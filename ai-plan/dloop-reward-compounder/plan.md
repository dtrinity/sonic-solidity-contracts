# DLoop Reward Compounder Bot — Implementation & Test Plan

## Overview

- Goal: Build a flashloan-based periphery and a bot that compounds rewards for `DLoopCoreDLend` by swapping flashloaned `dUSD` → collateral (e.g., `sfrxUSD`), depositing to mint shares, calling `compoundRewards` with those shares to realize rewards, repaying flash, and keeping surplus as profit.
- Contracts: New periphery in `bot/dloop-reward-compounder/contracts` with base + venue-specific (Odos) implementation.
- Bot: Standalone repo under `bot/dloop-reward-compounder` mirroring the style of `bot/dlend-liquidator` (Makefile, Dockerfile, hardhat, TypeScript runner, config, notifications).
- Decisioning: Bot first “quotes” profitability (thresholded by `exchangeThreshold`, fees, slippage) then triggers the on-chain periphery.
- Independence: The repo must be self-contained; all interfaces/types needed are vendored inside the bot repo.

References

- Logic/pseudocode: `ai-promt/dloop-reward-compounder/flashloan-reward-compounding-explanation.md`
- Reward quoting helper: `ai-promt/dloop-reward-compounder/reward-quoting-implementation.md`
- Style and structure reference: `bot/dlend-liquidator` and `/Users/dinosaurchi/Desktop/Project/stably-prime/trinity/dloop-rebalancer` (eslint setup)

## Repository Structure

Following `bot/dlend-liquidator`, adapted for reward compounding:

```
bot/dloop-reward-compounder/
  .env                      # Secrets and network config (not committed)
  .gitignore                # Copy from `bot/dlend-liquidator/.gitignore`
  .solhint.json
  .yarnrc.yml               # Copy from `bot/dlend-liquidator/.yarnrc.yml`
  Dockerfile
  Makefile
  eslint.config.mjs         # Copy from `bot/dlend-liquidator/eslint.config.mjs`
  hardhat.config.ts         # Copy from `bot/dlend-liquidator/hardhat.config.ts`
  jest.config.js            # Copy from `bot/dlend-liquidator/jest.config.js`
  package.json
  tsconfig.json
  yarn.lock                 # Generated by yarn install

  config/
    addresses.sonic_mainnet.json
    addresses.sonic_testnet.json
    odos.sonic_mainnet.json           # Optional swap-configs
    odos.sonic_testnet.json

  contracts/
    common/
      Constants.sol
    interface/
      IERC3156FlashBorrower.sol
      IERC3156FlashLender.sol
      IERC20.sol
      IDLoopCoreDLend.sol             # Minimal interface for deposit/compoundRewards, preview, threshold
      IRewardClaimable.sol            # Minimal subset if separated
      IOdosRouterV2.sol               # Copied from liquidator repo
    libraries/
      PercentageMath.sol              # If needed
    odos/
      OdosSwapUtils.sol               # Thin wrapper like in liquidator
    base/
      RewardCompounderDLendBase.sol   # Abstract orchestration, flash callback, accounting
    venue/
      RewardCompounderDLendOdos.sol   # Venue-specific swap execution (exactIn guarded by minOut)
    helpers/
      RewardHelper.sol                # From reward-quoting-implementation.md (adapt imports to local)

  deploy/
    00_deploy_reward_compounder_base.ts
    01_deploy_reward_compounder_odos.ts

  deployments/               # hardhat-deploy outputs (per network)

  scripts/
    sh/clean-deployments.sh

  state/                     # Docker runtime state (mounted volume)

  typescript/
    common/
      env.ts
      networks.ts
      addrs.ts               # Loads from config/ by network
      slack.ts               # Wrapper around @slack/web-api, similar to dlend-liquidator
    quoting/
      reward_quote.ts        # Off-chain estimator for profitability
    odos/
      route.ts               # Build/craft calldata for Odos swap (mocked in tests)
    bot/
      run.ts                 # Periodic runner: quote → if profitable, call periphery
      notify.ts              # Notify helper (success/failure)
      utils.ts               # Math, thresholds, basis points helpers

  test/
    contracts/
      mocks/
        MockERC20.sol
        MockOdosRouterV2.sol
        MockFlashLender.sol
        MockDLoopCoreDLend.sol        # Minimal core with deposit, compoundRewards, exchangeThreshold
      RewardCompounderDLendOdos.t.sol # Foundry/Hardhat-style mixed tests (we’ll use hardhat + TS tests)
    typescript/
      bot_full_flow.spec.ts           # Full-flow bot test with mocks
      swap_edgecases.spec.ts          # Slippage, exactIn/out, reverts
      notify.spec.ts                  # Slack mocked
```

Notes

- All interfaces vendored locally; do not rely on monorepo pathing.
- Reuse/conform to `eslint.config.mjs` from dloop-rebalancer.
- Makefile and Dockerfile modeled on `bot/dlend-liquidator` with target names adjusted.

## Contracts — Design & Responsibilities

1) RewardCompounderDLendBase.sol (abstract)

- Implements IERC3156FlashBorrower callback and shared flow:
  - Validates lender/token
  - Executes swap via virtual hook `_swapExactIn(dusdIn, minCollateralOut, swapData)`
  - Deposits collateral into Core: `deposit(assets, address(this))` → mints shares and receives `K` dUSD
  - Ensures `shares >= exchangeThreshold()` and optional `maxDeposit > 0`
  - Calls `compoundRewards(shares, [dUSD], address(this))`
  - Repays flash amount + fee
  - Emits detailed events: `RewardCompounded`, `FlashRepaid`, `Profit(realized)`
- Provides helpers:
  - `_previewDeposit(assets) → shares`
  - `_ensureProfitableOrRevert(expectedMinProfit)` with K/netZ accounting
  - `_approveIfNeeded(token, spender, amount)`
  - Access control for pausing/owner-only params (optional)

2) RewardCompounderDLendOdos.sol (venue-specific)

- Inherits Base, wires Odos router and swap execution.
- Swap is exactIn dUSD → collateral; guard using `minOut` from calldata to avoid exactIn/exactOut mismatch.
- Decodes calldata and calls Odos Router V2, checks received collateral balance delta.

3) RewardHelper.sol

- Implements the reward-quoting helper from `reward-quoting-implementation.md`.
- Adapt imports to local interfaces; used off-chain and optionally on-chain for sanity checks.

4) Mocks (test only)

- `MockDLoopCoreDLend`:
  - `deposit(assets, receiver) → shares` with deterministic ratio and transfers `K` dUSD to receiver
  - `compoundRewards(amount, rewardTokens, receiver)` burns shares and sends net rewards (treasury fee applied)
  - `exchangeThreshold()` and `treasuryFeeBps()` getters
- `MockFlashLender`: simple ERC3156 flash loaner with fixed fee bps
- `MockOdosRouterV2`: consumes `dUSD` and returns fixed collateral out subject to slippage param

## TypeScript Bot — Flow

1) Quote step

- Pull config by network (core address, lender, tokens, odos router, thresholds, feeBps, slippageBps)
- Read on-chain data: `exchangeThreshold`, treasury fee bps, `maxDeposit`
- Call price/route service (odos) or use mocked route in tests; compute:
  - `Y` collateral out for `X` dUSD in
  - `S = previewDeposit(Y)`
  - `K` estimation using preview or measure K delta in prior runs
  - `Z` rewards estimate via RewardHelper and vault state
- Break-even check: `K + netZ >= X + flashFee + swapCosts`
- If `S < exchangeThreshold` or not profitable, skip and notify (optional).

2) Execute step

- Build `swapCalldata` for Odos exactIn dUSD → collateral with `minOut` guard
- Call periphery: `run(flashAmount, swapCalldata, minCollateralOut)`
- Wait for receipt, parse events, and notify result.

3) Notify

- Use Slack via `@slack/web-api` (same pattern as `bot/dlend-liquidator/typescript/odos_bot/notification.ts`).
- Include profit, gas used, and reason for failure if reverted.

## Makefile Targets

- `compile`: `yarn hardhat compile --show-stack-traces`
- `deploy.contracts.sonic_mainnet`: `yarn hardhat deploy --network sonic_mainnet`
  - Reset variants with keyword filter `RewardCompounderDLend`
- `lint`: `lint.solidity` + `lint.typescript` (prettier-plugin-solidity, solhint, eslint)
- `docker.build.(arm64|amd64)`: same shape as liquidator; image name `reward-compounder-bot-sonic`
- `docker.run`: mounts `.env` and `state/`; args: `<network> odos`
- `deploy-local.bot.<network>` and `deploy-remote.bot` mirroring liquidator flow

## Hardhat Configuration

- Plugins: `@nomicfoundation/hardhat-toolbox`, `hardhat-deploy`, `typechain`
- Compiler: `0.8.20` with optimizer 200–1000 runs, via Prettier + Solhint
- Networks: `sonic_mainnet`, `sonic_testnet`, accounts via `.env`
- Paths: standard; artifacts included in Docker image during build

## ESLint/Formatting

- Copy `eslint.config.mjs` from dloop-rebalancer and reuse the same rules.
- Prettier with `prettier-plugin-solidity` for `.sol`.

## Deployment Scripts

1) `00_deploy_reward_compounder_base.ts`

- Deploy `RewardCompounderDLendBase` dependencies (if any utility libs), then `RewardHelper`.

2) `01_deploy_reward_compounder_odos.ts`

- Deploy `RewardCompounderDLendOdos` with ctor args: `core`, `dusd`, `collateral`, `flashLender`, `odosRouter`, `treasury`, config params (slippage bps, minProfit)
- Verify with Hardhat Etherscan if configured (optional)

Environment variables in `.env` (examples)

- RPC URLs: `SONIC_MAINNET_RPC`, `SONIC_TESTNET_RPC`
- Keys: `PRIVATE_KEY`
- Slack: `SONIC_MAINNET_SLACK_BOT_TOKEN`, `SONIC_MAINNET_SLACK_CHANNEL_ID`

## Detailed Implementation Steps

1) Scaffold repo

- Copy baseline from `bot/dlend-liquidator` (Makefile, Dockerfile, hardhat, eslint) and adjust names.
- Vendor required interfaces into `contracts/interface`.

2) Implement contracts

- Base contract with ERC3156 flash callback and flow control.
- Odos venue contract implementing `_swapExactIn` using `IOdosRouterV2` and `OdosSwapUtils` pattern; ensure exactIn vs exactOut consistency.
- RewardHelper per spec; adjust imports to local interfaces.

3) Implement TS bot

- Config loaders, quoting logic, swap route builder (mock Odos in tests), Slack notifier.
- Runner script that loops at interval or single-run by `make run.%` target.

4) Linting and scripts

- Ensure `make lint`, `yarn eslint .`, `yarn solhint`, and prettier are wired.

5) Dockerization

- Follow liquidator Dockerfile; copy artifacts, ts, configs, and run `node dist/...` via hardhat.

6) Deployment scripts

- Write `hardhat-deploy` scripts for base/helper and odos periphery.

7) Testing (contracts + TS)

- Add mocks and unit/integration style tests under `test/`.
- Mock external services (Slack, Odos API) — no real network calls.

## Test Plan (with Mock Test Cases)

Contract-level (Hardhat + TS tests using ethers.js):

1) Successful compounding flow (happy path)

- Setup: Deploy `MockERC20 dUSD`, `MockERC20 sfrxUSD`, `MockFlashLender` (fee = 8 bps), `MockOdosRouterV2` (exactIn quote slippage 10 bps), `MockDLoopCoreDLend` with target leverage and treasuryFeeBps = 100 (1%).
- Action: Call `RewardCompounderDLendOdos.run(X, swapCalldata, minCollateralOut)` with X = 100k dUSD; router returns Y, deposit mints S and transfers K dUSD; compound rewards returns netZ.
- Assert: Flash repaid, profit = K + netZ - (X + fee + swapCosts) > 0; events emitted; no approvals required from the bot caller.

2) Revert when exchangeThreshold not met

- Setup: `exchangeThreshold = S+1`; route yields smaller Y → S below threshold.
- Assert: Revert with descriptive error from base.

3) Revert when not enough to repay flash

- Setup: Very low Z (rewards) or high slippage so `K + netZ < X + fee + swapCosts`.
- Assert: Revert before final approve to lender; dUSD balance invariant checked.

4) Treasury fee applied correctly

- Setup: treasuryFeeBps = 100; raw Z emitted by mock; base receives `Z * (1 - 0.01)`.
- Assert: NetZ used in profit calc and in final DUSD balance.

5) Odos exactIn guard and minOut

- Setup: `minOut = Y*(1 - slippageBps)`; router returns below `minOut`.
- Assert: Swap revert and entire transaction reverts; no partial state changes.

6) Core disabled deposit

- Setup: `maxDeposit(address(this)) = 0` in mock.
- Assert: Pre-check reverts with “deposit disabled”.

7) Events coverage

- Assert: `RewardCompounded(shares, netZ)`, `FlashRepaid(amount, fee)`, `Profit(realized)` logged with expected values.

TypeScript bot-level (with mocks):

8) Quoting determines profitable run

- Mock RewardHelper return values and Odos route to yield `K + netZ >= X + fee + swapCosts`.
- Assert: Bot proceeds to call periphery `run()` with correct calldata and `minOut`.

9) Quoting skips unprofitable run

- Mock lower Z or higher slippage.
- Assert: Bot logs and sends Slack “skip” notification; no periphery call.

10) Slack notification success/failure

- Mock Slack client; assert message contents include network, tx hash, profit or error message.

11) Config loading

- Assert: Loads addresses from `config/addresses.<network>.json`; environment overrides honored.

12) Docker entry

- Smoke test: container command resolves network arg, loads `.env`, and starts run script; no external network calls in tests.

Test Utilities

- Deterministic math helpers; unify basis points handling; mock block timestamps when needed.

## Review Checklist (self-review against requirements)

- Contracts compile with `make compile`.
- Deployment scripts present and correct for `make deploy.sonic_mainnet` (no need to execute, just correctness and ready-to-run).
- Swap logic exactIn vs exactOut: enforced minOut guard; no mismatched mode.
- ESLint rules mirror dloop-rebalancer; `make lint` passes.
- `make test` passes with mocks; all external resources mocked (Slack, Odos API).
- Repo is self-contained; copying any missing interfaces into `contracts/interface`.
- No token approvals required from off-chain bot user; periphery handles approvals internally during flash callback.

## Risks & Mitigations

- Front-running on rewards claim: consider private endpoints in production (out of scope for tests).
- Oracle/preview drift: rely on `previewDeposit` and guards; conservative `minOut`.
- Flash capacity limits: parameterize `flashAmount` and handle lender errors.
- Reentrancy: follow checks-effects-interactions and use nonReentrant in base if needed.

## Next Steps

1) Scaffold repo and vendor interfaces
2) Implement base + Odos contracts
3) Implement RewardHelper
4) Write deploy scripts and config
5) Implement TS quoting + bot runner + notifications
6) Add mocks and tests, ensure `make lint/test` pass
7) Prepare Docker image and run scripts
