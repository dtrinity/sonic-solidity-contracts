import { expect } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { ethers } from "hardhat";
import {
  BURST_ONE,
  BURST_TWO,
  COLLATERAL_DECIMALS,
  COLLATERAL_TO_SWAP,
  FLASH_SWAP_AMOUNT,
  FLASH_MINT_AMOUNT,
  DUSD_DECIMALS,
  SAME_ASSET_DUST,
  deployOdosV1ExploitFixture,
  createMaliciousSwapData,
  OdosV1ExploitFixture,
} from "../v1/fixtures/setup";

/**
 * V2 Exploit Prevention Tests
 *
 * These tests verify that the V2 adapters with msg.sender-only design
 * successfully prevent the authentication bypass attack that affected V1.
 *
 * Key differences from V1:
 * - V2 adapters removed the user parameter entirely - always use msg.sender internally
 * - V2 adapters have oracle price validation (5% tolerance)
 * - V2 adapters support PT tokens via composed swaps
 *
 * Attack vector from V1 (now impossible in V2):
 * - V1 allowed attacker to specify params.user (victim's address) without validation
 * - V2 eliminates this by removing user parameter - operations always affect msg.sender
 * - No way for attacker to execute operations on victim's behalf
 *
 * Note: Many tests below are now obsolete as they test the old user parameter
 * authentication model. They're kept for historical reference and comparison with V1.
 */

describe("Odos V2 Adapters - Exploit Prevention", function () {
  /**
   * Test: OdosLiquiditySwapAdapterV2 prevents unauthorized execution
   *
   * This test verifies that V2's msg.sender check prevents the exact attack
   * that succeeded against V1. The attacker should be blocked at the entry point.
   */
  describe("OdosLiquiditySwapAdapterV2 - Authentication Enforcement", function () {
    it("üõ°Ô∏è should reject attack when msg.sender != params.user (no flash loan)", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, attacker, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      // Deploy V2 adapter with msg.sender enforcement
      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set oracle prices to pass validation (if attack gets that far)
      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      // Victim approves the V2 adapter (simulating pre-existing approval)
      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), COLLATERAL_TO_SWAP);

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: COLLATERAL_TO_SWAP,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: SAME_ASSET_DUST,
        user: victim.address, // Attacker tries to impersonate victim
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      const victimBalanceBefore = await aWstkscUsd.balanceOf(victim.address);

      // Attack should be rejected immediately with InitiatorMustBeThis error
      // msg.sender (attacker) != params.user (victim)
      await expect(adapterV2.connect(attacker).swapLiquidity(liquiditySwapParams, permitInput))
        .to.be.revertedWithCustomError(adapterV2, "InitiatorMustBeThis")
        .withArgs(attacker.address, victim.address);

      // Verify victim's collateral was NOT drained
      const victimBalanceAfter = await aWstkscUsd.balanceOf(victim.address);
      expect(victimBalanceAfter).to.equal(victimBalanceBefore);
      expect(victimBalanceAfter).to.equal(COLLATERAL_TO_SWAP);
    });

    it("üõ°Ô∏è should reject attack when msg.sender != params.user (with flash loan)", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const {
        deployer,
        victim,
        attacker,
        attackerBeneficiary,
        reserveManager,
        addressesProvider,
        pool,
        router,
        wstkscUsd,
        aWstkscUsd,
        priceOracle,
      } = fixture;

      // Deploy V2 adapter
      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set oracle prices
      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      // Configure pool for flash loan scenario
      const EXTRA_COLLATERAL = BURST_ONE + BURST_TWO + (COLLATERAL_TO_SWAP * 5n) / 10_000n;
      await pool
        .connect(deployer)
        .configureReserve(await wstkscUsd.getAddress(), reserveManager.address, await adapterV2.getAddress(), 5, EXTRA_COLLATERAL);

      // Setup router for flash loan case
      await router.setSwapBehaviourWithDust(
        await wstkscUsd.getAddress(),
        await wstkscUsd.getAddress(),
        FLASH_SWAP_AMOUNT,
        SAME_ASSET_DUST,
        false,
        attacker.address,
      );

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), COLLATERAL_TO_SWAP);

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: COLLATERAL_TO_SWAP,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: SAME_ASSET_DUST,
        user: victim.address, // Attacker tries to impersonate victim
        withFlashLoan: true,
        swapData,
        allBalanceOffset: 0n,
      };

      const victimBalanceBefore = await aWstkscUsd.balanceOf(victim.address);
      const attackerBalanceBefore = await wstkscUsd.balanceOf(attackerBeneficiary.address);

      // Attack should be rejected before flash loan is even initiated
      await expect(adapterV2.connect(attacker).swapLiquidity(liquiditySwapParams, permitInput))
        .to.be.revertedWithCustomError(adapterV2, "InitiatorMustBeThis")
        .withArgs(attacker.address, victim.address);

      // Verify complete state preservation
      const victimBalanceAfter = await aWstkscUsd.balanceOf(victim.address);
      const attackerBalanceAfter = await wstkscUsd.balanceOf(attackerBeneficiary.address);

      expect(victimBalanceAfter).to.equal(victimBalanceBefore);
      expect(victimBalanceAfter).to.equal(COLLATERAL_TO_SWAP);
      expect(attackerBalanceAfter).to.equal(attackerBalanceBefore);
      expect(attackerBalanceAfter).to.equal(0n);
    });

    it("‚úÖ should allow legitimate user to execute their own swap", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set oracle prices
      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      // Setup legitimate swap (victim calls for themselves)
      const swapAmount = ethers.parseUnits("100", COLLATERAL_DECIMALS);
      await wstkscUsd.mint(victim.address, swapAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), swapAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), swapAmount, victim.address, 0);

      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), swapAmount);

      // Configure router for legitimate swap - return to adapter, not victim
      await router.setSwapBehaviourWithDust(
        await wstkscUsd.getAddress(),
        await wstkscUsd.getAddress(),
        swapAmount,
        swapAmount, // Return same amount (legitimate swap)
        false,
        victim.address, // Return to victim directly
      );

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: swapAmount,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: swapAmount,
        user: victim.address, // Victim is the caller
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Legitimate call should NOT be reverted with InitiatorMustBeThis
      // (may fail for other reasons like oracle/swap validation, but not authentication)
      const tx = adapterV2.connect(victim).swapLiquidity(liquiditySwapParams, permitInput);
      await expect(tx).to.not.be.revertedWithCustomError(adapterV2, "InitiatorMustBeThis");
    });
  });

  /**
   * Test: OdosRepayAdapterV2 prevents unauthorized execution
   */
  describe("OdosRepayAdapterV2 - Authentication Enforcement", function () {
    it("üõ°Ô∏è should reject attack when msg.sender != params.user", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, attacker, addressesProvider, pool, router, wstkscUsd, dusd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosRepayAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set oracle prices
      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));
      await priceOracle.setPrice(await dusd.getAddress(), ethers.parseUnits("1", 8));

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), COLLATERAL_TO_SWAP);

      const repayParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmount: COLLATERAL_TO_SWAP,
        debtAsset: await dusd.getAddress(),
        repayAmount: ethers.parseUnits("1000", DUSD_DECIMALS),
        rateMode: 2,
        withFlashLoan: false,
        user: victim.address, // Attacker tries to impersonate victim
        minAmountToReceive: 0n,
        swapData,
        allBalanceOffset: 0n,
      };

      const victimBalanceBefore = await aWstkscUsd.balanceOf(victim.address);

      // Attack should be rejected with InitiatorMustBeThis
      await expect(adapterV2.connect(attacker).repayWithCollateral(repayParams, permitInput))
        .to.be.revertedWithCustomError(adapterV2, "InitiatorMustBeThis")
        .withArgs(attacker.address, victim.address);

      // Verify victim's collateral was NOT drained
      const victimBalanceAfter = await aWstkscUsd.balanceOf(victim.address);
      expect(victimBalanceAfter).to.equal(victimBalanceBefore);
    });

    it("‚úÖ should allow legitimate user to execute their own repay", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, dusd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosRepayAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set oracle prices
      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));
      await priceOracle.setPrice(await dusd.getAddress(), ethers.parseUnits("1", 8));

      // Setup legitimate repay scenario
      const collateralAmount = ethers.parseUnits("100", COLLATERAL_DECIMALS);
      const debtAmount = ethers.parseUnits("95", DUSD_DECIMALS);

      await wstkscUsd.mint(victim.address, collateralAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), collateralAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), collateralAmount, victim.address, 0);

      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), collateralAmount);

      // Configure router for legitimate swap
      await router.setSwapBehaviourWithDust(
        await wstkscUsd.getAddress(),
        await dusd.getAddress(),
        collateralAmount,
        debtAmount,
        false,
        await adapterV2.getAddress(),
      );

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const repayParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmount: collateralAmount,
        debtAsset: await dusd.getAddress(),
        repayAmount: debtAmount,
        rateMode: 2,
        withFlashLoan: false,
        user: victim.address, // Victim is the caller
        minAmountToReceive: 0n,
        swapData,
        allBalanceOffset: 0n,
      };

      // Legitimate call should succeed (msg.sender == params.user)
      // Note: This may still fail due to oracle validation or other checks,
      // but it should NOT fail with InitiatorMustBeThis
      const tx = adapterV2.connect(victim).repayWithCollateral(repayParams, permitInput);
      await expect(tx).to.not.be.revertedWithCustomError(adapterV2, "InitiatorMustBeThis");
    });
  });

  /**
   * Test: OdosWithdrawSwapAdapterV2 prevents unauthorized execution
   */
  describe("OdosWithdrawSwapAdapterV2 - Authentication Enforcement", function () {
    it("üõ°Ô∏è should reject attack when msg.sender != params.user", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, attacker, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosWithdrawSwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set oracle prices
      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), COLLATERAL_TO_SWAP);

      const withdrawSwapParams = {
        oldAsset: await wstkscUsd.getAddress(),
        oldAssetAmount: COLLATERAL_TO_SWAP,
        newAsset: await wstkscUsd.getAddress(),
        minAmountToReceive: SAME_ASSET_DUST,
        user: victim.address, // Attacker tries to impersonate victim
        swapData,
        allBalanceOffset: 0n,
      };

      const victimBalanceBefore = await aWstkscUsd.balanceOf(victim.address);

      // Attack should be rejected with InitiatorMustBeThis
      await expect(adapterV2.connect(attacker).withdrawAndSwap(withdrawSwapParams, permitInput))
        .to.be.revertedWithCustomError(adapterV2, "InitiatorMustBeThis")
        .withArgs(attacker.address, victim.address);

      // Verify victim's collateral was NOT drained
      const victimBalanceAfter = await aWstkscUsd.balanceOf(victim.address);
      expect(victimBalanceAfter).to.equal(victimBalanceBefore);
    });

    it("‚úÖ should allow legitimate user to execute their own withdraw", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosWithdrawSwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set oracle prices
      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const withdrawAmount = ethers.parseUnits("50", COLLATERAL_DECIMALS);
      await wstkscUsd.mint(victim.address, withdrawAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), withdrawAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), withdrawAmount, victim.address, 0);

      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), withdrawAmount);

      // Configure router for legitimate swap
      await router.setSwapBehaviourWithDust(
        await wstkscUsd.getAddress(),
        await wstkscUsd.getAddress(),
        withdrawAmount,
        withdrawAmount,
        false,
        await adapterV2.getAddress(),
      );

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const withdrawSwapParams = {
        oldAsset: await wstkscUsd.getAddress(),
        oldAssetAmount: withdrawAmount,
        newAsset: await wstkscUsd.getAddress(),
        minAmountToReceive: withdrawAmount,
        user: victim.address, // Victim is the caller
        swapData,
        allBalanceOffset: 0n,
      };

      // Legitimate call should succeed (msg.sender == params.user)
      const tx = adapterV2.connect(victim).withdrawAndSwap(withdrawSwapParams, permitInput);
      await expect(tx).to.not.be.revertedWithCustomError(adapterV2, "InitiatorMustBeThis");
    });
  });

  /**
   * Test: Oracle validation provides additional defense layer
   *
   * Even if authentication were somehow bypassed, V2's oracle validation
   * should catch suspicious swap ratios (like returning dust for full collateral).
   */
  describe("V2 Oracle Validation - Defense in Depth", function () {
    it("üõ°Ô∏è should reject dust-output swaps via oracle deviation check", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set oracle prices (same price for both assets)
      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const swapAmount = ethers.parseUnits("1000", COLLATERAL_DECIMALS);
      await wstkscUsd.mint(victim.address, swapAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), swapAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), swapAmount, victim.address, 0);

      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), swapAmount);

      // Configure router to return dust (1 micro-unit) for large input
      await router.setSwapBehaviourWithDust(
        await wstkscUsd.getAddress(),
        await wstkscUsd.getAddress(),
        swapAmount,
        1n, // Dust output
        false,
        await adapterV2.getAddress(),
      );

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: swapAmount,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: 1n, // Dust output
        user: victim.address, // Legitimate caller (victim)
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Even with legitimate caller, oracle should reject dust output
      // Expected output = 1000, actual minOut = 1, deviation = 99.9% >> 5% tolerance
      await expect(adapterV2.connect(victim).swapLiquidity(liquiditySwapParams, permitInput)).to.be.revertedWithCustomError(
        adapterV2,
        "OraclePriceDeviationExceeded",
      );
    });

    it("üõ°Ô∏è should reject zero-price oracle attacks", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set zero price (simulating unconfigured oracle or manipulation attempt)
      await priceOracle.setPrice(await wstkscUsd.getAddress(), 0n);

      const swapAmount = ethers.parseUnits("100", COLLATERAL_DECIMALS);
      await wstkscUsd.mint(victim.address, swapAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), swapAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), swapAmount, victim.address, 0);

      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), swapAmount);

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: swapAmount,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: swapAmount,
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Should reject due to zero oracle price with clear error
      await expect(adapterV2.connect(victim).swapLiquidity(liquiditySwapParams, permitInput)).to.be.revertedWithCustomError(
        adapterV2,
        "ZeroOraclePrice",
      );
    });
  });

  /**
   * Test: Comprehensive attack scenario comparison
   *
   * This test attempts the full V1 attack flow against V2 adapters
   * and verifies complete protection at multiple layers.
   */
  describe("Full Attack Scenario - V1 vs V2 Comparison", function () {
    it("üìä V2 blocks attack that would succeed on V1", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, attacker, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      // Deploy V2 adapter
      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set oracle prices for V2
      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      // Setup: Victim approves V2 adapter
      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), COLLATERAL_TO_SWAP);

      const liquiditySwapParamsV2 = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: COLLATERAL_TO_SWAP,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: SAME_ASSET_DUST,
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // V2: Attack fails (authentication enforced)
      const victimBalanceBeforeV2 = await aWstkscUsd.balanceOf(victim.address);

      await expect(adapterV2.connect(attacker).swapLiquidity(liquiditySwapParamsV2, permitInput))
        .to.be.revertedWithCustomError(adapterV2, "InitiatorMustBeThis")
        .withArgs(attacker.address, victim.address);

      const victimBalanceAfterV2 = await aWstkscUsd.balanceOf(victim.address);

      // Verify V2 protected the victim
      expect(victimBalanceAfterV2).to.equal(victimBalanceBeforeV2);
      expect(victimBalanceAfterV2).to.equal(COLLATERAL_TO_SWAP);

      console.log("\n=== V2 Attack Prevention ===");
      console.log(`V2 (protected): Attack blocked at authentication layer`);
      console.log(`Victim balance preserved: ${ethers.formatUnits(victimBalanceAfterV2, COLLATERAL_DECIMALS)} wstkscUSD`);
      console.log("============================\n");
    });
  });

  /**
   * Test: Multi-adapter attack surface verification
   *
   * Verify that ALL V2 adapters enforce msg.sender == user consistently
   */
  describe("Multi-Adapter Attack Surface", function () {
    it("üõ°Ô∏è should enforce authentication across all V2 adapters", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, attacker, addressesProvider, pool, router, wstkscUsd, dusd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;

      // Deploy all V2 adapters
      const LiquidityAdapterFactory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const liquidityAdapter = await LiquidityAdapterFactory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      const RepayAdapterFactory = await ethers.getContractFactory("OdosRepayAdapterV2");
      const repayAdapter = await RepayAdapterFactory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      const WithdrawAdapterFactory = await ethers.getContractFactory("OdosWithdrawSwapAdapterV2");
      const withdrawAdapter = await WithdrawAdapterFactory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set oracle prices
      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));
      await priceOracle.setPrice(await dusd.getAddress(), ethers.parseUnits("1", 8));

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      // Test 1: LiquiditySwapAdapterV2
      const liquidityParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: COLLATERAL_TO_SWAP,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: SAME_ASSET_DUST,
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      await expect(liquidityAdapter.connect(attacker).swapLiquidity(liquidityParams, permitInput)).to.be.revertedWithCustomError(
        liquidityAdapter,
        "InitiatorMustBeThis",
      );

      // Test 2: RepayAdapterV2
      const repayParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmount: COLLATERAL_TO_SWAP,
        debtAsset: await dusd.getAddress(),
        repayAmount: ethers.parseUnits("1000", DUSD_DECIMALS),
        rateMode: 2,
        withFlashLoan: false,
        user: victim.address,
        minAmountToReceive: 0n,
        swapData,
        allBalanceOffset: 0n,
      };

      await expect(repayAdapter.connect(attacker).repayWithCollateral(repayParams, permitInput)).to.be.revertedWithCustomError(
        repayAdapter,
        "InitiatorMustBeThis",
      );

      // Test 3: WithdrawSwapAdapterV2
      const withdrawParams = {
        oldAsset: await wstkscUsd.getAddress(),
        oldAssetAmount: COLLATERAL_TO_SWAP,
        newAsset: await wstkscUsd.getAddress(),
        minAmountToReceive: SAME_ASSET_DUST,
        user: victim.address,
        swapData,
        allBalanceOffset: 0n,
      };

      await expect(withdrawAdapter.connect(attacker).withdrawAndSwap(withdrawParams, permitInput)).to.be.revertedWithCustomError(
        withdrawAdapter,
        "InitiatorMustBeThis",
      );

      console.log("\n=== Multi-Adapter Protection Verified ===");
      console.log("‚úì OdosLiquiditySwapAdapterV2: Authentication enforced");
      console.log("‚úì OdosRepayAdapterV2: Authentication enforced");
      console.log("‚úì OdosWithdrawSwapAdapterV2: Authentication enforced");
      console.log("==========================================\n");
    });
  });

  /**
   * Test: Edge cases and boundary conditions
   */
  describe("Edge Cases - V2 Protection Boundaries", function () {
    it("üõ°Ô∏è should reject even with valid permit signature when caller != user", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, attacker, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const swapAmount = ethers.parseUnits("100", COLLATERAL_DECIMALS);
      await wstkscUsd.mint(victim.address, swapAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), swapAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), swapAmount, victim.address, 0);

      // Even with a valid permit, attacker cannot execute for victim
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: swapAmount,
        deadline: ethers.MaxUint256,
        v: 27,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const swapData = createMaliciousSwapData(router);

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: swapAmount,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: swapAmount,
        user: victim.address, // Victim's address
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Should fail at authentication check BEFORE permit is even processed
      await expect(adapterV2.connect(attacker).swapLiquidity(liquiditySwapParams, permitInput)).to.be.revertedWithCustomError(
        adapterV2,
        "InitiatorMustBeThis",
      );
    });

    it("üõ°Ô∏è should reject attack even with allBalanceOffset set", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, attacker, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), COLLATERAL_TO_SWAP);

      // Attacker tries to use allBalanceOffset to drain entire balance
      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: 0n, // Will be overridden by allBalanceOffset
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: SAME_ASSET_DUST,
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 1n, // Non-zero triggers balance lookup
      };

      // Should still fail at authentication check
      await expect(adapterV2.connect(attacker).swapLiquidity(liquiditySwapParams, permitInput)).to.be.revertedWithCustomError(
        adapterV2,
        "InitiatorMustBeThis",
      );
    });
  });

  /**
   * Test: Zero-amount parameter protection
   *
   * Verify that oracle validation rejects zero amounts before division
   */
  describe("Zero-Amount Protection", function () {
    it("üõ°Ô∏è should reject zero amountIn in exact input swaps", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: 0n, // Zero amount
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: ethers.parseUnits("100", COLLATERAL_DECIMALS),
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Should reject zero amountIn with clear error
      await expect(adapterV2.connect(victim).swapLiquidity(liquiditySwapParams, permitInput)).to.be.revertedWithCustomError(
        adapterV2,
        "ZeroSwapAmount",
      );
    });

    it("üõ°Ô∏è should reject zero minAmountOut in exact input swaps", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const swapAmount = ethers.parseUnits("100", COLLATERAL_DECIMALS);
      await wstkscUsd.mint(victim.address, swapAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), swapAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), swapAmount, victim.address, 0);
      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), swapAmount);

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: swapAmount,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: 0n, // Zero minAmountOut
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Should reject zero minAmountOut with clear error
      await expect(adapterV2.connect(victim).swapLiquidity(liquiditySwapParams, permitInput)).to.be.revertedWithCustomError(
        adapterV2,
        "ZeroSwapAmount",
      );
    });

    it("üõ°Ô∏è should reject zero maxAmountIn in exact output swaps", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, dusd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosRepayAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));
      await priceOracle.setPrice(await dusd.getAddress(), ethers.parseUnits("1", 8));

      // Setup: mint collateral but pass zero collateralAmount (maxAmountIn)
      const collateralAmount = ethers.parseUnits("100", COLLATERAL_DECIMALS);
      await wstkscUsd.mint(victim.address, collateralAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), collateralAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), collateralAmount, victim.address, 0);
      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), collateralAmount);

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const repayParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmount: 0n, // Zero maxAmountIn
        debtAsset: await dusd.getAddress(),
        repayAmount: ethers.parseUnits("95", DUSD_DECIMALS),
        rateMode: 2,
        withFlashLoan: false,
        user: victim.address,
        minAmountToReceive: 0n,
        swapData,
        allBalanceOffset: 0n,
      };

      // Should reject zero maxAmountIn (collateralAmount)
      // May fail at balance check or oracle validation
      await expect(adapterV2.connect(victim).repayWithCollateral(repayParams, permitInput)).to.be.reverted;
    });
  });

  /**
   * Test: Oracle deviation boundary conditions
   *
   * Verify behavior at and around the 5% tolerance threshold
   */
  describe("Oracle Deviation Boundary Tests", function () {
    it("‚úÖ should accept swap at 4.99% deviation (within tolerance)", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const inputAmount = ethers.parseUnits("1000", COLLATERAL_DECIMALS);
      const expectedOutput = ethers.parseUnits("1000", COLLATERAL_DECIMALS);
      // 4.99% deviation: output = expected * 0.9501 = 950.1
      const minOutput = ethers.parseUnits("950.1", COLLATERAL_DECIMALS);

      await wstkscUsd.mint(victim.address, inputAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), inputAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), inputAmount, victim.address, 0);
      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), inputAmount);

      await router.setSwapBehaviourWithDust(
        await wstkscUsd.getAddress(),
        await wstkscUsd.getAddress(),
        inputAmount,
        minOutput,
        false,
        victim.address,
      );

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: inputAmount,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: minOutput,
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Should NOT revert (within 5% tolerance)
      const tx = adapterV2.connect(victim).swapLiquidity(liquiditySwapParams, permitInput);
      await expect(tx).to.not.be.revertedWithCustomError(adapterV2, "OraclePriceDeviationExceeded");
    });

    it("üõ°Ô∏è should reject swap at 5.01% deviation (exceeds tolerance)", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const inputAmount = ethers.parseUnits("1000", COLLATERAL_DECIMALS);
      // 5.01% deviation: output = expected * 0.9499 = 949.9
      const minOutput = ethers.parseUnits("949.9", COLLATERAL_DECIMALS);

      await wstkscUsd.mint(victim.address, inputAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), inputAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), inputAmount, victim.address, 0);
      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), inputAmount);

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: inputAmount,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: minOutput,
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Should revert (exceeds 5% tolerance)
      await expect(adapterV2.connect(victim).swapLiquidity(liquiditySwapParams, permitInput)).to.be.revertedWithCustomError(
        adapterV2,
        "OraclePriceDeviationExceeded",
      );
    });

    it("‚úÖ should accept swap at exactly 5.00% deviation (at boundary)", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const inputAmount = ethers.parseUnits("1000", COLLATERAL_DECIMALS);
      // Exactly 5.00% deviation: output = expected * 0.95 = 950
      const minOutput = ethers.parseUnits("950", COLLATERAL_DECIMALS);

      await wstkscUsd.mint(victim.address, inputAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), inputAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), inputAmount, victim.address, 0);
      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), inputAmount);

      await router.setSwapBehaviourWithDust(
        await wstkscUsd.getAddress(),
        await wstkscUsd.getAddress(),
        inputAmount,
        minOutput,
        false,
        victim.address,
      );

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: inputAmount,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: minOutput,
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Should NOT revert (exactly at 5% tolerance)
      const tx = adapterV2.connect(victim).swapLiquidity(liquiditySwapParams, permitInput);
      await expect(tx).to.not.be.revertedWithCustomError(adapterV2, "OraclePriceDeviationExceeded");
    });
  });

  /**
   * Test: Large number overflow protection
   *
   * Verify that SafeOracleMath prevents overflow in extreme scenarios
   */
  describe("Overflow Protection - Large Numbers", function () {
    it("‚úÖ should handle large amounts without overflow in oracle math", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Set high oracle price to test large number multiplication
      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("10000", 8)); // $10,000 per token

      // Use large but realistic amount
      const largeAmount = ethers.parseUnits("10000000", COLLATERAL_DECIMALS); // 10 million tokens
      const expectedOutput = (largeAmount * 95n) / 100n; // 5% slippage

      await wstkscUsd.mint(victim.address, largeAmount);
      await wstkscUsd.connect(victim).approve(await pool.getAddress(), largeAmount);
      await pool.connect(victim).supply(await wstkscUsd.getAddress(), largeAmount, victim.address, 0);
      await aWstkscUsd.connect(victim).approve(await adapterV2.getAddress(), largeAmount);

      await router.setSwapBehaviourWithDust(
        await wstkscUsd.getAddress(),
        await wstkscUsd.getAddress(),
        largeAmount,
        expectedOutput,
        false,
        victim.address,
      );

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: largeAmount,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: expectedOutput,
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Should NOT overflow in oracle math (SafeOracleMath prevents it)
      // Transaction should complete oracle validation without panic
      const tx = adapterV2.connect(victim).swapLiquidity(liquiditySwapParams, permitInput);
      await expect(tx).to.not.be.revertedWithPanic();
    });

    it("‚úÖ should handle extreme price ratios without overflow", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, addressesProvider, pool, router, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      // Deploy test tokens with different decimals
      const TestMintableERC20Factory = await ethers.getContractFactory("TestMintableERC20");
      const token6 = await TestMintableERC20Factory.deploy("Token6", "T6", 6);
      const token18 = await TestMintableERC20Factory.deploy("Token18", "T18", 18);

      // Set extreme price ratio: 1:1,000,000
      await priceOracle.setPrice(await token6.getAddress(), ethers.parseUnits("1", 8)); // $1
      await priceOracle.setPrice(await token18.getAddress(), ethers.parseUnits("1000000", 8)); // $1M

      // Setup pool and aToken for token6
      const MockATokenFactory = await ethers.getContractFactory("MockAToken");
      const aToken6 = await MockATokenFactory.deploy("aToken6", "aT6", 6, await pool.getAddress());
      await pool.setReserveData(await token6.getAddress(), await aToken6.getAddress(), ethers.ZeroAddress, ethers.ZeroAddress);

      const amount = ethers.parseUnits("1000", 6); // 1000 token6
      await token6.mint(victim.address, amount);
      await token6.connect(victim).approve(await pool.getAddress(), amount);
      await pool.connect(victim).supply(await token6.getAddress(), amount, victim.address, 0);
      await aToken6.connect(victim).approve(await adapterV2.getAddress(), amount);

      // Expected: need ~1,000,000 token6 to get 1 token18 (with decimal adjustment)
      // With 5% tolerance: up to 1,050,000 token6
      const expectedOut = ethers.parseUnits("0.001", 18); // Very small output due to price ratio

      await router.setSwapBehaviourWithDust(
        await token6.getAddress(),
        await token18.getAddress(),
        amount,
        expectedOut,
        false,
        victim.address,
      );

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aToken6.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const liquiditySwapParams = {
        collateralAsset: await token6.getAddress(),
        collateralAmountToSwap: amount,
        newCollateralAsset: await token18.getAddress(),
        newCollateralAmount: expectedOut,
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Should handle extreme price ratio without overflow
      const tx = adapterV2.connect(victim).swapLiquidity(liquiditySwapParams, permitInput);
      // May revert for other reasons, but NOT due to overflow
      await expect(tx).to.not.be.revertedWithPanic();
    });
  });

  /**
   * Test: Documentation and reporting
   *
   * Verify that error messages provide clear information for security monitoring
   */
  describe("Security Monitoring - Error Clarity", function () {
    it("üìù should emit clear error with actual vs expected addresses", async function () {
      const fixture = await loadFixture(deployOdosV1ExploitFixture);
      const { deployer, victim, attacker, addressesProvider, pool, router, wstkscUsd, aWstkscUsd, priceOracle } = fixture;

      const pendleRouter = ethers.Wallet.createRandom().address;
      const AdapterV2Factory = await ethers.getContractFactory("OdosLiquiditySwapAdapterV2");
      const adapterV2 = await AdapterV2Factory.deploy(
        await addressesProvider.getAddress(),
        await pool.getAddress(),
        await router.getAddress(),
        pendleRouter,
        deployer.address,
      );

      await priceOracle.setPrice(await wstkscUsd.getAddress(), ethers.parseUnits("1", 8));

      const swapData = createMaliciousSwapData(router);
      const permitInput = {
        aToken: await aWstkscUsd.getAddress(),
        value: 0n,
        deadline: 0n,
        v: 0,
        r: ethers.ZeroHash,
        s: ethers.ZeroHash,
      };

      const liquiditySwapParams = {
        collateralAsset: await wstkscUsd.getAddress(),
        collateralAmountToSwap: COLLATERAL_TO_SWAP,
        newCollateralAsset: await wstkscUsd.getAddress(),
        newCollateralAmount: SAME_ASSET_DUST,
        user: victim.address,
        withFlashLoan: false,
        swapData,
        allBalanceOffset: 0n,
      };

      // Verify error includes both addresses for forensic analysis
      await expect(adapterV2.connect(attacker).swapLiquidity(liquiditySwapParams, permitInput))
        .to.be.revertedWithCustomError(adapterV2, "InitiatorMustBeThis")
        .withArgs(attacker.address, victim.address);
    });
  });
});
