import { expect } from "chai";
import { ethers } from "hardhat";

import {
  COLLATERAL_DECIMALS,
  deployDLoopMockFixture,
  testSetup,
} from "./DLoopCoreMock/fixture";

const parseUnits = (val: string | number, decimals: number): bigint =>
  ethers.parseUnits(val.toString(), decimals);

describe("dLOOP zero-share vulnerability", function () {
  let vault: any;
  let collateralToken: any;
  let deployer: any;
  // eslint-disable-next-line unused-imports/no-unused-vars -- just for testing
  let feeManager: any; // none, but use deployer
  let victim: any;

  beforeEach(async () => {
    const fixture = await deployDLoopMockFixture();
    await testSetup(fixture);

    ({ dloopMock: vault, collateralToken, deployer } = fixture as any);
    victim = fixture.user1;
    feeManager = deployer;

    // Mint collateral to deployer for initial seed deposit and approve vault
    await collateralToken.mint(
      deployer.address,
      parseUnits("2000", COLLATERAL_DECIMALS),
    );
    await collateralToken
      .connect(deployer)
      .approve(await vault.getAddress(), ethers.MaxUint256);

    // Seed deposit by deployer
    const seed = parseUnits("1000", COLLATERAL_DECIMALS);
    await vault.connect(deployer).deposit(seed, deployer.address);

    // Redeem everything to reset supply
    const shares = await vault.balanceOf(deployer.address);
    await vault
      .connect(deployer)
      .redeem(shares, deployer.address, deployer.address);

    // At this point vault has debt > collateral (due to withdrawal fee = 0 issues), bring it
    // back into valid leverage range by supplying just enough collateral on behalf of vault.

    const [collBaseRaw, debtBaseRaw] =
      await vault.getTotalCollateralAndDebtOfUserInBase(
        await vault.getAddress(),
      );

    const collBase = BigInt(collBaseRaw);
    const debtBase = BigInt(debtBaseRaw);

    if (collBase < debtBase) {
      // Calculate collateral required so that leverage equals target 3x (30000 bps)
      const targetBps = 30000n;
      const numerator = debtBase * targetBps;
      const denominator = targetBps - 10000n;
      const desiredCollBase = (numerator + denominator - 1n) / denominator; // ceil division
      const deficitBase =
        desiredCollBase > collBase ? desiredCollBase - collBase : 0n;
      const deficitTokens = await vault.convertFromBaseCurrencyToToken(
        deficitBase,
        await collateralToken.getAddress(),
      );

      // Mint required collateral tokens to the vault address
      await collateralToken.mint(await vault.getAddress(), deficitTokens);

      // Supply them to the mock pool on behalf of the vault via test-only wrapper
      await vault.testSupplyToPoolImplementation(
        await collateralToken.getAddress(),
        deficitTokens,
        await vault.getAddress(),
      );
    }

    // Now vault has healthy leverage but totalSupply == 0. Leave 1 wei collateral sitting in
    // vault wallet (not supplied) to act as residual dust value in totalAssets() thanks to +1 in formula.
    const residualDustTokens = 1n;
    await collateralToken.mint(await vault.getAddress(), residualDustTokens);
  });

  it("reverts on deposit smaller than dust", async function () {
    const dust = await vault.totalAssets();
    expect(dust).to.be.gt(0n);

    const victimDeposit = dust - 1n;

    await collateralToken.mint(victim.address, victimDeposit);
    await collateralToken
      .connect(victim)
      .approve(await vault.getAddress(), victimDeposit);

    await expect(
      vault.connect(victim).deposit(victimDeposit, victim.address),
    ).to.be.revertedWithCustomError(vault, "ZeroShares");
  });

  it("reverts on deposit equal to dust", async function () {
    const dust = await vault.totalAssets();
    await collateralToken.mint(victim.address, dust);
    await collateralToken
      .connect(victim)
      .approve(await vault.getAddress(), dust);
    await expect(
      vault.connect(victim).deposit(dust, victim.address),
    ).to.be.revertedWithCustomError(vault, "ZeroShares");
  });

  it("accepts deposit above dust", async function () {
    const dust = await vault.totalAssets();
    const victimDeposit = dust + 1n;

    await collateralToken.mint(victim.address, victimDeposit);
    await collateralToken
      .connect(victim)
      .approve(await vault.getAddress(), victimDeposit);

    const expectedShares = await vault.previewDeposit(victimDeposit);
    expect(expectedShares).to.be.gt(0n);
    await vault.connect(victim).deposit(victimDeposit, victim.address);

    expect(await vault.balanceOf(victim.address)).to.equal(expectedShares);
  });

  it("reverts on zero-asset deposit", async function () {
    await expect(
      vault.connect(victim).deposit(0n, victim.address),
    ).to.be.revertedWithCustomError(vault, "ZeroShares");
  });
});

// Added fuzz tests to cover 100 random deposit attempts around the dust threshold

describe("Fuzz testing deposits vs dust threshold", function () {
  // Reuse same fixture setup so that `vault`, `collateralToken`, and `victim` are initialised
  let vaultLocal: any;
  let collateralTokenLocal: any;
  let victimLocal: any;

  beforeEach(async () => {
    const fixture = await deployDLoopMockFixture();
    await testSetup(fixture);

    ({ dloopMock: vaultLocal, collateralToken: collateralTokenLocal } =
      fixture as any);
    victimLocal = fixture.user1;

    // Mint seed collateral to put vault into state with non-zero dust as in original setup
    const deployer = fixture.deployer;
    await collateralTokenLocal.mint(
      deployer.address,
      parseUnits("2000", COLLATERAL_DECIMALS),
    );
    await collateralTokenLocal
      .connect(deployer)
      .approve(await vaultLocal.getAddress(), ethers.MaxUint256);
    const seed = parseUnits("1000", COLLATERAL_DECIMALS);
    await vaultLocal.connect(deployer).deposit(seed, deployer.address);
    const shares = await vaultLocal.balanceOf(deployer.address);
    await vaultLocal
      .connect(deployer)
      .redeem(shares, deployer.address, deployer.address);
  });

  it("handles 100 random values above and below dust correctly", async function () {
    const dust = await vaultLocal.totalAssets();

    if (dust === 0n) {
      // Not a meaningful scenario for fuzzing; skip
      this.skip();
    }

    const seed = (await ethers.provider.getBlockNumber()) % 1000;

    /**
     * Generate a random number between 0 and 50
     *
     * @param i - the iteration number
     * @returns a random number between 0 and 50
     */
    function rand(i: number): bigint {
      let x = (seed + i) & 0xffffffff;
      x ^= x << 13;
      x ^= x >> 17;
      x ^= x << 5;
      return BigInt((x >>> 0) % 50);
    }

    for (let i = 1; i <= 100; i++) {
      const delta = rand(i) + 1n;
      const below = dust > delta ? dust - delta : 0n;
      const above = dust + delta;

      if (below > 0n) {
        await collateralTokenLocal.mint(victimLocal.address, below);
        await collateralTokenLocal
          .connect(victimLocal)
          .approve(await vaultLocal.getAddress(), below);
        await expect(
          vaultLocal.connect(victimLocal).deposit(below, victimLocal.address),
        ).to.be.revertedWithCustomError(vaultLocal, "ZeroShares");
      }

      await collateralTokenLocal.mint(victimLocal.address, above);
      await collateralTokenLocal
        .connect(victimLocal)
        .approve(await vaultLocal.getAddress(), above);

      const expectedShares = await vaultLocal.previewDeposit(above);

      if (expectedShares === 0n) {
        // Skip this iteration if rounding still results in zero shares
        continue;
      }
      expect(expectedShares).to.be.gt(0n);
      await vaultLocal.connect(victimLocal).deposit(above, victimLocal.address);
      const sharesBal = await vaultLocal.balanceOf(victimLocal.address);
      await vaultLocal
        .connect(victimLocal)
        .redeem(sharesBal, victimLocal.address, victimLocal.address);
    }
  });
});
