{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC-4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC-20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC-20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation introduces configurable virtual assets and shares to help developers mitigate that risk.\n * The `_decimalsOffset()` corresponds to an offset in the decimal representation between the underlying asset's decimals\n * and the vault decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which\n * itself determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default\n * offset (0) makes it non-profitable even if an attacker is able to capture value from multiple user deposits, as a result\n * of the value being captured by the virtual shares (out of the attacker's donation) matching the attacker's expected gains.\n * With a larger offset, the attack becomes orders of magnitude more expensive than it is profitable. More details about the\n * underlying math can be found xref:ROOT:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n */\nabstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable, IERC4626 {\n    using Math for uint256;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC4626\n    struct ERC4626Storage {\n        IERC20 _asset;\n        uint8 _underlyingDecimals;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC4626\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC4626StorageLocation = 0x0773e532dfede91f04b12a73d3d2acd361424f41f76b4fb79f090161e36b4e00;\n\n    function _getERC4626Storage() private pure returns (ERC4626Storage storage $) {\n        assembly {\n            $.slot := ERC4626StorageLocation\n        }\n    }\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC-20 or ERC-777).\n     */\n    function __ERC4626_init(IERC20 asset_) internal onlyInitializing {\n        __ERC4626_init_unchained(asset_);\n    }\n\n    function __ERC4626_init_unchained(IERC20 asset_) internal onlyInitializing {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        $._underlyingDecimals = success ? assetDecimals : 18;\n        $._asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        return $._underlyingDecimals + _decimalsOffset();\n    }\n\n    /** @dev See {IERC4626-asset}. */\n    function asset() public view virtual returns (address) {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        return address($._asset);\n    }\n\n    /** @dev See {IERC4626-totalAssets}. */\n    function totalAssets() public view virtual returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4626-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-maxDeposit}. */\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint}. */\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-previewMint}. */\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /** @dev See {IERC4626-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint}. */\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw}. */\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem}. */\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If asset() is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(IERC20(asset()), caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(IERC20(asset()), receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";\nimport {SafeERC20} from \"../utils/SafeERC20.sol\";\nimport {IERC4626} from \"../../../interfaces/IERC4626.sol\";\nimport {Math} from \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC-4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC-20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC-20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation introduces configurable virtual assets and shares to help developers mitigate that risk.\n * The `_decimalsOffset()` corresponds to an offset in the decimal representation between the underlying asset's decimals\n * and the vault decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which\n * itself determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default\n * offset (0) makes it non-profitable even if an attacker is able to capture value from multiple user deposits, as a result\n * of the value being captured by the virtual shares (out of the attacker's donation) matching the attacker's expected gains.\n * With a larger offset, the attack becomes orders of magnitude more expensive than it is profitable. More details about the\n * underlying math can be found xref:ROOT:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _underlyingDecimals;\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC-20 or ERC-777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _underlyingDecimals + _decimalsOffset();\n    }\n\n    /** @dev See {IERC4626-asset}. */\n    function asset() public view virtual returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4626-totalAssets}. */\n    function totalAssets() public view virtual returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4626-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-maxDeposit}. */\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint}. */\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-previewMint}. */\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /** @dev See {IERC4626-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint}. */\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw}. */\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem}. */\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If asset() is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(IERC20(asset()), caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(IERC20(asset()), receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {ERC721Utils} from \"./utils/ERC721Utils.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC-721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if:\n     * - `spender` does not have approval from `owner` for `tokenId`.\n     * - `spender` does not have approval to manage all of `owner`'s assets.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC-721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {IERC721Enumerable} from \"./IERC721Enumerable.sol\";\nimport {IERC165} from \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the ERC that adds enumerability\n * of all the token ids in the contract as well as all token ids owned by each account.\n *\n * CAUTION: {ERC721} extensions that implement custom `balanceOf` logic, such as {ERC721Consecutive},\n * interfere with enumerability and should not be used together with {ERC721Enumerable}.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;\n    mapping(uint256 tokenId => uint256) private _ownedTokensIndex;\n\n    uint256[] private _allTokens;\n    mapping(uint256 tokenId => uint256) private _allTokensIndex;\n\n    /**\n     * @dev An `owner`'s token query was out of bounds for `index`.\n     *\n     * NOTE: The owner being `address(0)` indicates a global out of bounds index.\n     */\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n\n    /**\n     * @dev Batch mint is not allowed.\n     */\n    error ERC721EnumerableForbiddenBatchMint();\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_update}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n\n        return previousOwner;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = balanceOf(to) - 1;\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        mapping(uint256 index => uint256) storage _ownedTokensByOwner = _ownedTokens[from];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokensByOwner[lastTokenIndex];\n\n            _ownedTokensByOwner[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokensByOwner[lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch\n     */\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC721/utils/ERC721Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../IERC721Receiver.sol\";\nimport {IERC721Errors} from \"../../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Library that provide common ERC-721 utility functions.\n *\n * See https://eips.ethereum.org/EIPS/eip-721[ERC-721].\n *\n * _Available since v5.1._\n */\nlibrary ERC721Utils {\n    /**\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC721Receiver-onERC721Received}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC721Receiver-onERC721Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(operator, from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    // Token rejected\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC721Receiver implementer\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Arrays.sol)\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\n\npragma solidity ^0.8.20;\n\nimport {Comparators} from \"./Comparators.sol\";\nimport {SlotDerivation} from \"./SlotDerivation.sol\";\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using SlotDerivation for bytes32;\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        uint256[] memory array,\n        function(uint256, uint256) pure returns (bool) comp\n    ) internal pure returns (uint256[] memory) {\n        _quickSort(_begin(array), _end(array), comp);\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\n     */\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\n        sort(array, Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of address (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        address[] memory array,\n        function(address, address) pure returns (bool) comp\n    ) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\n     */\n    function sort(address[] memory array) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        bytes32[] memory array,\n        function(bytes32, bytes32) pure returns (bool) comp\n    ) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\n     */\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\n     * at end (exclusive). Sorting follows the `comp` comparator.\n     *\n     * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.\n     *\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\n     * be used only if the limits are within a memory array.\n     */\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\n        unchecked {\n            if (end - begin < 0x40) return;\n\n            // Use first element as pivot\n            uint256 pivot = _mload(begin);\n            // Position where the pivot should be at the end of the loop\n            uint256 pos = begin;\n\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\n                if (comp(_mload(it), pivot)) {\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\n                    // position of the pivot and move the value there.\n                    pos += 0x20;\n                    _swap(pos, it);\n                }\n            }\n\n            _swap(begin, pos); // Swap pivot into place\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first element of `array`.\n     */\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\n        assembly (\"memory-safe\") {\n            ptr := add(array, 0x20)\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\n     * that comes just after the last element of the array.\n     */\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\n        unchecked {\n            return _begin(array) + array.length * 0x20;\n        }\n    }\n\n    /**\n     * @dev Load memory word (as a uint256) at location `ptr`.\n     */\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\n        assembly {\n            value := mload(ptr)\n        }\n    }\n\n    /**\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\n     */\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\n        assembly {\n            let value1 := mload(ptr1)\n            let value2 := mload(ptr2)\n            mstore(ptr1, value2)\n            mstore(ptr2, value1)\n        }\n    }\n\n    /// @dev Helper: low level cast address memory array to uint256 memory array\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast address comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(address, address) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(bytes32, bytes32) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\n     * contain no repeated elements.\n     *\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\n     * support for repeated elements in the array. The {lowerBound} function should\n     * be used instead.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value greater or equal than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\n     */\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value strictly greater than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\n     */\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {lowerBound}, but with an array in memory.\n     */\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {upperBound}, but with an array in memory.\n     */\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Base64.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     * See sections 4 and 5 of https://datatracker.ietf.org/doc/html/rfc4648\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    string internal constant _TABLE_URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        return _encode(data, _TABLE, true);\n    }\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64Url `string` representation.\n     * Output is not padded with `=` as specified in https://www.rfc-editor.org/rfc/rfc4648[rfc4648].\n     */\n    function encodeURL(bytes memory data) internal pure returns (string memory) {\n        return _encode(data, _TABLE_URL, false);\n    }\n\n    /**\n     * @dev Internal table-agnostic conversion\n     */\n    function _encode(bytes memory data, string memory table, bool withPadding) private pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // If padding is enabled, the final length should be `bytes` data length divided by 3 rounded up and then\n        // multiplied by 4 so that it leaves room for padding the last chunk\n        // - `data.length + 2`  -> Prepare for division rounding up\n        // - `/ 3`              -> Number of 3-bytes chunks (rounded up)\n        // - `4 *`              -> 4 characters for each chunk\n        // This is equivalent to: 4 * Math.ceil(data.length / 3)\n        //\n        // If padding is disabled, the final length should be `bytes` data length multiplied by 4/3 rounded up as\n        // opposed to when padding is required to fill the last chunk.\n        // - `4 * data.length`  -> 4 characters for each chunk\n        // - ` + 2`             -> Prepare for division rounding up\n        // - `/ 3`              -> Number of 3-bytes chunks (rounded up)\n        // This is equivalent to: Math.ceil((4 * data.length) / 3)\n        uint256 resultLength = withPadding ? 4 * ((data.length + 2) / 3) : (4 * data.length + 2) / 3;\n\n        string memory result = new string(resultLength);\n\n        assembly (\"memory-safe\") {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 0x20)\n            let dataPtr := data\n            let endPtr := add(data, mload(data))\n\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\n            // set it to zero to make sure no dirty bytes are read in that section.\n            let afterPtr := add(endPtr, 0x20)\n            let afterCache := mload(afterPtr)\n            mstore(afterPtr, 0x00)\n\n            // Run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 byte (24 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\n                // Use this as an index into the lookup table, mload an entire word\n                // so the desired character is in the least significant byte, and\n                // mstore8 this least significant byte into the result and continue.\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // Reset the value that was cached\n            mstore(afterPtr, afterCache)\n\n            if withPadding {\n                // When data `bytes` is not exactly 3 bytes long\n                // it is padded with `=` characters at the end\n                switch mod(mload(data), 3)\n                case 1 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                    mstore8(sub(resultPtr, 2), 0x3d)\n                }\n                case 2 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                }\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Comparators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to compare values.\n *\n * _Available since v5.1._\n */\nlibrary Comparators {\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a < b;\n    }\n\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a > b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2 + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2 + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2 + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/SlotDerivation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\n * the solidity language / compiler.\n *\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\n *\n * Example usage:\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using StorageSlot for bytes32;\n *     using SlotDerivation for bytes32;\n *\n *     // Declare a namespace\n *     string private constant _NAMESPACE = \"<namespace>\"; // eg. OpenZeppelin.Slot\n *\n *     function setValueInNamespace(uint256 key, address newValue) internal {\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\n *     }\n *\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {StorageSlot}.\n *\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\n * upgrade safety will ignore the slots accessed through this library.\n *\n * _Available since v5.1._\n */\nlibrary SlotDerivation {\n    /**\n     * @dev Derive an ERC-7201 slot from a string (namespace).\n     */\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }\n\n    /**\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\n     */\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }\n\n    /**\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\n     */\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(buffer, add(0x20, offset)))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n * - Map can be cleared (all entries removed) in O(n).\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n * - `uint256 -> bytes32` (`UintToBytes32Map`) since v5.1.0\n * - `address -> address` (`AddressToAddressMap`) since v5.1.0\n * - `address -> bytes32` (`AddressToBytes32Map`) since v5.1.0\n * - `bytes32 -> address` (`Bytes32ToAddressMap`) since v5.1.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(Bytes32ToBytes32Map storage map) internal {\n        uint256 len = length(map);\n        for (uint256 i = 0; i < len; ++i) {\n            delete map._values[map._keys.at(i)];\n        }\n        map._keys.clear();\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32 key, bytes32 value) {\n        bytes32 atKey = map._keys.at(index);\n        return (atKey, map._values[atKey]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool exists, bytes32 value) {\n        bytes32 val = map._values[key];\n        if (val == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, val);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        if (value == 0 && !contains(map, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(UintToUintMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256 key, uint256 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (uint256(atKey), uint256(val));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool exists, uint256 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(val));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(UintToAddressMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256 key, address value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (uint256(atKey), address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool exists, address value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToBytes32Map\n\n    struct UintToBytes32Map {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToBytes32Map storage map, uint256 key, bytes32 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), value);\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToBytes32Map storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(UintToBytes32Map storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToBytes32Map storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToBytes32Map storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToBytes32Map storage map, uint256 index) internal view returns (uint256 key, bytes32 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (uint256(atKey), val);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToBytes32Map storage map, uint256 key) internal view returns (bool exists, bytes32 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(key));\n        return (success, val);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToBytes32Map storage map, uint256 key) internal view returns (bytes32) {\n        return get(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToBytes32Map storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(AddressToUintMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address key, uint256 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (address(uint160(uint256(atKey))), uint256(val));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool exists, uint256 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(val));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToAddressMap\n\n    struct AddressToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToAddressMap storage map, address key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToAddressMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(AddressToAddressMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToAddressMap storage map, uint256 index) internal view returns (address key, address value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (address(uint160(uint256(atKey))), address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToAddressMap storage map, address key) internal view returns (bool exists, address value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToAddressMap storage map, address key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(uint256(uint160(key)))))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToAddressMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToBytes32Map\n\n    struct AddressToBytes32Map {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToBytes32Map storage map, address key, bytes32 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), value);\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToBytes32Map storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(AddressToBytes32Map storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToBytes32Map storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToBytes32Map storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToBytes32Map storage map, uint256 index) internal view returns (address key, bytes32 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (address(uint160(uint256(atKey))), val);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToBytes32Map storage map, address key) internal view returns (bool exists, bytes32 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, val);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToBytes32Map storage map, address key) internal view returns (bytes32) {\n        return get(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToBytes32Map storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(Bytes32ToUintMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32 key, uint256 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (atKey, uint256(val));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool exists, uint256 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, key);\n        return (success, uint256(val));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToAddressMap\n\n    struct Bytes32ToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToAddressMap storage map, bytes32 key, address value) internal returns (bool) {\n        return set(map._inner, key, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToAddressMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(Bytes32ToAddressMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToAddressMap storage map, uint256 index) internal view returns (bytes32 key, address value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (atKey, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool exists, address value) {\n        (bool success, bytes32 val) = tryGet(map._inner, key);\n        return (success, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, key))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToAddressMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\nimport {Arrays} from \"../Arrays.sol\";\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n * - Set can be cleared (all elements removed) in O(n).\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function _clear(Set storage set) private {\n        uint256 len = _length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(Bytes32Set storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(AddressSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(UintSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "contracts/common/BasisPointConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nlibrary BasisPointConstants {\n    // Shared definitions of how we represent percentages and basis points\n    uint16 public constant ONE_BPS = 100; // 1 basis point with 2 decimals\n    uint32 public constant ONE_PERCENT_BPS = ONE_BPS * 100;\n    uint32 public constant ONE_HUNDRED_PERCENT_BPS = ONE_PERCENT_BPS * 100;\n}\n"
    },
    "contracts/common/Erc20Helper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nlibrary Erc20Helper {\n    /**\n     * @dev Checks if a token is an ERC-20\n     * @param token Address of the token\n     * @return bool True if the token is an ERC-20, false otherwise\n     */\n    function isERC20(address token) internal view returns (bool) {\n        try ERC20(token).totalSupply() returns (uint256) {\n            try ERC20(token).balanceOf(address(this)) returns (uint256) {\n                return true;\n            } catch {\n                return false;\n            }\n        } catch {\n            return false;\n        }\n    }\n}\n"
    },
    "contracts/common/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n    /**\n     * @notice Returns the base currency address\n     * @dev Address 0x0 is reserved for USD as base currency.\n     * @return Returns the base currency address.\n     */\n    function BASE_CURRENCY() external view returns (address);\n\n    /**\n     * @notice Returns the base currency unit\n     * @dev 1 ether for ETH, 1e8 for USD.\n     * @return Returns the base currency unit.\n     */\n    function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n    /**\n     * @notice Returns the asset price in the base currency\n     * @param asset The address of the asset\n     * @return The price of the asset\n     */\n    function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/common/IMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMintableERC20 is IERC20 {\n    function mint(address to, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n\n    function burnFrom(address account, uint256 amount) external;\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/common/RescuableVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\n/**\n * @title RescuableVault\n * @dev A helper contract for rescuing tokens accidentally sent to the contract\n *      - The derived contract must implement the getRestrictedRescueTokens() function\n */\nabstract contract RescuableVault is Ownable, ReentrancyGuard {\n    using SafeERC20 for ERC20;\n\n    /* Virtual Methods - Required to be implemented by derived contracts */\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return address[] Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens()\n        public\n        view\n        virtual\n        returns (address[] memory);\n\n    /* Rescue Functions */\n\n    /**\n     * @dev Rescues tokens accidentally sent to the contract (except for the collateral token and debt token)\n     * @param token Address of the token to rescue\n     * @param receiver Address to receive the rescued tokens\n     * @param amount Amount of tokens to rescue\n     */\n    function rescueToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) public onlyOwner nonReentrant {\n        // The vault does not hold any debt token and collateral token, so it is not necessary to restrict the rescue of debt token and collateral token\n        // We can just rescue any ERC-20 token\n\n        address[] memory restrictedRescueTokens = getRestrictedRescueTokens();\n\n        // Check if the token is restricted\n        for (uint256 i = 0; i < restrictedRescueTokens.length; i++) {\n            if (token == restrictedRescueTokens[i]) {\n                revert(\"Cannot rescue restricted token\");\n            }\n        }\n\n        // Rescue the token\n        ERC20(token).safeTransfer(receiver, amount);\n    }\n}\n"
    },
    "contracts/common/SupportsWithdrawalFee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./BasisPointConstants.sol\";\n\nerror InitialFeeExceedsMaxFee(uint256 feeBps, uint256 maxFeeBps);\nerror InvalidFeeBps(uint256 feeBps, uint256 maxFeeBps);\n\n// Note: FeeManagerCannotBeZeroAddress error can be handled by the consuming contract's AccessControl checks.\n\nabstract contract SupportsWithdrawalFee {\n    uint256 internal withdrawalFeeBps_;\n\n    event WithdrawalFee(\n        address indexed owner,\n        address indexed receiver,\n        uint256 feeAmount\n    );\n    event WithdrawalFeeSet(uint256 newFeeBps);\n\n    /**\n     * @notice Must be implemented by the inheriting contract to define its specific maximum withdrawal fee in BPS.\n     * @return The maximum withdrawal fee in basis points.\n     */\n    function _maxWithdrawalFeeBps() internal view virtual returns (uint256);\n\n    /**\n     * @notice Initialize the withdrawal fee during contract construction/initialization.\n     * @param initialFeeBps The initial withdrawal fee in basis points.\n     */\n    function _initializeWithdrawalFee(uint256 initialFeeBps) internal {\n        uint256 maxFee = _maxWithdrawalFeeBps();\n        if (initialFeeBps > maxFee) {\n            revert InitialFeeExceedsMaxFee(initialFeeBps, maxFee);\n        }\n        withdrawalFeeBps_ = initialFeeBps;\n        emit WithdrawalFeeSet(initialFeeBps);\n    }\n\n    /**\n     * @notice Set the withdrawal fee. Internal function to be called by the inheriting contract.\n     * @param newFeeBps The new withdrawal fee in basis points.\n     */\n    function _setWithdrawalFee(uint256 newFeeBps) internal {\n        uint256 maxFee = _maxWithdrawalFeeBps();\n        if (newFeeBps > maxFee) {\n            revert InvalidFeeBps(newFeeBps, maxFee);\n        }\n        withdrawalFeeBps_ = newFeeBps;\n        emit WithdrawalFeeSet(newFeeBps);\n    }\n\n    /**\n     * @notice Calculate the withdrawal fee for a given asset amount.\n     * @dev Uses precise division since fees stay in the vault (no external transfer).\n     * @param assetAmount The amount of assets being withdrawn.\n     * @return The fee amount in asset terms.\n     */\n    function _calculateWithdrawalFee(\n        uint256 assetAmount\n    ) internal view returns (uint256) {\n        return\n            (assetAmount * withdrawalFeeBps_) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n    }\n\n    /**\n     * @notice Calculate the net amount after deducting withdrawal fees.\n     * Used for previewRedeem to show what the user will actually receive.\n     * @param grossAmount The gross amount before fees.\n     * @return The net amount after deducting fees.\n     */\n    function _getNetAmountAfterFee(\n        uint256 grossAmount\n    ) internal view returns (uint256) {\n        uint256 fee = _calculateWithdrawalFee(grossAmount);\n        return grossAmount - fee;\n    }\n\n    /**\n     * @notice Calculate the gross amount required to achieve a desired net amount.\n     * Used for previewWithdraw to show how many shares are needed for a desired net withdrawal.\n     * @dev Uses precise division since fees stay in the vault.\n     * @param netAmount The desired net amount after fees.\n     * @return The gross amount required before fees.\n     */\n    function _getGrossAmountRequiredForNet(\n        uint256 netAmount\n    ) internal view returns (uint256) {\n        if (withdrawalFeeBps_ == 0) {\n            return netAmount;\n        }\n        // grossAmount = netAmount / (1 - feeBps/ONE_HUNDRED_PERCENT_BPS)\n        // grossAmount = netAmount * ONE_HUNDRED_PERCENT_BPS / (ONE_HUNDRED_PERCENT_BPS - feeBps)\n        return\n            (netAmount * BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n            (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS - withdrawalFeeBps_);\n    }\n\n    /**\n     * @notice Get the current withdrawal fee in basis points.\n     * @return The withdrawal fee in basis points.\n     */\n    function getWithdrawalFeeBps() public view returns (uint256) {\n        return withdrawalFeeBps_;\n    }\n}\n"
    },
    "contracts/common/SwappableVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\n/**\n * @title SwappableVault\n * @dev Base contract for swap functions\n *      - Need to implement the _swapExactOutputImplementation function\n *      - The wrapper function _swapExactOutput has some sanity checks\n */\nabstract contract SwappableVault {\n    error SpentInputTokenAmountGreaterThanAmountInMaximum(\n        uint256 spentInputTokenAmount,\n        uint256 amountInMaximum\n    );\n    error ReceivedOutputTokenAmountNotEqualAmountOut(\n        uint256 receivedOutputTokenAmount,\n        uint256 amountOut\n    );\n    error OutputTokenBalanceNotIncreasedAfterSwap(\n        uint256 outputTokenBalanceBefore,\n        uint256 outputTokenBalanceAfter\n    );\n    error SpentInputTokenAmountNotEqualReturnedAmountIn(\n        uint256 spentInputTokenAmount,\n        uint256 returnedAmountIn\n    );\n\n    /* Virtual functions */\n\n    /**\n     * @dev Swaps an exact amount of input assets for as much output assets as possible\n     * @param inputToken Input asset\n     * @param outputToken Output asset\n     * @param amountOut Amount of input assets\n     * @param amountInMaximum Minimum amount of output assets (slippage protection)\n     * @param receiver Address to receive the output assets\n     * @param deadline Deadline for the swap\n     * @param extraData Additional data for the swap\n     * @return amountIn Amount of input assets used for the swap\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory extraData\n    ) internal virtual returns (uint256);\n\n    /* Swap functions */\n\n    /**\n     * @dev A wrapper function for the _swapExactOutputImplementation function\n     *      - Add some sanity checks\n     * @param inputToken Input asset\n     * @param outputToken Output asset\n     * @param amountOut Amount of input assets\n     * @param amountInMaximum Minimum amount of output assets (slippage protection)\n     * @param receiver Address to receive the output assets\n     * @param deadline Deadline for the swap\n     * @param extraData Additional data for the swap\n     * @return amountIn Amount of input assets used for the swap\n     */\n    function _swapExactOutput(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory extraData\n    ) internal returns (uint256) {\n        uint256 inputTokenBalanceBefore = inputToken.balanceOf(address(this));\n        uint256 outputTokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        // Perform the swap\n        uint256 amountIn = _swapExactOutputImplementation(\n            inputToken,\n            outputToken,\n            amountOut,\n            amountInMaximum,\n            receiver,\n            deadline,\n            extraData\n        );\n        uint256 inputTokenBalanceAfter = inputToken.balanceOf(address(this));\n        uint256 outputTokenBalanceAfter = outputToken.balanceOf(address(this));\n\n        // Make sure the spent input token amount is not greater than the amount in maximum\n        if (inputTokenBalanceAfter < inputTokenBalanceBefore) {\n            uint256 spentInputTokenAmount = inputTokenBalanceBefore -\n                inputTokenBalanceAfter;\n            if (spentInputTokenAmount > amountInMaximum) {\n                revert SpentInputTokenAmountGreaterThanAmountInMaximum(\n                    spentInputTokenAmount,\n                    amountInMaximum\n                );\n            }\n            if (spentInputTokenAmount != amountIn) {\n                revert SpentInputTokenAmountNotEqualReturnedAmountIn(\n                    spentInputTokenAmount,\n                    amountIn\n                );\n            }\n        }\n        // Do not need to check the input token balance decreased after the swap\n        // as it is not a risk for the caller\n\n        // Make sure the received output token amount is exactly the amount out\n        if (outputTokenBalanceAfter > outputTokenBalanceBefore) {\n            uint256 receivedOutputTokenAmount = outputTokenBalanceAfter -\n                outputTokenBalanceBefore;\n            if (receivedOutputTokenAmount != amountOut) {\n                revert ReceivedOutputTokenAmountNotEqualAmountOut(\n                    receivedOutputTokenAmount,\n                    amountOut\n                );\n            }\n        } else {\n            revert OutputTokenBalanceNotIncreasedAfterSwap(\n                outputTokenBalanceBefore,\n                outputTokenBalanceAfter\n            );\n        }\n\n        return amountIn;\n    }\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/math/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary PercentageMath {\n    // Maximum percentage factor (100.00%)\n    uint256 internal constant PERCENTAGE_FACTOR = 1e4;\n\n    // Half percentage factor (50.00%)\n    uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\n\n    /**\n     * @notice Executes a percentage multiplication\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return result value percentmul percentage\n     */\n    function percentMul(\n        uint256 value,\n        uint256 percentage\n    ) internal pure returns (uint256 result) {\n        // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\n        assembly {\n            if iszero(\n                or(\n                    iszero(percentage),\n                    iszero(\n                        gt(\n                            value,\n                            div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage)\n                        )\n                    )\n                )\n            ) {\n                revert(0, 0)\n            }\n\n            result := div(\n                add(mul(value, percentage), HALF_PERCENTAGE_FACTOR),\n                PERCENTAGE_FACTOR\n            )\n        }\n    }\n\n    /**\n     * @notice Executes a percentage division\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return result value percentdiv percentage\n     */\n    function percentDiv(\n        uint256 value,\n        uint256 percentage\n    ) internal pure returns (uint256 result) {\n        // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\n        assembly {\n            if or(\n                iszero(percentage),\n                iszero(\n                    iszero(\n                        gt(\n                            value,\n                            div(\n                                sub(not(0), div(percentage, 2)),\n                                PERCENTAGE_FACTOR\n                            )\n                        )\n                    )\n                )\n            ) {\n                revert(0, 0)\n            }\n\n            result := div(\n                add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)),\n                percentage\n            )\n        }\n    }\n}\n"
    },
    "contracts/dstable/AmoManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"contracts/common/IMintableERC20.sol\";\nimport \"./CollateralVault.sol\";\nimport \"./OracleAware.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n// Forward declaration interface for AmoVault instead of importing the full contract\ninterface IAmoVault {\n    function totalValue() external view returns (uint256);\n\n    function totalDstableValue() external view returns (uint256);\n\n    function totalCollateralValue() external view returns (uint256);\n\n    function withdrawTo(\n        address recipient,\n        uint256 amount,\n        address asset\n    ) external;\n\n    function assetValueFromAmount(\n        uint256 amount,\n        address asset\n    ) external view returns (uint256);\n}\n\n/**\n * @title AmoManager\n * @dev Manages AMOs for dStable\n * Handles allocation, deallocation, collateral management, and profit management for AMO vaults.\n */\ncontract AmoManager is AccessControl, OracleAware, ReentrancyGuard {\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    /* Core state */\n\n    EnumerableMap.AddressToUintMap private _amoVaults;\n    // Separate map to track whether a vault is considered active. This decouples\n    // allocation bookkeeping (which may change when moving collateral) from the\n    // governancecontrolled active status of a vault.\n    mapping(address => bool) private _isAmoActive;\n    uint256 public totalAllocated;\n    IMintableERC20 public dstable;\n    CollateralVault public collateralHolderVault;\n\n    /* Events */\n\n    event AmoVaultSet(address indexed amoVault, bool isActive);\n    event AmoAllocated(address indexed amoVault, uint256 dstableAmount);\n    event AmoDeallocated(address indexed amoVault, uint256 dstableAmount);\n    event ProfitsWithdrawn(address indexed amoVault, uint256 amount);\n    event AllocationSurplus(address indexed amoVault, uint256 surplusInDstable);\n\n    /* Roles */\n\n    bytes32 public constant AMO_ALLOCATOR_ROLE =\n        keccak256(\"AMO_ALLOCATOR_ROLE\");\n    bytes32 public constant FEE_COLLECTOR_ROLE =\n        keccak256(\"FEE_COLLECTOR_ROLE\");\n\n    /* Errors */\n\n    error InactiveAmoVault(address amoVault);\n    error AmoSupplyInvariantViolation(\n        uint256 startingSupply,\n        uint256 endingSupply\n    );\n    error AmoVaultAlreadyEnabled(address amoVault);\n    error CannotTransferDStable();\n    error InsufficientProfits(\n        uint256 takeProfitValueInBase,\n        int256 availableProfitInBase\n    );\n    error InsufficientAllocation(uint256 requested, uint256 available);\n\n    /**\n     * @notice Initializes the AmoManager contract.\n     * @param _dstable The address of the dStable stablecoin.\n     * @param _collateralHolderVault The address of the collateral holder vault.\n     * @param _oracle The oracle for price feeds.\n     */\n    constructor(\n        address _dstable,\n        address _collateralHolderVault,\n        IPriceOracleGetter _oracle\n    ) OracleAware(_oracle, _oracle.BASE_CURRENCY_UNIT()) {\n        dstable = IMintableERC20(_dstable);\n        collateralHolderVault = CollateralVault(_collateralHolderVault);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        grantRole(AMO_ALLOCATOR_ROLE, msg.sender);\n        grantRole(FEE_COLLECTOR_ROLE, msg.sender);\n    }\n\n    /* AMO */\n\n    /**\n     * @notice Allocates AMO tokens to an AMO vault.\n     * @param amoVault The address of the AMO vault.\n     * @param dstableAmount The amount of dStable to allocate.\n     */\n    function allocateAmo(\n        address amoVault,\n        uint256 dstableAmount\n    ) public onlyRole(AMO_ALLOCATOR_ROLE) nonReentrant {\n        uint256 startingAmoSupply = totalAmoSupply();\n\n        // Make sure the vault is active\n        if (!isAmoActive(amoVault)) {\n            revert InactiveAmoVault(amoVault);\n        }\n\n        // Update the allocation for this vault\n        (, uint256 currentAllocation) = _amoVaults.tryGet(amoVault);\n        _amoVaults.set(amoVault, currentAllocation + dstableAmount);\n\n        // Make the deposit\n        totalAllocated += dstableAmount;\n        dstable.transfer(amoVault, dstableAmount);\n\n        // Check invariants\n        uint256 endingAmoSupply = totalAmoSupply();\n        if (endingAmoSupply != startingAmoSupply) {\n            revert AmoSupplyInvariantViolation(\n                startingAmoSupply,\n                endingAmoSupply\n            );\n        }\n\n        emit AmoAllocated(amoVault, dstableAmount);\n    }\n\n    /**\n     * @notice Deallocates AMO tokens from an AMO vault.\n     * @param amoVault The address of the AMO vault.\n     * @param dstableAmount The amount of dStable to deallocate.\n     */\n    function deallocateAmo(\n        address amoVault,\n        uint256 dstableAmount\n    ) public onlyRole(AMO_ALLOCATOR_ROLE) nonReentrant {\n        uint256 startingAmoSupply = totalAmoSupply();\n\n        // We don't require that the vault is active or has allocation, since we want to allow withdrawing from inactive vaults\n\n        // If the vault is still active, make sure it has enough allocation and decrease it\n        (, uint256 currentAllocation) = _amoVaults.tryGet(amoVault);\n\n        // Ensure we do not deallocate more than the vault's recorded allocation\n        if (dstableAmount > currentAllocation) {\n            revert InsufficientAllocation(dstableAmount, currentAllocation);\n        }\n\n        // Update the allocation for this vault (safe: dstableAmount <= currentAllocation)\n        _amoVaults.set(amoVault, currentAllocation - dstableAmount);\n\n        // Make the withdrawal and update global counter\n        totalAllocated -= dstableAmount;\n        dstable.transferFrom(amoVault, address(this), dstableAmount);\n\n        // Check invariants\n        uint256 endingAmoSupply = totalAmoSupply();\n        if (endingAmoSupply != startingAmoSupply) {\n            revert AmoSupplyInvariantViolation(\n                startingAmoSupply,\n                endingAmoSupply\n            );\n        }\n\n        emit AmoDeallocated(amoVault, dstableAmount);\n    }\n\n    /**\n     * @notice Returns the total AMO supply.\n     * @return The total AMO supply.\n     */\n    function totalAmoSupply() public view returns (uint256) {\n        uint256 freeBalance = dstable.balanceOf(address(this));\n        return freeBalance + totalAllocated;\n    }\n\n    /**\n     * @notice Decreases the AMO supply by burning dStable.\n     * @param dstableAmount The amount of dStable to burn.\n     */\n    function decreaseAmoSupply(\n        uint256 dstableAmount\n    ) public onlyRole(AMO_ALLOCATOR_ROLE) {\n        dstable.burn(dstableAmount);\n    }\n\n    /**\n     * @notice Checks if an AMO vault is active.\n     * @param amoVault The address of the AMO vault to check.\n     * @return True if the AMO vault is active, false otherwise.\n     */\n    function isAmoActive(address amoVault) public view returns (bool) {\n        return _isAmoActive[amoVault];\n    }\n\n    /**\n     * @notice Returns the allocation for a specific AMO vault.\n     * @param amoVault The address of the AMO vault.\n     * @return The current allocation for the vault.\n     */\n    function amoVaultAllocation(\n        address amoVault\n    ) public view returns (uint256) {\n        (bool exists, uint256 allocation) = _amoVaults.tryGet(amoVault);\n        return exists ? allocation : 0;\n    }\n\n    /**\n     * @notice Returns the list of all AMO vaults.\n     * @return The list of AMO vault addresses.\n     */\n    function amoVaults() public view returns (address[] memory) {\n        return _amoVaults.keys();\n    }\n\n    /**\n     * @notice Enables an AMO vault.\n     * @param amoVault The address of the AMO vault.\n     */\n    function enableAmoVault(\n        address amoVault\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_isAmoActive[amoVault]) {\n            revert AmoVaultAlreadyEnabled(amoVault);\n        }\n        // Ensure the vault is tracked in the allocation map (initial allocation may be zero)\n        (, uint256 currentAllocation) = _amoVaults.tryGet(amoVault);\n        _amoVaults.set(amoVault, currentAllocation);\n        _isAmoActive[amoVault] = true;\n        emit AmoVaultSet(amoVault, true);\n    }\n\n    /**\n     * @notice Disables an AMO vault.\n     * @param amoVault The address of the AMO vault.\n     */\n    function disableAmoVault(\n        address amoVault\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (!_isAmoActive[amoVault]) {\n            revert InactiveAmoVault(amoVault);\n        }\n        _isAmoActive[amoVault] = false;\n        emit AmoVaultSet(amoVault, false);\n    }\n\n    /* Collateral Management */\n\n    /**\n     * @notice Returns the total collateral value of all active AMO vaults.\n     * @return The total collateral value in base value.\n     */\n    function totalCollateralValue() public view returns (uint256) {\n        uint256 totalBaseValue = 0;\n        for (uint256 i = 0; i < _amoVaults.length(); i++) {\n            (address vaultAddress, ) = _amoVaults.at(i);\n            if (isAmoActive(vaultAddress)) {\n                totalBaseValue += IAmoVault(vaultAddress).totalCollateralValue();\n            }\n        }\n        return totalBaseValue;\n    }\n\n    /**\n     * @notice Transfers collateral from an AMO vault to the holding vault.\n     * @param amoVault The address of the AMO vault.\n     * @param token The address of the collateral token to transfer.\n     * @param amount The amount of collateral to transfer.\n     */\n    function transferFromAmoVaultToHoldingVault(\n        address amoVault,\n        address token,\n        uint256 amount\n    ) public onlyRole(AMO_ALLOCATOR_ROLE) nonReentrant {\n        if (token == address(dstable)) {\n            revert CannotTransferDStable();\n        }\n\n        // Update allocation\n        // A note on why we modify AMO allocation when we withdraw collateral:\n        // 1. When dStable AMO enters the AMO vault, the dStable is initially unbacked\n        // 2. Over time the AMO vault accrues collateral in exchange for distributing dStable\n        // 3. We may be able to make better use of that collateral in a different collateral vault\n        // 4. So we transfer the collateral out of the AMO vault, but at that point the dStable that\n        //    converted to that collateral is now free-floating and fully backed\n        // 5. Thus we decrement the AMO allocation to reflect the fact that the dStable is no longer\n        //    unbacked, but is actually fully backed and circulating\n        uint256 collateralBaseValue = collateralHolderVault\n            .assetValueFromAmount(amount, token);\n        uint256 collateralInDstable = baseValueToDstableAmount(\n            collateralBaseValue\n        );\n        (, uint256 currentAllocation) = _amoVaults.tryGet(amoVault);\n\n        uint256 adjustmentAmount = collateralInDstable;\n        if (collateralInDstable > currentAllocation) {\n            // Emit event to explicitly record the surplus that improves backing\n            uint256 surplus = collateralInDstable - currentAllocation;\n            emit AllocationSurplus(amoVault, surplus);\n\n            // Cap the adjustment to the current allocation to prevent underflow\n            adjustmentAmount = currentAllocation;\n        }\n\n        // Bookkeeping: adjust the vault's allocation. This does NOT change the vault's active status.\n        _amoVaults.set(amoVault, currentAllocation - adjustmentAmount);\n        totalAllocated -= adjustmentAmount;\n\n        // Transfer the collateral\n        IAmoVault(amoVault).withdrawTo(\n            address(collateralHolderVault),\n            amount,\n            token\n        );\n    }\n\n    /**\n     * @notice Transfers collateral from the holding vault to an AMO vault.\n     * @param amoVault The address of the AMO vault.\n     * @param token The address of the collateral token to transfer.\n     * @param amount The amount of collateral to transfer.\n     */\n    function transferFromHoldingVaultToAmoVault(\n        address amoVault,\n        address token,\n        uint256 amount\n    ) public onlyRole(AMO_ALLOCATOR_ROLE) nonReentrant {\n        if (token == address(dstable)) {\n            revert CannotTransferDStable();\n        }\n        if (!_isAmoActive[amoVault]) {\n            revert InactiveAmoVault(amoVault);\n        }\n\n        // Update allocation\n        // A note on why we modify AMO allocation when we deposit collateral:\n        // 1. When we deposit collateral, it can be used to buy back dStable\n        // 2. When we buy back dStable, the dStable is now unbacked (a redemption)\n        // 3. Thus any collateral deposited to an AMO vault can create unbacked dStable,\n        //    which means the AMO allocation for that vault must be increased to reflect this\n        uint256 collateralBaseValue = collateralHolderVault\n            .assetValueFromAmount(amount, token);\n        uint256 collateralInDstable = baseValueToDstableAmount(\n            collateralBaseValue\n        );\n        (, uint256 currentAllocation) = _amoVaults.tryGet(amoVault);\n        _amoVaults.set(amoVault, currentAllocation + collateralInDstable);\n        totalAllocated += collateralInDstable;\n\n        // Transfer the collateral\n        collateralHolderVault.withdrawTo(amoVault, amount, token);\n    }\n\n    /* Profit Management */\n\n    /**\n     * @notice Returns the available profit for a specific vault in base value (e.g., the underlying).\n     * @param vaultAddress The address of the AMO vault to check.\n     * @return The available profit in base (can be negative).\n     */\n    function availableVaultProfitsInBase(\n        address vaultAddress\n    ) public view returns (int256) {\n        uint256 totalVaultValueInBase = IAmoVault(vaultAddress).totalValue();\n        uint256 allocatedDstable = amoVaultAllocation(vaultAddress);\n        uint256 allocatedValueInBase = dstableAmountToBaseValue(\n            allocatedDstable\n        );\n\n        return int256(totalVaultValueInBase) - int256(allocatedValueInBase);\n    }\n\n    /**\n     * @notice Withdraws profits from an AMO vault to a recipient.\n     * @param amoVault The AMO vault from which to withdraw profits.\n     * @param recipient The address to receive the profits.\n     * @param takeProfitToken The collateral token to withdraw.\n     * @param takeProfitAmount The amount of collateral to withdraw.\n     * @return takeProfitValueInBase The value of the withdrawn profits in base.\n     */\n    function withdrawProfits(\n        IAmoVault amoVault,\n        address recipient,\n        address takeProfitToken,\n        uint256 takeProfitAmount\n    )\n        public\n        onlyRole(FEE_COLLECTOR_ROLE)\n        nonReentrant\n        returns (uint256 takeProfitValueInBase)\n    {\n        // Leave open the possibility of withdrawing profits from inactive vaults\n\n        takeProfitValueInBase = amoVault.assetValueFromAmount(\n            takeProfitAmount,\n            takeProfitToken\n        );\n\n        int256 _availableProfitInBase = availableVaultProfitsInBase(\n            address(amoVault)\n        );\n\n        // Make sure we are withdrawing less than the available profit\n        if (\n            _availableProfitInBase <= 0 ||\n            int256(takeProfitValueInBase) > _availableProfitInBase\n        ) {\n            revert InsufficientProfits(\n                takeProfitValueInBase,\n                _availableProfitInBase\n            );\n        }\n\n        // Withdraw profits from the vault\n        amoVault.withdrawTo(recipient, takeProfitAmount, takeProfitToken);\n\n        emit ProfitsWithdrawn(address(amoVault), takeProfitValueInBase);\n\n        return takeProfitValueInBase;\n    }\n\n    /**\n     * @notice Returns the total available profit across all AMO vaults in base.\n     * @return The total available profit in base.\n     */\n    function availableProfitInBase() public view returns (int256) {\n        int256 totalProfit = 0;\n\n        // Iterate through all AMO vaults\n        for (uint256 i = 0; i < _amoVaults.length(); i++) {\n            (address vaultAddress, ) = _amoVaults.at(i);\n\n            if (isAmoActive(vaultAddress)) {\n                totalProfit += availableVaultProfitsInBase(vaultAddress);\n            }\n        }\n\n        return totalProfit;\n    }\n\n    /* Utility */\n\n    /**\n     * @notice Converts a base value to an equivalent amount of dStable tokens.\n     * @param baseValue The amount of base value to convert.\n     * @return The equivalent amount of dStable tokens.\n     */\n    function baseValueToDstableAmount(\n        uint256 baseValue\n    ) public view returns (uint256) {\n        uint8 dstableDecimals = dstable.decimals();\n        // Align valuation with Issuer/Redeemer: assume 1 dStable == baseCurrencyUnit\n        return (baseValue * (10 ** dstableDecimals)) / baseCurrencyUnit;\n    }\n\n    /**\n     * @notice Converts an amount of dStable tokens to an equivalent base value.\n     * @param dstableAmount The amount of dStable tokens to convert.\n     * @return The equivalent amount of base value.\n     */\n    function dstableAmountToBaseValue(\n        uint256 dstableAmount\n    ) public view returns (uint256) {\n        uint8 dstableDecimals = dstable.decimals();\n        // Align valuation with Issuer/Redeemer: assume 1 dStable == baseCurrencyUnit\n        return (dstableAmount * baseCurrencyUnit) / (10 ** dstableDecimals);\n    }\n\n    /* Admin */\n\n    /**\n     * @notice Sets the collateral vault address\n     * @param _collateralVault The address of the new collateral vault\n     */\n    function setCollateralVault(\n        address _collateralVault\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        collateralHolderVault = CollateralVault(_collateralVault);\n    }\n}\n\n/**\n * @title ICollateralSum\n * @dev Interface for contracts that can provide total collateral value.\n */\ninterface ICollateralSum {\n    /**\n     * @notice Returns the total collateral value of the implementing contract.\n     * @return The total collateral value in base value.\n     */\n    function totalCollateralValue() external view returns (uint256);\n}\n"
    },
    "contracts/dstable/AmoVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"contracts/common/IMintableERC20.sol\";\nimport \"./AmoManager.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"contracts/dstable/CollateralVault.sol\";\n\ninterface IRecoverable {\n    function recoverERC20(address token, address to, uint256 amount) external;\n\n    function recoverETH(address to, uint256 amount) external;\n}\n\n/**\n * @title AmoVault\n * @notice Base contract for AMO (Algorithmic Market Operations) vaults that manage dStable and collateral assets\n */\nabstract contract AmoVault is CollateralVault, IRecoverable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    /* Core state */\n\n    IMintableERC20 public immutable dstable;\n    uint8 public immutable dstableDecimals;\n    AmoManager public amoManager;\n\n    /* Roles */\n\n    bytes32 public constant RECOVERER_ROLE = keccak256(\"RECOVERER_ROLE\");\n\n    /* Errors */\n\n    error CannotRecoverVaultToken(address token);\n    error InvalidAmoManager();\n\n    constructor(\n        address _dstable,\n        address _amoManager,\n        address _admin,\n        address _collateralWithdrawer,\n        address _recoverer,\n        IPriceOracleGetter _oracle\n    ) CollateralVault(_oracle) {\n        dstable = IMintableERC20(_dstable);\n        dstableDecimals = IERC20Metadata(_dstable).decimals();\n        amoManager = AmoManager(_amoManager);\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        grantRole(COLLATERAL_WITHDRAWER_ROLE, _collateralWithdrawer);\n        grantRole(RECOVERER_ROLE, _recoverer);\n        dstable.approve(address(amoManager), type(uint256).max);\n    }\n\n    /**\n     * @notice Approves the AmoManager to spend dStable on behalf of this contract\n     * @dev Only callable by the contract owner or an account with the DEFAULT_ADMIN_ROLE\n     */\n    function approveAmoManager() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        dstable.approve(address(amoManager), type(uint256).max);\n    }\n\n    /**\n     * @notice Updates the dStable allowance granted to the current AmoManager\n     * @dev Resets the existing allowance to 0 first to accommodate non-standard ERC20 tokens that require\n     *      the allowance to be set to zero before changing it.\n     * @param amount The new allowance amount to grant.\n     */\n    function setAmoManagerApproval(\n        uint256 amount\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        // Reset to zero first for safety with tokens that enforce the ERC20 race-condition mitigation\n        dstable.approve(address(amoManager), 0);\n        dstable.approve(address(amoManager), amount);\n    }\n\n    /**\n     * @notice Sets a new AmoManager address\n     * @param _newAmoManager The address of the new AmoManager\n     * @dev Only callable by an account with the DEFAULT_ADMIN_ROLE\n     */\n    function setAmoManager(\n        address _newAmoManager\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_newAmoManager == address(0)) revert InvalidAmoManager();\n\n        // Revoke allowance from the previous AmoManager to prevent it from spending vault funds\n        dstable.approve(address(amoManager), 0);\n\n        // Set new AMO manager\n        amoManager = AmoManager(_newAmoManager);\n\n        // Approve new AMO manager\n        approveAmoManager();\n    }\n\n    /* Recovery */\n\n    /**\n     * @notice Recovers ERC20 tokens accidentally sent to the contract\n     * @param token The address of the token to recover\n     * @param to The address to send the tokens to\n     * @param amount The amount of tokens to recover\n     */\n    function recoverERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyRole(RECOVERER_ROLE) nonReentrant {\n        if (token == address(dstable) || isCollateralSupported(token)) {\n            revert CannotRecoverVaultToken(token);\n        }\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Recovers ETH accidentally sent to the contract\n     * @param to The address to send the ETH to\n     * @param amount The amount of ETH to recover\n     */\n    function recoverETH(\n        address to,\n        uint256 amount\n    ) external onlyRole(RECOVERER_ROLE) {\n        payable(to).sendValue(amount);\n    }\n\n    /* Virtual functions */\n\n    /**\n     * @notice Calculates the total value of non-dStable collateral assets in the vault\n     * @return The total value of collateral assets denominated in the base currency\n     * @dev Must be implemented by derived contracts\n     */\n    function totalCollateralValue() public view virtual returns (uint256);\n\n    /**\n     * @notice Calculates the total value of dStable holdings in the vault\n     * @return The total value of dStable holdings denominated in the base currency\n     * @dev Must be implemented by derived contracts\n     */\n    function totalDstableValue() public view virtual returns (uint256);\n}\n"
    },
    "contracts/dstable/CollateralVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"contracts/common/IAaveOracle.sol\";\nimport \"./OracleAware.sol\";\n\n/**\n * @title CollateralVault\n * @notice Abstract contract for any contract that manages collateral assets\n\\ */\nabstract contract CollateralVault is AccessControl, OracleAware {\n    using SafeERC20 for IERC20Metadata;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* Core state */\n\n    EnumerableSet.AddressSet internal _supportedCollaterals;\n\n    /* Events */\n\n    event CollateralAllowed(address indexed collateralAsset);\n    event CollateralDisallowed(address indexed collateralAsset);\n\n    /* Roles */\n\n    bytes32 public constant COLLATERAL_MANAGER_ROLE =\n        keccak256(\"COLLATERAL_MANAGER_ROLE\");\n    bytes32 public constant COLLATERAL_STRATEGY_ROLE =\n        keccak256(\"COLLATERAL_STRATEGY_ROLE\");\n    bytes32 public constant COLLATERAL_WITHDRAWER_ROLE =\n        keccak256(\"COLLATERAL_WITHDRAWER_ROLE\");\n\n    /* Errors */\n    error UnsupportedCollateral(address collateralAsset);\n    error CollateralAlreadyAllowed(address collateralAsset);\n    error NoOracleSupport(address collateralAsset);\n    error FailedToAddCollateral(address collateralAsset);\n    error CollateralNotSupported(address collateralAsset);\n    error MustSupportAtLeastOneCollateral();\n    error FailedToRemoveCollateral(address collateralAsset);\n\n    /**\n     * @notice Initializes the vault with an oracle and sets up initial roles\n     * @dev Grants all roles to the contract deployer initially\n     * @param oracle The price oracle to use for collateral valuation\n     */\n    constructor(\n        IPriceOracleGetter oracle\n    ) OracleAware(oracle, oracle.BASE_CURRENCY_UNIT()) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); // This is the super admin\n        grantRole(COLLATERAL_MANAGER_ROLE, msg.sender);\n        grantRole(COLLATERAL_WITHDRAWER_ROLE, msg.sender);\n        grantRole(COLLATERAL_STRATEGY_ROLE, msg.sender);\n    }\n\n    /* Deposit */\n\n    /**\n     * @notice Deposit collateral into the vault\n     * @param collateralAmount The amount of collateral to deposit\n     * @param collateralAsset The address of the collateral asset\n     */\n    function deposit(uint256 collateralAmount, address collateralAsset) public {\n        if (!_supportedCollaterals.contains(collateralAsset)) {\n            revert UnsupportedCollateral(collateralAsset);\n        }\n\n        IERC20Metadata(collateralAsset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralAmount\n        );\n    }\n\n    /* Withdrawal */\n\n    /**\n     * @notice Withdraws collateral from the vault\n     * @param collateralAmount The amount of collateral to withdraw\n     * @param collateralAsset The address of the collateral asset\n     */\n    function withdraw(\n        uint256 collateralAmount,\n        address collateralAsset\n    ) public onlyRole(COLLATERAL_WITHDRAWER_ROLE) {\n        return _withdraw(msg.sender, collateralAmount, collateralAsset);\n    }\n\n    /**\n     * @notice Withdraws collateral from the vault to a specific address\n     * @param recipient The address receiving the collateral\n     * @param collateralAmount The amount of collateral to withdraw\n     * @param collateralAsset The address of the collateral asset\n     */\n    function withdrawTo(\n        address recipient,\n        uint256 collateralAmount,\n        address collateralAsset\n    ) public onlyRole(COLLATERAL_WITHDRAWER_ROLE) {\n        return _withdraw(recipient, collateralAmount, collateralAsset);\n    }\n\n    /**\n     * @notice Internal function to withdraw collateral from the vault\n     * @param withdrawer The address withdrawing the collateral\n     * @param collateralAmount The amount of collateral to withdraw\n     * @param collateralAsset The address of the collateral asset\n     */\n    function _withdraw(\n        address withdrawer,\n        uint256 collateralAmount,\n        address collateralAsset\n    ) internal {\n        IERC20Metadata(collateralAsset).safeTransfer(\n            withdrawer,\n            collateralAmount\n        );\n    }\n\n    /* Collateral Info */\n\n    /**\n     * @notice Calculates the total value of all assets in the vault\n     * @return baseValue The total value of all assets in base\n     */\n    function totalValue() public view virtual returns (uint256 baseValue);\n\n    /**\n     * @notice Calculates the base value of a given amount of an asset\n     * @param assetAmount The amount of the asset\n     * @param asset The address of the asset\n     * @return baseValue The base value of the asset\n     */\n    function assetValueFromAmount(\n        uint256 assetAmount,\n        address asset\n    ) public view returns (uint256 baseValue) {\n        uint256 assetPrice = oracle.getAssetPrice(asset);\n        uint8 assetDecimals = IERC20Metadata(asset).decimals();\n        return (assetPrice * assetAmount) / (10 ** assetDecimals);\n    }\n\n    /**\n     * @notice Calculates the amount of an asset that corresponds to a given base value\n     * @param baseValue The base value\n     * @param asset The address of the asset\n     * @return assetAmount The amount of the asset\n     */\n    function assetAmountFromValue(\n        uint256 baseValue,\n        address asset\n    ) public view returns (uint256 assetAmount) {\n        uint256 assetPrice = oracle.getAssetPrice(asset);\n        uint8 assetDecimals = IERC20Metadata(asset).decimals();\n        return (baseValue * (10 ** assetDecimals)) / assetPrice;\n    }\n\n    /* Collateral management */\n\n    /**\n     * @notice Allows a new collateral asset\n     * @param collateralAsset The address of the collateral asset\n     */\n    function allowCollateral(\n        address collateralAsset\n    ) public onlyRole(COLLATERAL_MANAGER_ROLE) {\n        if (_supportedCollaterals.contains(collateralAsset)) {\n            revert CollateralAlreadyAllowed(collateralAsset);\n        }\n        if (oracle.getAssetPrice(collateralAsset) == 0) {\n            revert NoOracleSupport(collateralAsset);\n        }\n        if (!_supportedCollaterals.add(collateralAsset)) {\n            revert FailedToAddCollateral(collateralAsset);\n        }\n        emit CollateralAllowed(collateralAsset);\n    }\n\n    /**\n     * @notice Disallows a previously supported collateral asset\n     * @dev Requires at least one collateral asset to remain supported\n     * @param collateralAsset The address of the collateral asset to disallow\n     */\n    function disallowCollateral(\n        address collateralAsset\n    ) public onlyRole(COLLATERAL_MANAGER_ROLE) {\n        if (!_supportedCollaterals.contains(collateralAsset)) {\n            revert CollateralNotSupported(collateralAsset);\n        }\n        if (_supportedCollaterals.length() <= 1) {\n            revert MustSupportAtLeastOneCollateral();\n        }\n        if (!_supportedCollaterals.remove(collateralAsset)) {\n            revert FailedToRemoveCollateral(collateralAsset);\n        }\n\n        emit CollateralDisallowed(collateralAsset);\n    }\n\n    /**\n     * @notice Checks if a given asset is supported as collateral\n     * @param collateralAsset The address of the collateral asset to check\n     * @return bool True if the asset is supported, false otherwise\n     */\n    function isCollateralSupported(\n        address collateralAsset\n    ) public view returns (bool) {\n        return _supportedCollaterals.contains(collateralAsset);\n    }\n\n    /**\n     * @notice Returns a list of all supported collateral assets\n     * @return address[] Array of collateral asset addresses\n     */\n    function listCollateral() public view returns (address[] memory) {\n        return _supportedCollaterals.values();\n    }\n\n    /**\n     * @notice Calculates the total base value of all supported collateral assets in the vault\n     * @dev Iterates through all supported collaterals and sums their base values\n     * @return uint256 The total value in base\n     */\n    function _totalValueOfSupportedCollaterals()\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalBaseValue = 0;\n        for (uint256 i = 0; i < _supportedCollaterals.length(); i++) {\n            address collateral = _supportedCollaterals.at(i);\n            uint256 collateralPrice = oracle.getAssetPrice(collateral);\n            uint8 collateralDecimals = IERC20Metadata(collateral).decimals();\n            uint256 collateralValue = (collateralPrice *\n                IERC20Metadata(collateral).balanceOf(address(this))) /\n                (10 ** collateralDecimals);\n            totalBaseValue += collateralValue;\n        }\n        return totalBaseValue;\n    }\n}\n"
    },
    "contracts/dstable/Issuer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"contracts/common/IAaveOracle.sol\";\nimport \"contracts/common/IMintableERC20.sol\";\nimport \"./CollateralVault.sol\";\nimport \"./AmoManager.sol\";\nimport \"./OracleAware.sol\";\n\n/**\n * @title Issuer\n * @notice Contract responsible for issuing dStable tokens\n */\ncontract Issuer is AccessControl, OracleAware, ReentrancyGuard {\n    using SafeERC20 for IERC20Metadata;\n\n    /* Core state */\n\n    IMintableERC20 public dstable;\n    uint8 public immutable dstableDecimals;\n    CollateralVault public collateralVault;\n    AmoManager public amoManager;\n\n    /* Events */\n\n    event CollateralVaultSet(address indexed collateralVault);\n    event AmoManagerSet(address indexed amoManager);\n\n    /* Roles */\n\n    bytes32 public constant AMO_MANAGER_ROLE = keccak256(\"AMO_MANAGER_ROLE\");\n    bytes32 public constant INCENTIVES_MANAGER_ROLE =\n        keccak256(\"INCENTIVES_MANAGER_ROLE\");\n\n    /* Errors */\n\n    error SlippageTooHigh(uint256 minDStable, uint256 dstableAmount);\n    error IssuanceSurpassesExcessCollateral(\n        uint256 collateralInDstable,\n        uint256 circulatingDstable\n    );\n    error MintingToAmoShouldNotIncreaseSupply(\n        uint256 circulatingDstableBefore,\n        uint256 circulatingDstableAfter\n    );\n\n    /**\n     * @notice Initializes the Issuer contract with core dependencies\n     * @param _collateralVault The address of the collateral vault\n     * @param _dstable The address of the dStable stablecoin\n     * @param oracle The address of the price oracle\n     * @param _amoManager The address of the AMO Manager\n     */\n    constructor(\n        address _collateralVault,\n        address _dstable,\n        IPriceOracleGetter oracle,\n        address _amoManager\n    ) OracleAware(oracle, oracle.BASE_CURRENCY_UNIT()) {\n        collateralVault = CollateralVault(_collateralVault);\n        dstable = IMintableERC20(_dstable);\n        dstableDecimals = dstable.decimals();\n        amoManager = AmoManager(_amoManager);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        grantRole(AMO_MANAGER_ROLE, msg.sender);\n        grantRole(INCENTIVES_MANAGER_ROLE, msg.sender);\n    }\n\n    /* Issuer */\n\n    /**\n     * @notice Issues dStable tokens in exchange for collateral from the caller\n     * @param collateralAmount The amount of collateral to deposit\n     * @param collateralAsset The address of the collateral asset\n     * @param minDStable The minimum amount of dStable to receive, used for slippage protection\n     */\n    function issue(\n        uint256 collateralAmount,\n        address collateralAsset,\n        uint256 minDStable\n    ) external nonReentrant {\n        // Ensure the collateral asset is supported by the vault before any further processing\n        if (!collateralVault.isCollateralSupported(collateralAsset)) {\n            revert CollateralVault.UnsupportedCollateral(collateralAsset);\n        }\n\n        uint8 collateralDecimals = IERC20Metadata(collateralAsset).decimals();\n        uint256 baseValue = (oracle.getAssetPrice(collateralAsset) *\n            collateralAmount) / (10 ** collateralDecimals);\n        uint256 dstableAmount = baseValueToDstableAmount(baseValue);\n        if (dstableAmount < minDStable) {\n            revert SlippageTooHigh(minDStable, dstableAmount);\n        }\n\n        // Transfer collateral directly to vault\n        IERC20Metadata(collateralAsset).safeTransferFrom(\n            msg.sender,\n            address(collateralVault),\n            collateralAmount\n        );\n\n        dstable.mint(msg.sender, dstableAmount);\n    }\n\n    /**\n     * @notice Issues dStable tokens using excess collateral in the system\n     * @param receiver The address to receive the minted dStable tokens\n     * @param dstableAmount The amount of dStable to mint\n     */\n    function issueUsingExcessCollateral(\n        address receiver,\n        uint256 dstableAmount\n    ) external onlyRole(INCENTIVES_MANAGER_ROLE) {\n        dstable.mint(receiver, dstableAmount);\n\n        // We don't use the buffer value here because we only mint up to the excess collateral\n        uint256 _circulatingDstable = circulatingDstable();\n        uint256 _collateralInDstable = collateralInDstable();\n        if (_collateralInDstable < _circulatingDstable) {\n            revert IssuanceSurpassesExcessCollateral(\n                _collateralInDstable,\n                _circulatingDstable\n            );\n        }\n    }\n\n    /**\n     * @notice Increases the AMO supply by minting new dStable tokens\n     * @param dstableAmount The amount of dStable to mint and send to the AMO Manager\n     */\n    function increaseAmoSupply(\n        uint256 dstableAmount\n    ) external onlyRole(AMO_MANAGER_ROLE) {\n        uint256 _circulatingDstableBefore = circulatingDstable();\n\n        dstable.mint(address(amoManager), dstableAmount);\n\n        uint256 _circulatingDstableAfter = circulatingDstable();\n\n        // Sanity check that we are sending to the active AMO Manager\n        if (_circulatingDstableAfter != _circulatingDstableBefore) {\n            revert MintingToAmoShouldNotIncreaseSupply(\n                _circulatingDstableBefore,\n                _circulatingDstableAfter\n            );\n        }\n    }\n\n    /**\n     * @notice Calculates the circulating supply of dStable tokens\n     * @return The amount of dStable tokens that are not held by the AMO Manager\n     */\n    function circulatingDstable() public view returns (uint256) {\n        uint256 totalDstable = dstable.totalSupply();\n        uint256 amoDstable = amoManager.totalAmoSupply();\n        return totalDstable - amoDstable;\n    }\n\n    /**\n     * @notice Calculates the collateral value in dStable tokens\n     * @return The amount of dStable tokens equivalent to the collateral value\n     */\n    function collateralInDstable() public view returns (uint256) {\n        uint256 _collateralInBase = collateralVault.totalValue();\n        return baseValueToDstableAmount(_collateralInBase);\n    }\n\n    /**\n     * @notice Converts a base value to an equivalent amount of dStable tokens\n     * @param baseValue The amount of base value to convert\n     * @return The equivalent amount of dStable tokens\n     */\n    function baseValueToDstableAmount(\n        uint256 baseValue\n    ) public view returns (uint256) {\n        return (baseValue * (10 ** dstableDecimals)) / baseCurrencyUnit;\n    }\n\n    /* Admin */\n\n    /**\n     * @notice Sets the AMO Manager address\n     * @param _amoManager The address of the AMO Manager\n     */\n    function setAmoManager(\n        address _amoManager\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        amoManager = AmoManager(_amoManager);\n        grantRole(AMO_MANAGER_ROLE, _amoManager);\n        emit AmoManagerSet(_amoManager);\n    }\n\n    /**\n     * @notice Sets the collateral vault address\n     * @param _collateralVault The address of the collateral vault\n     */\n    function setCollateralVault(\n        address _collateralVault\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        collateralVault = CollateralVault(_collateralVault);\n        emit CollateralVaultSet(_collateralVault);\n    }\n}\n"
    },
    "contracts/dstable/mocks/MockAmoVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"contracts/dstable/AmoVault.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ncontract MockAmoVault is AmoVault {\n    using SafeERC20 for IERC20;\n\n    uint256 private fakeDeFiCollateralValue;\n\n    constructor(\n        address _dstable,\n        address _amoManager,\n        address _admin,\n        address _collateralWithdrawer,\n        address _recoverer,\n        IPriceOracleGetter _oracle\n    )\n        AmoVault(\n            _dstable,\n            _amoManager,\n            _admin,\n            _collateralWithdrawer,\n            _recoverer,\n            _oracle\n        )\n    {}\n\n    // Override totalCollateralValue to return the sum of all simulated values\n    function totalCollateralValue() public view override returns (uint256) {\n        return _totalValueOfSupportedCollaterals() + fakeDeFiCollateralValue;\n    }\n\n    // Override totalDstableValue to return the sum of all simulated values\n    function totalDstableValue() public view override returns (uint256) {\n        uint256 dstableBalance = dstable.balanceOf(address(this));\n        uint256 dstablePrice = oracle.getAssetPrice(address(dstable));\n        uint256 dstableValue = (dstableBalance * dstablePrice) /\n            (10 ** dstableDecimals);\n\n        return dstableValue;\n    }\n\n    function totalValue() public view override returns (uint256) {\n        return totalCollateralValue() + totalDstableValue();\n    }\n\n    // Simulate AmoVault losing some value\n    function mockRemoveAsset(address asset, uint256 amount) external {\n        IERC20(asset).safeTransfer(\n            address(0x000000000000000000000000000000000000dEaD), // Arbitrary black hole address\n            amount\n        );\n    }\n\n    // Simulate fake DeFi returns\n    function getFakeDeFiCollateralValue() external view returns (uint256) {\n        return fakeDeFiCollateralValue;\n    }\n\n    // Set fake DeFi collateral value\n    function setFakeDeFiCollateralValue(uint256 value) external {\n        fakeDeFiCollateralValue = value;\n    }\n}\n"
    },
    "contracts/dstable/OracleAware.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"contracts/common/IAaveOracle.sol\";\n\n/**\n * @title OracleAware\n * @notice Abstract contract that provides oracle functionality to other contracts\n */\nabstract contract OracleAware is AccessControl {\n    /* Core state */\n\n    IPriceOracleGetter public oracle;\n    uint256 public baseCurrencyUnit;\n\n    /* Events */\n\n    event OracleSet(address indexed newOracle);\n\n    /* Errors */\n\n    error IncorrectBaseCurrencyUnit(uint256 baseCurrencyUnit);\n\n    /**\n     * @notice Initializes the contract with an oracle and base currency unit\n     * @param initialOracle The initial oracle to use for price feeds\n     * @param _baseCurrencyUnit The base currency unit for price calculations\n     * @dev Sets up the initial oracle and base currency unit values\n     */\n    constructor(IPriceOracleGetter initialOracle, uint256 _baseCurrencyUnit) {\n        oracle = initialOracle;\n        baseCurrencyUnit = _baseCurrencyUnit;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Sets the oracle to use for collateral valuation\n     * @param newOracle The new oracle to use\n     */\n    function setOracle(\n        IPriceOracleGetter newOracle\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (newOracle.BASE_CURRENCY_UNIT() != baseCurrencyUnit) {\n            revert IncorrectBaseCurrencyUnit(baseCurrencyUnit);\n        }\n\n        oracle = newOracle;\n\n        emit OracleSet(address(newOracle));\n    }\n\n    /**\n     * @notice Updates the base currency unit used for price calculations\n     * @param _newBaseCurrencyUnit The new base currency unit to set\n     * @dev Only used if the oracle's base currency unit changes\n     */\n    function setBaseCurrencyUnit(\n        uint256 _newBaseCurrencyUnit\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        baseCurrencyUnit = _newBaseCurrencyUnit;\n    }\n}\n"
    },
    "contracts/dstable/Redeemer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport \"contracts/common/IMintableERC20.sol\";\nimport \"./CollateralVault.sol\";\nimport \"./OracleAware.sol\";\n\ncontract Redeemer is AccessControl, OracleAware {\n    /* Core state */\n\n    IMintableERC20 public dstable;\n    uint8 public immutable dstableDecimals;\n    CollateralVault public collateralVault;\n\n    /* Roles */\n\n    bytes32 public constant REDEMPTION_MANAGER_ROLE =\n        keccak256(\"REDEMPTION_MANAGER_ROLE\");\n\n    /* Errors */\n    error DStableTransferFailed();\n    error SlippageTooHigh(uint256 actualCollateral, uint256 minCollateral);\n\n    /**\n     * @notice Initializes the Redeemer contract\n     * @param _collateralVault The address of the collateral vault\n     * @param _dstable The address of the dStable stablecoin\n     * @param _oracle The address of the price oracle\n     * @dev Sets up initial roles and configuration for redemption functionality\n     */\n    constructor(\n        address _collateralVault,\n        address _dstable,\n        IPriceOracleGetter _oracle\n    ) OracleAware(_oracle, _oracle.BASE_CURRENCY_UNIT()) {\n        collateralVault = CollateralVault(_collateralVault);\n        dstable = IMintableERC20(_dstable);\n        dstableDecimals = dstable.decimals();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        grantRole(REDEMPTION_MANAGER_ROLE, msg.sender);\n    }\n\n    /* Redeemer */\n\n    /**\n     * @notice Redeems dStable tokens for collateral from the caller\n     * @param dstableAmount The amount of dStable to redeem\n     * @param collateralAsset The address of the collateral asset\n     * @param minCollateral The minimum amount of collateral to receive, used for slippage protection\n     */\n    function redeem(\n        uint256 dstableAmount,\n        address collateralAsset,\n        uint256 minCollateral\n    ) external onlyRole(REDEMPTION_MANAGER_ROLE) {\n        // Transfer dStable from withdrawer to this contract\n        if (!dstable.transferFrom(msg.sender, address(this), dstableAmount)) {\n            revert DStableTransferFailed();\n        }\n\n        // Burn the dStable\n        dstable.burn(dstableAmount);\n\n        // Calculate collateral amount\n        uint256 dstableValue = dstableAmountToBaseValue(dstableAmount);\n        uint256 collateralAmount = collateralVault.assetAmountFromValue(\n            dstableValue,\n            collateralAsset\n        );\n        if (collateralAmount < minCollateral) {\n            revert SlippageTooHigh(collateralAmount, minCollateral);\n        }\n\n        // Withdraw collateral from the vault\n        collateralVault.withdrawTo(\n            msg.sender,\n            collateralAmount,\n            collateralAsset\n        );\n    }\n\n    /**\n     * @notice Converts an amount of dStable tokens to its equivalent base value.\n     * @param dstableAmount The amount of dStable tokens to convert.\n     * @return The equivalent base value.\n     */\n    function dstableAmountToBaseValue(\n        uint256 dstableAmount\n    ) public view returns (uint256) {\n        return (dstableAmount * baseCurrencyUnit) / (10 ** dstableDecimals);\n    }\n\n    /* Admin */\n\n    /**\n     * @notice Sets the collateral vault address\n     * @param _collateralVault The address of the new collateral vault\n     */\n    function setCollateralVault(\n        address _collateralVault\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        collateralVault = CollateralVault(_collateralVault);\n    }\n}\n"
    },
    "contracts/dstable/RedeemerWithFees.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\\\"\\_\\ \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"contracts/common/IMintableERC20.sol\";\nimport \"./CollateralVault.sol\";\nimport \"./OracleAware.sol\";\nimport \"contracts/common/BasisPointConstants.sol\";\n\ncontract RedeemerWithFees is AccessControl, OracleAware {\n    /* Constants */\n    uint256 public immutable MAX_FEE_BPS;\n\n    /* Core state */\n    IMintableERC20 public dstable;\n    uint8 public immutable dstableDecimals;\n    CollateralVault public collateralVault;\n\n    /* Fee related state */\n    address public feeReceiver;\n    uint256 public defaultRedemptionFeeBps; // Default fee in basis points\n    mapping(address => uint256) public collateralRedemptionFeeBps; // Fee in basis points per collateral asset\n\n    /* Roles */\n    bytes32 public constant REDEMPTION_MANAGER_ROLE =\n        keccak256(\"REDEMPTION_MANAGER_ROLE\");\n\n    /* Events */\n    event FeeReceiverUpdated(\n        address indexed oldFeeReceiver,\n        address indexed newFeeReceiver\n    );\n    event DefaultRedemptionFeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n    event CollateralRedemptionFeeUpdated(\n        address indexed collateralAsset,\n        uint256 oldFeeBps,\n        uint256 newFeeBps\n    );\n    event Redemption(\n        address indexed redeemer,\n        address indexed collateralAsset,\n        uint256 dstableAmount,\n        uint256 collateralAmountToRedeemer,\n        uint256 feeAmountCollateral\n    );\n\n    /* Errors */\n    error DStableTransferFailed();\n    error SlippageTooHigh(uint256 actualCollateral, uint256 minCollateral);\n    error FeeTooHigh(uint256 requestedFeeBps, uint256 maxFeeBps);\n    error CollateralTransferFailed(\n        address recipient,\n        uint256 amount,\n        address token\n    );\n    error CannotBeZeroAddress();\n\n    /**\n     * @notice Initializes the RedeemerWithFees contract\n     * @param _collateralVault The address of the collateral vault\n     * @param _dstable The address of the dStable stablecoin\n     * @param _oracle The address of the price oracle\n     * @param _initialFeeReceiver The initial address to receive redemption fees\n     * @param _initialRedemptionFeeBps The initial redemption fee in basis points\n     * @dev Sets up initial roles and configuration for redemption functionality\n     */\n    constructor(\n        address _collateralVault,\n        address _dstable,\n        IPriceOracleGetter _oracle,\n        address _initialFeeReceiver,\n        uint256 _initialRedemptionFeeBps\n    ) OracleAware(_oracle, _oracle.BASE_CURRENCY_UNIT()) {\n        if (\n            _collateralVault == address(0) ||\n            _dstable == address(0) ||\n            address(_oracle) == address(0)\n        ) {\n            revert CannotBeZeroAddress();\n        }\n        if (_initialFeeReceiver == address(0)) {\n            revert CannotBeZeroAddress();\n        }\n\n        MAX_FEE_BPS = 5 * BasisPointConstants.ONE_PERCENT_BPS; // 5%\n\n        if (_initialRedemptionFeeBps > MAX_FEE_BPS) {\n            revert FeeTooHigh(_initialRedemptionFeeBps, MAX_FEE_BPS);\n        }\n\n        collateralVault = CollateralVault(_collateralVault);\n        dstable = IMintableERC20(_dstable);\n        dstableDecimals = dstable.decimals();\n\n        feeReceiver = _initialFeeReceiver;\n        defaultRedemptionFeeBps = _initialRedemptionFeeBps;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(REDEMPTION_MANAGER_ROLE, msg.sender); // Grant to deployer as well\n\n        emit FeeReceiverUpdated(address(0), _initialFeeReceiver);\n        emit DefaultRedemptionFeeUpdated(0, _initialRedemptionFeeBps);\n    }\n\n    /* Public Redemption */\n\n    /**\n     * @notice Allows anyone to redeem dStable tokens for collateral, subject to a fee.\n     * @param dstableAmount The amount of dStable to redeem.\n     * @param collateralAsset The address of the collateral asset.\n     * @param minNetCollateral The minimum amount of collateral to receive after fees, for slippage protection.\n     */\n    function redeem(\n        uint256 dstableAmount,\n        address collateralAsset,\n        uint256 minNetCollateral\n    ) external {\n        // Ensure the requested collateral asset is supported by the vault\n        if (!collateralVault.isCollateralSupported(collateralAsset)) {\n            revert CollateralVault.UnsupportedCollateral(collateralAsset);\n        }\n\n        uint256 dstableValue = dstableAmountToBaseValue(dstableAmount);\n        uint256 totalCollateral = collateralVault.assetAmountFromValue(\n            dstableValue,\n            collateralAsset\n        );\n        // Calculate fee\n        uint256 feeCollateral = 0;\n        uint256 currentFeeBps = collateralRedemptionFeeBps[collateralAsset];\n        if (currentFeeBps == 0) {\n            currentFeeBps = defaultRedemptionFeeBps;\n        }\n\n        if (currentFeeBps > 0) {\n            feeCollateral =\n                (totalCollateral * currentFeeBps) /\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n            if (feeCollateral > totalCollateral) {\n                // This should never happen\n                revert FeeTooHigh(currentFeeBps, MAX_FEE_BPS);\n            }\n        }\n        uint256 netCollateral = totalCollateral - feeCollateral;\n        if (netCollateral < minNetCollateral) {\n            revert SlippageTooHigh(netCollateral, minNetCollateral);\n        }\n\n        // Burn and withdraw net amount to redeemer\n        _redeem(msg.sender, dstableAmount, collateralAsset, netCollateral);\n\n        // Withdraw fee to feeReceiver\n        if (feeCollateral > 0) {\n            collateralVault.withdrawTo(\n                feeReceiver,\n                feeCollateral,\n                collateralAsset\n            );\n        }\n\n        emit Redemption(\n            msg.sender,\n            collateralAsset,\n            dstableAmount,\n            netCollateral,\n            feeCollateral\n        );\n    }\n\n    /* Protocol Redemption */\n\n    /**\n     * @notice Allows the REDEMPTION_MANAGER_ROLE to redeem dStable tokens for collateral without fees.\n     * @param dstableAmount The amount of dStable to redeem.\n     * @param collateralAsset The address of the collateral asset.\n     * @param minCollateral The minimum amount of collateral to receive, for slippage protection.\n     */\n    function redeemAsProtocol(\n        uint256 dstableAmount,\n        address collateralAsset,\n        uint256 minCollateral\n    ) external onlyRole(REDEMPTION_MANAGER_ROLE) {\n        uint256 dstableValue = dstableAmountToBaseValue(dstableAmount);\n        uint256 totalCollateral = collateralVault.assetAmountFromValue(\n            dstableValue,\n            collateralAsset\n        );\n        if (totalCollateral < minCollateral) {\n            revert SlippageTooHigh(totalCollateral, minCollateral);\n        }\n\n        // Burn and withdraw full amount to redeemer\n        _redeem(msg.sender, dstableAmount, collateralAsset, totalCollateral);\n\n        emit Redemption(\n            msg.sender,\n            collateralAsset,\n            dstableAmount,\n            totalCollateral,\n            0\n        );\n    }\n\n    /* Internal Core Redemption Logic */\n\n    /**\n     * @notice Internal helper to transfer dStable, burn it, and withdraw a specified collateral amount.\n     * @param redeemerAddress The address performing the redemption (source for dStable and recipient of collateral).\n     * @param dstableAmount The amount of dStable to redeem.\n     * @param collateralAsset The address of the collateral asset.\n     * @param collateralAmount The amount of collateral to withdraw to redeemer.\n     */\n    function _redeem(\n        address redeemerAddress,\n        uint256 dstableAmount,\n        address collateralAsset,\n        uint256 collateralAmount\n    ) internal {\n        if (\n            !dstable.transferFrom(redeemerAddress, address(this), dstableAmount)\n        ) {\n            revert DStableTransferFailed();\n        }\n        dstable.burn(dstableAmount);\n        collateralVault.withdrawTo(\n            redeemerAddress,\n            collateralAmount,\n            collateralAsset\n        );\n    }\n\n    /* Value Calculation */\n\n    /**\n     * @notice Converts an amount of dStable tokens to its equivalent base value.\n     * @param _dstableAmount The amount of dStable tokens to convert.\n     * @return The equivalent base value.\n     */\n    function dstableAmountToBaseValue(\n        uint256 _dstableAmount\n    ) public view returns (uint256) {\n        return (_dstableAmount * baseCurrencyUnit) / (10 ** dstableDecimals);\n    }\n\n    /* Admin Functions */\n\n    /**\n     * @notice Sets the collateral vault address.\n     * @param _collateralVault The address of the new collateral vault.\n     */\n    function setCollateralVault(\n        address _collateralVault\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_collateralVault == address(0)) {\n            revert CannotBeZeroAddress();\n        }\n        collateralVault = CollateralVault(_collateralVault);\n    }\n\n    /**\n     * @notice Sets the fee receiver address.\n     * @param _newFeeReceiver The address of the new fee receiver.\n     */\n    function setFeeReceiver(\n        address _newFeeReceiver\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_newFeeReceiver == address(0)) {\n            revert CannotBeZeroAddress();\n        }\n        address oldFeeReceiver = feeReceiver;\n        feeReceiver = _newFeeReceiver;\n        emit FeeReceiverUpdated(oldFeeReceiver, _newFeeReceiver);\n    }\n\n    /**\n     * @notice Sets the default redemption fee in basis points.\n     * @param _newFeeBps The new default redemption fee (e.g., 10000 for 1%).\n     */\n    function setDefaultRedemptionFee(\n        uint256 _newFeeBps\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_newFeeBps > MAX_FEE_BPS) {\n            revert FeeTooHigh(_newFeeBps, MAX_FEE_BPS);\n        }\n        uint256 oldFeeBps = defaultRedemptionFeeBps;\n        defaultRedemptionFeeBps = _newFeeBps;\n        emit DefaultRedemptionFeeUpdated(oldFeeBps, _newFeeBps);\n    }\n\n    /**\n     * @notice Sets the redemption fee for a specific collateral asset in basis points.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _newFeeBps The new redemption fee for the specified asset (e.g., 10000 for 1%).\n     */\n    function setCollateralRedemptionFee(\n        address _collateralAsset,\n        uint256 _newFeeBps\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_collateralAsset == address(0)) {\n            revert CannotBeZeroAddress();\n        }\n        if (_newFeeBps > MAX_FEE_BPS) {\n            revert FeeTooHigh(_newFeeBps, MAX_FEE_BPS);\n        }\n        uint256 oldFeeBps = collateralRedemptionFeeBps[_collateralAsset];\n        collateralRedemptionFeeBps[_collateralAsset] = _newFeeBps;\n        emit CollateralRedemptionFeeUpdated(\n            _collateralAsset,\n            oldFeeBps,\n            _newFeeBps\n        );\n    }\n}\n"
    },
    "contracts/odos/interface/IOdosRouterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\n/**\n * @dev Interface for Odos Router V2.\n * @dev Generated from original ABI: https://fraxscan.com/address/0x56c85a254dd12ee8d9c04049a4ab62769ce98210#code\n */\npragma solidity ^0.8.20;\n\ninterface IOdosRouterV2 {\n    struct swapTokenInfo {\n        address inputToken;\n        uint256 inputAmount;\n        address inputReceiver;\n        address outputToken;\n        uint256 outputQuote;\n        uint256 outputMin;\n        address outputReceiver;\n    }\n\n    struct inputTokenInfo {\n        address tokenAddress;\n        uint256 amountIn;\n        address receiver;\n    }\n\n    struct outputTokenInfo {\n        address tokenAddress;\n        uint256 relativeValue;\n        address receiver;\n    }\n\n    struct permit2Info {\n        address contractAddress;\n        uint256 nonce;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    event Swap(\n        address sender,\n        uint256 inputAmount,\n        address inputToken,\n        uint256 amountOut,\n        address outputToken,\n        int256 slippage,\n        uint32 referralCode\n    );\n\n    event SwapMulti(\n        address sender,\n        uint256[] amountsIn,\n        address[] tokensIn,\n        uint256[] amountsOut,\n        address[] tokensOut,\n        uint32 referralCode\n    );\n\n    function FEE_DENOM() external view returns (uint256);\n\n    function REFERRAL_WITH_FEE_THRESHOLD() external view returns (uint256);\n\n    function addressList(uint256) external view returns (address);\n\n    function owner() external view returns (address);\n\n    function referralLookup(\n        uint32\n    )\n        external\n        view\n        returns (uint64 referralFee, address beneficiary, bool registered);\n\n    function registerReferralCode(\n        uint32 _referralCode,\n        uint64 _referralFee,\n        address _beneficiary\n    ) external;\n\n    function renounceOwnership() external;\n\n    function setSwapMultiFee(uint256 _swapMultiFee) external;\n\n    function swap(\n        swapTokenInfo calldata tokenInfo,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external payable returns (uint256 amountOut);\n\n    function swapCompact() external payable returns (uint256);\n\n    function swapMulti(\n        inputTokenInfo[] calldata inputs,\n        outputTokenInfo[] calldata outputs,\n        uint256 valueOutMin,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external payable returns (uint256[] memory amountsOut);\n\n    function swapMultiCompact()\n        external\n        payable\n        returns (uint256[] memory amountsOut);\n\n    function swapMultiFee() external view returns (uint256);\n\n    function swapMultiPermit2(\n        permit2Info calldata permit2,\n        inputTokenInfo[] calldata inputs,\n        outputTokenInfo[] calldata outputs,\n        uint256 valueOutMin,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external payable returns (uint256[] memory amountsOut);\n\n    function swapPermit2(\n        permit2Info calldata permit2,\n        swapTokenInfo calldata tokenInfo,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external returns (uint256 amountOut);\n\n    function swapRouterFunds(\n        inputTokenInfo[] calldata inputs,\n        outputTokenInfo[] calldata outputs,\n        uint256 valueOutMin,\n        bytes calldata pathDefinition,\n        address executor\n    ) external returns (uint256[] memory amountsOut);\n\n    function transferOwnership(address newOwner) external;\n\n    function transferRouterFunds(\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        address dest\n    ) external;\n\n    function writeAddressList(address[] calldata addresses) external;\n\n    receive() external payable;\n}\n"
    },
    "contracts/odos/OdosSwapUtils.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.20;\n\nimport \"./interface/IOdosRouterV2.sol\";\nimport \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/**\n * @title OdosSwapUtils\n * @notice Library for handling Odos swaps in liquidator contracts\n */\nlibrary OdosSwapUtils {\n    using SafeTransferLib for ERC20;\n\n    /// @notice Custom error for failed swap with no revert reason\n    error SwapFailed();\n    /// @notice Custom error when actual output amount is less than expected\n    error InsufficientOutput(uint256 expected, uint256 actual);\n\n    /**\n     * @notice Performs an swap operation using Odos router with swap data\n     * @param router Odos router contract\n     * @param inputToken Input token\n     * @param maxIn Maximum input amount\n     * @param exactOut Exact output amount\n     * @param swapData Encoded swap path data\n     */\n    function executeSwapOperation(\n        IOdosRouterV2 router,\n        address inputToken,\n        uint256 maxIn,\n        uint256 exactOut,\n        bytes memory swapData\n    ) internal returns (uint256) {\n        ERC20(inputToken).approve(address(router), maxIn);\n\n        (bool success, bytes memory result) = address(router).call(swapData);\n        if (!success) {\n            // Decode the revert reason if present\n            if (result.length > 0) {\n                // First try to decode the standard revert reason\n                assembly {\n                    let resultLength := mload(result)\n                    revert(add(32, result), resultLength)\n                }\n            }\n            revert SwapFailed();\n        }\n\n        uint256 actualAmountOut;\n        assembly {\n            actualAmountOut := mload(add(result, 32))\n        }\n\n        if (actualAmountOut < exactOut) {\n            revert InsufficientOutput(exactOut, actualAmountOut);\n        }\n\n        return actualAmountOut;\n    }\n}\n"
    },
    "contracts/testing/dex/SimpleDEXMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"contracts/common/BasisPointConstants.sol\";\n\n/**\n * @title SimpleDEXMock\n * @notice A mock decentralized exchange contract for testing purposes\n * @dev This contract mimics DEX behavior with configurable exchange rates and execution slippage\n */\ncontract SimpleDEXMock {\n    using SafeERC20 for IERC20;\n\n    // State variables\n    mapping(address => mapping(address => uint256)) public exchangeRates; // inputToken => outputToken => rate (in 18 decimals)\n    uint256 public executionSlippageBps; // Execution slippage in basis points\n\n    // Events\n    event ExchangeRateSet(\n        address indexed inputToken,\n        address indexed outputToken,\n        uint256 rate\n    );\n    event ExecutionSlippageSet(uint256 slippageBps);\n    event SwapExecuted(\n        address indexed inputToken,\n        address indexed outputToken,\n        uint256 amountIn,\n        uint256 amountOut,\n        address indexed receiver,\n        string swapType\n    );\n\n    // Errors\n    error ZeroAddress();\n    error ZeroAmount();\n    error ExchangeRateNotSet();\n    error InsufficientOutputAmount(uint256 actual, uint256 minimum);\n    error ExcessiveInputAmount(uint256 actual, uint256 maximum);\n    error InsufficientBalance(\n        address token,\n        uint256 requested,\n        uint256 available\n    );\n    error InsufficientAllowance(\n        address token,\n        uint256 requested,\n        uint256 available\n    );\n    error TransferFailed();\n\n    /**\n     * @notice Constructor\n     */\n    constructor() {\n        executionSlippageBps = 0; // Default no execution slippage\n    }\n\n    /**\n     * @notice Set exchange rate for a token pair\n     * @param inputToken The input token address\n     * @param outputToken The output token address\n     * @param rate The exchange rate (how much outputToken per 1 inputToken, in 18 decimals)\n     */\n    function setExchangeRate(\n        address inputToken,\n        address outputToken,\n        uint256 rate\n    ) external {\n        if (inputToken == address(0) || outputToken == address(0)) {\n            revert ZeroAddress();\n        }\n        if (rate == 0) {\n            revert ZeroAmount();\n        }\n\n        exchangeRates[inputToken][outputToken] = rate;\n        emit ExchangeRateSet(inputToken, outputToken, rate);\n    }\n\n    /**\n     * @notice Set execution slippage in basis points\n     * @param slippageBps The execution slippage (e.g., 20000 = 2%)\n     */\n    function setExecutionSlippage(uint256 slippageBps) external {\n        if (slippageBps >= BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert(\"Execution slippage cannot be 100% or more\");\n        }\n        executionSlippageBps = slippageBps;\n        emit ExecutionSlippageSet(slippageBps);\n    }\n\n    /**\n     * @notice Execute swap with exact input amount\n     * @param inputToken The input token to swap from\n     * @param outputToken The output token to swap to\n     * @param amountIn The exact amount of input tokens to swap\n     * @param amountOutMinimum The minimum amount of output tokens expected\n     * @param receiver The address to receive the output tokens\n     * @return amountOut The actual amount of output tokens transferred\n     */\n    function executeSwapExactInput(\n        IERC20Metadata inputToken,\n        IERC20Metadata outputToken,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address receiver\n    ) external returns (uint256 amountOut) {\n        if (\n            address(inputToken) == address(0) ||\n            address(outputToken) == address(0)\n        ) {\n            revert ZeroAddress();\n        }\n        if (receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        if (amountIn == 0) {\n            revert ZeroAmount();\n        }\n\n        // Check exchange rate exists\n        uint256 rate = exchangeRates[address(inputToken)][address(outputToken)];\n        if (rate == 0) {\n            revert ExchangeRateNotSet();\n        }\n\n        // Check allowance\n        uint256 allowance = inputToken.allowance(msg.sender, address(this));\n        if (allowance < amountIn) {\n            revert InsufficientAllowance(\n                address(inputToken),\n                amountIn,\n                allowance\n            );\n        }\n\n        // Calculate output amount before slippage\n        uint256 outputBeforeSlippage = _calculateOutputAmount(\n            amountIn,\n            rate,\n            inputToken.decimals(),\n            outputToken.decimals()\n        );\n\n        // Apply execution slippage\n        amountOut = _applyExecutionSlippage(outputBeforeSlippage);\n\n        // Check minimum output\n        if (amountOut < amountOutMinimum) {\n            revert InsufficientOutputAmount(amountOut, amountOutMinimum);\n        }\n\n        // Check contract has enough output tokens\n        uint256 contractBalance = outputToken.balanceOf(address(this));\n        if (contractBalance < amountOut) {\n            revert InsufficientBalance(\n                address(outputToken),\n                amountOut,\n                contractBalance\n            );\n        }\n\n        // Execute the swap\n        IERC20(inputToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountIn\n        );\n        IERC20(outputToken).safeTransfer(receiver, amountOut);\n\n        emit SwapExecuted(\n            address(inputToken),\n            address(outputToken),\n            amountIn,\n            amountOut,\n            receiver,\n            \"ExactInput\"\n        );\n\n        return amountOut;\n    }\n\n    /**\n     * @notice Execute swap with exact output amount\n     * @param inputToken The input token to swap from\n     * @param outputToken The output token to swap to\n     * @param amountOut The exact amount of output tokens to receive\n     * @param amountInMaximum The maximum amount of input tokens to spend\n     * @param receiver The address to receive the output tokens\n     * @return amountIn The actual amount of input tokens spent\n     */\n    function executeSwapExactOutput(\n        IERC20Metadata inputToken,\n        IERC20Metadata outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver\n    ) external returns (uint256 amountIn) {\n        if (\n            address(inputToken) == address(0) ||\n            address(outputToken) == address(0)\n        ) {\n            revert ZeroAddress();\n        }\n        if (receiver == address(0)) {\n            revert ZeroAddress();\n        }\n        if (amountOut == 0) {\n            revert ZeroAmount();\n        }\n\n        // Check exchange rate exists\n        uint256 rate = exchangeRates[address(inputToken)][address(outputToken)];\n        if (rate == 0) {\n            revert ExchangeRateNotSet();\n        }\n\n        // Check contract has enough output tokens\n        uint256 contractBalance = outputToken.balanceOf(address(this));\n        if (contractBalance < amountOut) {\n            revert InsufficientBalance(\n                address(outputToken),\n                amountOut,\n                contractBalance\n            );\n        }\n\n        // Calculate required input amount considering execution slippage\n        // We need to calculate how much input is needed to get amountOut after slippage\n        uint256 amountOutBeforeSlippage = _reverseExecutionSlippage(amountOut);\n\n        amountIn = _calculateInputAmount(\n            amountOutBeforeSlippage,\n            rate,\n            inputToken.decimals(),\n            outputToken.decimals()\n        );\n\n        // Check maximum input\n        if (amountIn > amountInMaximum) {\n            revert ExcessiveInputAmount(amountIn, amountInMaximum);\n        }\n\n        // Check allowance\n        uint256 allowance = inputToken.allowance(msg.sender, address(this));\n        if (allowance < amountIn) {\n            revert InsufficientAllowance(\n                address(inputToken),\n                amountIn,\n                allowance\n            );\n        }\n\n        // Execute the swap\n        IERC20(inputToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountIn\n        );\n        IERC20(outputToken).safeTransfer(receiver, amountOut);\n\n        emit SwapExecuted(\n            address(inputToken),\n            address(outputToken),\n            amountIn,\n            amountOut,\n            receiver,\n            \"ExactOutput\"\n        );\n\n        return amountIn;\n    }\n\n    /**\n     * @notice Get the exchange rate for a token pair\n     * @param inputToken The input token address\n     * @param outputToken The output token address\n     * @return rate The exchange rate (18 decimals)\n     */\n    function getExchangeRate(\n        address inputToken,\n        address outputToken\n    ) external view returns (uint256 rate) {\n        return exchangeRates[inputToken][outputToken];\n    }\n\n    /**\n     * @notice Preview output amount for exact input swap\n     * @param inputToken The input token\n     * @param outputToken The output token\n     * @param amountIn The input amount\n     * @return amountOut The expected output amount (after execution slippage)\n     */\n    function previewSwapExactInput(\n        IERC20Metadata inputToken,\n        IERC20Metadata outputToken,\n        uint256 amountIn\n    ) external view returns (uint256 amountOut) {\n        uint256 rate = exchangeRates[address(inputToken)][address(outputToken)];\n        if (rate == 0) {\n            return 0;\n        }\n\n        uint256 outputBeforeSlippage = _calculateOutputAmount(\n            amountIn,\n            rate,\n            inputToken.decimals(),\n            outputToken.decimals()\n        );\n\n        return _applyExecutionSlippage(outputBeforeSlippage);\n    }\n\n    /**\n     * @notice Preview input amount for exact output swap\n     * @param inputToken The input token\n     * @param outputToken The output token\n     * @param amountOut The output amount\n     * @return amountIn The expected input amount required\n     */\n    function previewSwapExactOutput(\n        IERC20Metadata inputToken,\n        IERC20Metadata outputToken,\n        uint256 amountOut\n    ) external view returns (uint256 amountIn) {\n        uint256 rate = exchangeRates[address(inputToken)][address(outputToken)];\n        if (rate == 0) {\n            return 0;\n        }\n\n        uint256 amountOutBeforeSlippage = _reverseExecutionSlippage(amountOut);\n\n        return\n            _calculateInputAmount(\n                amountOutBeforeSlippage,\n                rate,\n                inputToken.decimals(),\n                outputToken.decimals()\n            );\n    }\n\n    /**\n     * @notice Calculate output amount from input amount and rate\n     * @param amountIn The input amount\n     * @param rate The exchange rate (18 decimals)\n     * @param inputDecimals The input token decimals\n     * @param outputDecimals The output token decimals\n     * @return outputAmount The calculated output amount\n     */\n    function _calculateOutputAmount(\n        uint256 amountIn,\n        uint256 rate,\n        uint8 inputDecimals,\n        uint8 outputDecimals\n    ) internal pure returns (uint256 outputAmount) {\n        // Convert input to 18 decimals for calculation\n        uint256 normalizedInput = amountIn;\n        if (inputDecimals < 18) {\n            normalizedInput = amountIn * (10 ** (18 - inputDecimals));\n        } else if (inputDecimals > 18) {\n            normalizedInput = amountIn / (10 ** (inputDecimals - 18));\n        }\n\n        // Calculate output in 18 decimals: input * rate / 1e18\n        uint256 normalizedOutput = (normalizedInput * rate) / 1e18;\n\n        // Convert output to token decimals\n        if (outputDecimals < 18) {\n            outputAmount = normalizedOutput / (10 ** (18 - outputDecimals));\n        } else if (outputDecimals > 18) {\n            outputAmount = normalizedOutput * (10 ** (outputDecimals - 18));\n        } else {\n            outputAmount = normalizedOutput;\n        }\n\n        return outputAmount;\n    }\n\n    /**\n     * @notice Calculate input amount from output amount and rate\n     * @param amountOut The output amount\n     * @param rate The exchange rate (18 decimals)\n     * @param inputDecimals The input token decimals\n     * @param outputDecimals The output token decimals\n     * @return inputAmount The calculated input amount\n     */\n    function _calculateInputAmount(\n        uint256 amountOut,\n        uint256 rate,\n        uint8 inputDecimals,\n        uint8 outputDecimals\n    ) internal pure returns (uint256 inputAmount) {\n        // Convert output to 18 decimals for calculation\n        uint256 normalizedOutput = amountOut;\n        if (outputDecimals < 18) {\n            normalizedOutput = amountOut * (10 ** (18 - outputDecimals));\n        } else if (outputDecimals > 18) {\n            normalizedOutput = amountOut / (10 ** (outputDecimals - 18));\n        }\n\n        // Calculate input in 18 decimals: output * 1e18 / rate\n        uint256 normalizedInput = (normalizedOutput * 1e18) / rate;\n\n        // Convert input to token decimals\n        if (inputDecimals < 18) {\n            inputAmount = normalizedInput / (10 ** (18 - inputDecimals));\n        } else if (inputDecimals > 18) {\n            inputAmount = normalizedInput * (10 ** (inputDecimals - 18));\n        } else {\n            inputAmount = normalizedInput;\n        }\n\n        return inputAmount;\n    }\n\n    /**\n     * @notice Apply execution slippage to reduce output amount\n     * @param amount The original amount\n     * @return slippedAmount The amount after applying execution slippage\n     */\n    function _applyExecutionSlippage(\n        uint256 amount\n    ) internal view returns (uint256 slippedAmount) {\n        if (executionSlippageBps == 0) {\n            return amount;\n        }\n\n        // Reduce by execution slippage: amount * (100% - slippage%) / 100%\n        slippedAmount =\n            (amount *\n                (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS -\n                    executionSlippageBps)) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        return slippedAmount;\n    }\n\n    /**\n     * @notice Reverse execution slippage to calculate required amount before slippage\n     * @param targetAmount The target amount after slippage\n     * @return originalAmount The amount needed before slippage\n     */\n    function _reverseExecutionSlippage(\n        uint256 targetAmount\n    ) internal view returns (uint256 originalAmount) {\n        if (executionSlippageBps == 0) {\n            return targetAmount;\n        }\n\n        // Calculate original amount: targetAmount * 100% / (100% - slippage%)\n        originalAmount =\n            (targetAmount * BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n            (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS -\n                executionSlippageBps);\n\n        return originalAmount;\n    }\n\n    /**\n     * @notice Emergency function to withdraw tokens (for testing purposes)\n     * @param token The token to withdraw\n     * @param amount The amount to withdraw\n     * @param to The recipient address\n     */\n    function emergencyWithdraw(\n        IERC20 token,\n        uint256 amount,\n        address to\n    ) external {\n        if (to == address(0)) {\n            revert ZeroAddress();\n        }\n        token.safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/testing/DPoolVaultLPMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../vaults/dpool/core/DPoolVaultLP.sol\";\n\n/**\n * @title DPoolVaultLPMock\n * @notice Minimal concrete implementation of DPoolVaultLP used exclusively for unit testing.\n *         It implements the abstract functions with simple stubs so that the core logic in\n *         DPoolVaultLP can be exercised without external dependencies (e.g., Curve pools).\n */\ncontract DPoolVaultLPMock is DPoolVaultLP {\n    /// @dev Dummy pool address, not used in tests\n    address private immutable _pool;\n\n    constructor(\n        address lpToken\n    ) DPoolVaultLP(lpToken, \"Mock DPool Vault\", \"mDPVL\", msg.sender) {\n        _pool = address(0);\n    }\n\n    // --- Abstract overrides ---\n\n    function pool() external view override returns (address) {\n        return _pool;\n    }\n\n    function previewLPValue(\n        uint256 lpAmount\n    ) external view override returns (uint256) {\n        // For testing purposes we simply return the same amount.\n        return lpAmount;\n    }\n}\n"
    },
    "contracts/testing/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title MockERC20\n * @dev Simple ERC20 token for testing purposes.\n */\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 initialSupply\n    ) ERC20(name_, symbol_) {\n        _mint(msg.sender, initialSupply);\n    }\n}\n"
    },
    "contracts/vaults/dloop/core/DLoopCoreBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {BasisPointConstants} from \"contracts/common/BasisPointConstants.sol\";\nimport {ERC4626, ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {Erc20Helper} from \"contracts/common/Erc20Helper.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {RescuableVault} from \"contracts/common/RescuableVault.sol\";\n\n/**\n * @title DLoopCoreBase\n * @dev A contract that executes leveraged operations on a lending pool using a collateral token and a debt token\n *      - A leveraged position is created by supplying a collateral token to the lending pool and borrowing a debt token\n *      - The leverage ratio will be changed if the collateral and debt values are changed (due to price changes)\n *      - The leverage can be increased by supplying more collateral token or decreasing the debt token\n *      - The leverage can be decreased by withdrawing collateral token or increasing the debt token\n *      - In order to keep the vault balanced, user can call increaseLeverage or decreaseLeverage to increase or decrease the leverage\n *        when it is away from the target leverage\n *      - There is a subsidy for the caller when increasing the leverage.\n */\nabstract contract DLoopCoreBase is\n    ERC4626,\n    Ownable,\n    ReentrancyGuard,\n    RescuableVault\n{\n    using SafeERC20 for ERC20;\n\n    /* Core state */\n\n    uint32 public lowerBoundTargetLeverageBps;\n    uint32 public upperBoundTargetLeverageBps;\n    uint256 public maxSubsidyBps;\n\n    /* Constants */\n\n    uint32 public immutable targetLeverageBps; // ie. 30000 = 300% in basis points, means 3x leverage\n    ERC20 public immutable collateralToken;\n    ERC20 public immutable debtToken;\n\n    uint256 public constant BALANCE_DIFF_TOLERANCE = 1;\n\n    /* Errors */\n\n    error TooImbalanced(\n        uint256 currentLeverageBps,\n        uint256 lowerBoundTargetLeverageBps,\n        uint256 upperBoundTargetLeverageBps\n    );\n    error InsufficientAllowanceOfDebtAssetToRepay(\n        address owner,\n        address spender,\n        address debtAsset,\n        uint256 requiredAllowance\n    );\n    error DepositInsufficientToSupply(\n        uint256 currentBalance,\n        uint256 newTotalAssets\n    );\n    error CollateralLessThanDebt(\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase\n    );\n    error InsufficientShareBalanceToRedeem(\n        address owner,\n        uint256 sharesToRedeem,\n        uint256 shareBalance\n    );\n    error WithdrawableIsLessThanRequired(\n        address token,\n        uint256 assetToRemoveFromLending,\n        uint256 withdrawableAmount\n    );\n    error DecreaseLeverageOutOfRange(\n        uint256 newLeverageBps,\n        uint256 targetLeverageBps, // lower bound\n        uint256 currentLeverageBps // upper bound\n    );\n    error IncreaseLeverageOutOfRange(\n        uint256 newLeverageBps,\n        uint256 targetLeverageBps, // upper bound\n        uint256 currentLeverageBps // lower bound\n    );\n    error TokenBalanceNotDecreasedAfterRepay(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedRepayAmountToPool(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error TokenBalanceNotDecreasedAfterSupply(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedSupplyAmountToPool(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error TokenBalanceNotIncreasedAfterBorrow(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedBorrowAmountFromPool(\n        address token,\n        uint256 borrowedAmountBefore,\n        uint256 borrowedAmountAfter,\n        uint256 expectedBorrowedAmount\n    );\n    error TokenBalanceNotIncreasedAfterWithdraw(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedWithdrawAmountFromPool(\n        address token,\n        uint256 withdrawableAmountBefore,\n        uint256 withdrawableAmountAfter,\n        uint256 expectedWithdrawableAmount\n    );\n    error InvalidLeverageBounds(\n        uint256 lowerBound,\n        uint256 targetLeverage,\n        uint256 upperBound\n    );\n    error AssetPriceIsZero(address asset);\n    error LeverageExceedsTarget(\n        uint256 currentLeverageBps,\n        uint256 targetLeverageBps\n    );\n    error LeverageBelowTarget(\n        uint256 currentLeverageBps,\n        uint256 targetLeverageBps\n    );\n    error RebalanceReceiveLessThanMinAmount(\n        string operation,\n        uint256 receivedAmount,\n        uint256 minReceivedAmount\n    );\n    error InvalidLeverage(uint256 leverageBps);\n    error TotalCollateralBaseIsZero();\n    error TotalCollateralBaseIsLessThanTotalDebtBase(\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase\n    );\n\n    /**\n     * @dev Constructor for the DLoopCore contract\n     * @param _name Name of the vault token\n     * @param _symbol Symbol of the vault token\n     * @param _collateralToken Address of the collateral token\n     * @param _debtToken Address of the debt token\n     * @param _targetLeverageBps Target leverage in basis points\n     * @param _lowerBoundTargetLeverageBps Lower bound of target leverage in basis points\n     * @param _upperBoundTargetLeverageBps Upper bound of target leverage in basis points\n     * @param _maxSubsidyBps Maximum subsidy in basis points\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        ERC20 _collateralToken,\n        ERC20 _debtToken,\n        uint32 _targetLeverageBps,\n        uint32 _lowerBoundTargetLeverageBps,\n        uint32 _upperBoundTargetLeverageBps,\n        uint256 _maxSubsidyBps\n    ) ERC20(_name, _symbol) ERC4626(_collateralToken) Ownable(msg.sender) {\n        debtToken = _debtToken;\n        collateralToken = _collateralToken;\n\n        if (_targetLeverageBps < BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert(\"Target leverage must be at least 100% in basis points\");\n        }\n\n        if (\n            _lowerBoundTargetLeverageBps >= _targetLeverageBps ||\n            _targetLeverageBps >= _upperBoundTargetLeverageBps\n        ) {\n            revert InvalidLeverageBounds(\n                _lowerBoundTargetLeverageBps,\n                _targetLeverageBps,\n                _upperBoundTargetLeverageBps\n            );\n        }\n\n        // Make sure collateral token is ERC-20\n        if (!Erc20Helper.isERC20(address(_collateralToken))) {\n            revert(\"Collateral token must be an ERC-20\");\n        }\n\n        // Make sure debt token is ERC-20\n        if (!Erc20Helper.isERC20(address(_debtToken))) {\n            revert(\"Debt token must be an ERC-20\");\n        }\n\n        targetLeverageBps = _targetLeverageBps;\n        lowerBoundTargetLeverageBps = _lowerBoundTargetLeverageBps;\n        upperBoundTargetLeverageBps = _upperBoundTargetLeverageBps;\n        maxSubsidyBps = _maxSubsidyBps;\n    }\n\n    /* Virtual Methods - Required to be implemented by derived contracts */\n\n    /**\n     * @dev Gets the total collateral and debt of a user in base currency\n     * @param user Address of the user\n     * @return totalCollateralBase Total collateral in base currency\n     * @return totalDebtBase Total debt in base currency\n     */\n    function getTotalCollateralAndDebtOfUserInBase(\n        address user\n    )\n        public\n        view\n        virtual\n        returns (uint256 totalCollateralBase, uint256 totalDebtBase);\n\n    /**\n     * @dev Gets the additional rescue tokens\n     *      - As the getRestrictedRescueTokens function is very critical and we do not\n     *        want to override it in the derived contracts, we use this function to\n     *        get the additional rescue tokens\n     * @return address[] Additional rescue tokens\n     */\n    function _getAdditionalRescueTokensImplementation()\n        internal\n        view\n        virtual\n        returns (address[] memory);\n\n    /**\n     * @dev Gets the asset price from the oracle\n     * @param asset Address of the asset\n     * @return uint256 Price of the asset\n     */\n    function _getAssetPriceFromOracleImplementation(\n        address asset\n    ) internal view virtual returns (uint256);\n\n    /**\n     * @dev Supply tokens to the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to supply\n     * @param onBehalfOf Address to supply on behalf of\n     */\n    function _supplyToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal virtual;\n\n    /**\n     * @dev Borrow tokens from the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to borrow\n     * @param onBehalfOf Address to borrow on behalf of\n     */\n    function _borrowFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal virtual;\n\n    /**\n     * @dev Repay debt to the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to repay\n     * @param onBehalfOf Address to repay on behalf of\n     */\n    function _repayDebtToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal virtual;\n\n    /**\n     * @dev Withdraw tokens from the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to withdraw\n     * @param onBehalfOf Address to withdraw on behalf of\n     */\n    function _withdrawFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal virtual;\n\n    /* Wrapper Functions */\n\n    /**\n     * @dev Supply tokens to the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to supply\n     * @param onBehalfOf Address to supply on behalf of\n     */\n    function _supplyToPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal {\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeSupply = ERC20(token).balanceOf(onBehalfOf);\n\n        _supplyToPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterSupply = ERC20(token).balanceOf(onBehalfOf);\n        if (tokenBalanceAfterSupply >= tokenBalanceBeforeSupply) {\n            revert TokenBalanceNotDecreasedAfterSupply(\n                token,\n                tokenBalanceBeforeSupply,\n                tokenBalanceAfterSupply,\n                amount\n            );\n        }\n\n        // Now, as balance before must be greater than balance after, we can just check if the difference is the expected amount\n        if (tokenBalanceBeforeSupply - tokenBalanceAfterSupply != amount) {\n            revert UnexpectedSupplyAmountToPool(\n                token,\n                tokenBalanceBeforeSupply,\n                tokenBalanceAfterSupply,\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Borrow tokens from the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to borrow\n     * @param onBehalfOf Address to borrow on behalf of\n     */\n    function _borrowFromPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal {\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeBorrow = ERC20(token).balanceOf(onBehalfOf);\n\n        _borrowFromPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterBorrow = ERC20(token).balanceOf(onBehalfOf);\n        if (tokenBalanceAfterBorrow <= tokenBalanceBeforeBorrow) {\n            revert TokenBalanceNotIncreasedAfterBorrow(\n                token,\n                tokenBalanceBeforeBorrow,\n                tokenBalanceAfterBorrow,\n                amount\n            );\n        }\n\n        // Allow a 1-wei rounding tolerance when comparing the observed balance change with `amount`\n        uint256 observedDiffBorrow = tokenBalanceAfterBorrow -\n            tokenBalanceBeforeBorrow;\n        if (observedDiffBorrow > amount) {\n            if (observedDiffBorrow - amount > BALANCE_DIFF_TOLERANCE) {\n                revert UnexpectedBorrowAmountFromPool(\n                    token,\n                    tokenBalanceBeforeBorrow,\n                    tokenBalanceAfterBorrow,\n                    amount\n                );\n            }\n        } else {\n            if (amount - observedDiffBorrow > BALANCE_DIFF_TOLERANCE) {\n                revert UnexpectedBorrowAmountFromPool(\n                    token,\n                    tokenBalanceBeforeBorrow,\n                    tokenBalanceAfterBorrow,\n                    amount\n                );\n            }\n        }\n\n        // Now, as balance before must be less than balance after, we can just check if the difference is the expected amount\n        // NOTE: A second strict equality comparison is no longer necessary.\n        // The tolerance enforcement performed above (BALANCE_DIFF_TOLERANCE)\n        // already guarantees that any rounding variance is within an\n        // acceptable 1-wei window, so we purposefully avoid reverting here.\n    }\n\n    /**\n     * @dev Repay debt to the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to repay\n     * @param onBehalfOf Address to repay on behalf of\n     */\n    function _repayDebtToPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal {\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeRepay = ERC20(token).balanceOf(onBehalfOf);\n\n        _repayDebtToPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterRepay = ERC20(token).balanceOf(onBehalfOf);\n\n        // Ensure the balance actually decreased\n        if (tokenBalanceAfterRepay >= tokenBalanceBeforeRepay) {\n            revert TokenBalanceNotDecreasedAfterRepay(\n                token,\n                tokenBalanceBeforeRepay,\n                tokenBalanceAfterRepay,\n                amount\n            );\n        }\n\n        // Now, allow a 1-wei rounding tolerance on the observed balance decrease.\n        uint256 observedDiffRepay = tokenBalanceBeforeRepay -\n            tokenBalanceAfterRepay;\n        if (observedDiffRepay > amount) {\n            if (observedDiffRepay - amount > BALANCE_DIFF_TOLERANCE) {\n                revert UnexpectedRepayAmountToPool(\n                    token,\n                    tokenBalanceBeforeRepay,\n                    tokenBalanceAfterRepay,\n                    amount\n                );\n            }\n        } else {\n            if (amount - observedDiffRepay > BALANCE_DIFF_TOLERANCE) {\n                revert UnexpectedRepayAmountToPool(\n                    token,\n                    tokenBalanceBeforeRepay,\n                    tokenBalanceAfterRepay,\n                    amount\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens from the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to withdraw\n     * @param onBehalfOf Address to withdraw on behalf of\n     */\n    function _withdrawFromPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal {\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeWithdraw = ERC20(token).balanceOf(onBehalfOf);\n\n        _withdrawFromPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterWithdraw = ERC20(token).balanceOf(onBehalfOf);\n\n        // Ensure the balance actually increased\n        if (tokenBalanceAfterWithdraw <= tokenBalanceBeforeWithdraw) {\n            revert TokenBalanceNotIncreasedAfterWithdraw(\n                token,\n                tokenBalanceBeforeWithdraw,\n                tokenBalanceAfterWithdraw,\n                amount\n            );\n        }\n\n        // Allow a 1-wei rounding tolerance on the observed balance increase\n        uint256 observedDiffWithdraw = tokenBalanceAfterWithdraw -\n            tokenBalanceBeforeWithdraw;\n        if (observedDiffWithdraw > amount) {\n            if (observedDiffWithdraw - amount > BALANCE_DIFF_TOLERANCE) {\n                revert UnexpectedWithdrawAmountFromPool(\n                    token,\n                    tokenBalanceBeforeWithdraw,\n                    tokenBalanceAfterWithdraw,\n                    amount\n                );\n            }\n        } else {\n            if (amount - observedDiffWithdraw > BALANCE_DIFF_TOLERANCE) {\n                revert UnexpectedWithdrawAmountFromPool(\n                    token,\n                    tokenBalanceBeforeWithdraw,\n                    tokenBalanceAfterWithdraw,\n                    amount\n                );\n            }\n        }\n    }\n\n    /* Safety */\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return address[] Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens()\n        public\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        // Get the additional rescue tokens from the derived contract\n        address[]\n            memory additionalRescueTokens = _getAdditionalRescueTokensImplementation();\n\n        // Restrict the rescue tokens to the collateral token and the debt token\n        // as they are going to be used to compensate subsidies during the rebalance\n        address[] memory restrictedRescueTokens = new address[](\n            2 + additionalRescueTokens.length\n        );\n        restrictedRescueTokens[0] = address(collateralToken);\n        restrictedRescueTokens[1] = address(debtToken);\n\n        // Concatenate the restricted rescue tokens and the additional rescue tokens\n        for (uint256 i = 0; i < additionalRescueTokens.length; i++) {\n            restrictedRescueTokens[2 + i] = additionalRescueTokens[i];\n        }\n        return restrictedRescueTokens;\n    }\n\n    /* Helper Functions */\n\n    /**\n     * @dev Calculates the leveraged amount of the assets\n     * @param assets Amount of assets\n     * @return leveragedAssets Amount of leveraged assets\n     */\n    function getLeveragedAssets(uint256 assets) public view returns (uint256) {\n        return\n            (assets * targetLeverageBps) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n    }\n\n    /**\n     * @dev Calculates the unleveraged amount of the assets\n     * @param leveragedAssets Amount of leveraged assets\n     * @return unleveragedAssets Amount of unleveraged assets\n     */\n    function getUnleveragedAssets(\n        uint256 leveragedAssets\n    ) public view returns (uint256) {\n        return\n            (leveragedAssets * BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n            targetLeverageBps;\n    }\n\n    /**\n     * @dev Gets the asset price from the oracle\n     * @param asset Address of the asset\n     * @return uint256 Price of the asset\n     */\n    function getAssetPriceFromOracle(\n        address asset\n    ) public view returns (uint256) {\n        uint256 assetPrice = _getAssetPriceFromOracleImplementation(asset);\n\n        // Sanity check\n        if (assetPrice == 0) {\n            revert AssetPriceIsZero(asset);\n        }\n\n        return assetPrice;\n    }\n\n    /**\n     * @dev Converts an amount in base currency to the actual amount in the token\n     * @param amountInBase Amount in base currency\n     * @param token Address of the token\n     * @return amountInToken Amount in the token\n     */\n    function convertFromBaseCurrencyToToken(\n        uint256 amountInBase,\n        address token\n    ) public view returns (uint256) {\n        // The price decimals is cancelled out in the division (as the amount and price are in the same unit)\n        uint256 tokenPriceInBase = getAssetPriceFromOracle(token);\n        return\n            (amountInBase * 10 ** ERC20(token).decimals()) / tokenPriceInBase;\n    }\n\n    /**\n     * @dev Converts an amount in the token to the actual amount in base currency\n     * @param amountInToken Amount in the token\n     * @param token Address of the token\n     * @return amountInBase Amount in base currency\n     */\n    function convertFromTokenAmountToBaseCurrency(\n        uint256 amountInToken,\n        address token\n    ) public view returns (uint256) {\n        // The token decimals is cancelled out in the division (as the amount and price are in the same unit)\n        uint256 tokenPriceInBase = getAssetPriceFromOracle(token);\n        return\n            (amountInToken * tokenPriceInBase) / 10 ** ERC20(token).decimals();\n    }\n\n    /**\n     * @dev Override of totalAssets from ERC4626\n     * @return uint256 Total assets in the vault\n     */\n    function totalAssets() public view virtual override returns (uint256) {\n        // We override this function to return the total assets in the vault\n        // with respect to the position in the lending pool\n        // The dLend interest will be distributed to the dToken\n        (uint256 totalCollateralBase, ) = getTotalCollateralAndDebtOfUserInBase(\n            address(this)\n        );\n        // The price decimals is cancelled out in the division (as the amount and price are in the same unit)\n        return\n            convertFromBaseCurrencyToToken(\n                totalCollateralBase,\n                address(collateralToken)\n            );\n    }\n\n    /* Safety */\n\n    /**\n     * @dev Returns whether the current leverage is too imbalanced\n     * @return bool True if leverage is too imbalanced, false otherwise\n     */\n    function isTooImbalanced() public view returns (bool) {\n        uint256 currentLeverageBps = getCurrentLeverageBps();\n        // If there is no deposit yet, we don't need to rebalance, thus it is not too imbalanced\n        return\n            currentLeverageBps != 0 &&\n            (currentLeverageBps < lowerBoundTargetLeverageBps ||\n                currentLeverageBps > upperBoundTargetLeverageBps);\n    }\n\n    /* Deposit and Mint */\n\n    /**\n     * @dev Deposits assets into the vault\n     *      - It will send the borrowed debt token and the minted shares to the receiver\n     *      - The minted shares represent the position of the supplied collateral assets in the lending pool\n     * @param caller Address of the caller\n     * @param receiver Address to receive the minted shares\n     * @param assets Amount of assets to deposit\n     * @param shares Amount of shares to mint\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal override nonReentrant {\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - The current collateral token balance is 0 WETH\n         * - The current debt token balance is 0 dUSD\n         * - The current shares supply is 0\n         * - Assume that the price of WETH is 2000 dUSD\n         *\n         * 1. User deposits 300 WETH\n         * 2. The vault supplies 300 WETH to the lending pool\n         * 3. The vault borrows 400,000 dUSD (300 * 2000 * 66.6666666%) from the lending pool\n         *    - 66.666% is to keep the target leverage 3x\n         * 4. The vault sends 400,000 dUSD to the receiver\n         * 5. The vault mints 300 shares to the user (representing 300 WETH position in the lending pool)\n         *\n         * The current leverage is: (300 * 2000) / (300 * 2000 - 400,000) = 3x\n         */\n\n        // Make sure the current leverage is within the target range\n        if (isTooImbalanced()) {\n            revert TooImbalanced(\n                getCurrentLeverageBps(),\n                lowerBoundTargetLeverageBps,\n                upperBoundTargetLeverageBps\n            );\n        }\n\n        uint256 debtAssetBorrowed = _depositToPoolImplementation(\n            caller,\n            assets\n        );\n\n        // Transfer the debt asset to the receiver\n        debtToken.safeTransfer(receiver, debtAssetBorrowed);\n\n        // Mint the vault's shares to the depositor\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Handles the logic of supplying collateral token and borrowing debt token\n     * @param caller Address of the caller\n     * @param supplyAssetAmount Amount of assets to supply\n     * @return debtAssetAmountToBorrow Amount of debt asset to borrow\n     */\n    function _depositToPoolImplementation(\n        address caller,\n        uint256 supplyAssetAmount // supply amount\n    ) private returns (uint256) {\n        // Transfer the assets to the vault (need the allowance before calling this function)\n        collateralToken.safeTransferFrom(\n            caller,\n            address(this),\n            supplyAssetAmount\n        );\n\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        // Get current leverage before supplying (IMPORTANT: this is the leverage before supplying)\n        uint256 currentLeverageBpsBeforeSupply = getCurrentLeverageBps();\n\n        // Make sure we have enough balance to supply before supplying\n        uint256 currentCollateralTokenBalance = collateralToken.balanceOf(\n            address(this)\n        );\n        if (currentCollateralTokenBalance < supplyAssetAmount) {\n            revert DepositInsufficientToSupply(\n                currentCollateralTokenBalance,\n                supplyAssetAmount\n            );\n        }\n\n        // Supply the collateral token to the lending pool\n        _supplyToPool(\n            address(collateralToken),\n            supplyAssetAmount,\n            address(this)\n        );\n\n        // Get the amount of debt token to borrow that keeps the current leverage\n        // If there is no deposit yet (leverage=0), we use the target leverage\n        uint256 debtTokenAmountToBorrow = getBorrowAmountThatKeepCurrentLeverage(\n                address(collateralToken),\n                address(debtToken),\n                supplyAssetAmount,\n                currentLeverageBpsBeforeSupply > 0\n                    ? currentLeverageBpsBeforeSupply\n                    : targetLeverageBps\n            );\n\n        // Borrow the max amount of debt token\n        _borrowFromPool(\n            address(debtToken),\n            debtTokenAmountToBorrow,\n            address(this)\n        );\n\n        return debtTokenAmountToBorrow;\n    }\n\n    /* Withdraw and Redeem */\n\n    /**\n     * @dev Withdraws collateral assets from the vault\n     *      - It requires to spend the debt token to repay the debt\n     *      - It will send the withdrawn collateral assets to the receiver and burn the shares\n     *      - The burned shares represent the position of the withdrawn assets in the lending pool\n     * @param caller Address of the caller\n     * @param receiver Address to receive the withdrawn assets\n     * @param owner Address of the owner\n     * @param assets Amount of assets to remove from the lending pool\n     * @param shares Amount of shares to burn\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal override nonReentrant {\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - The current shares supply is 300\n         * - The current leverage is 3x\n         * - The current collateral token balance is 300 WETH\n         * - The current debt token balance is 400,000 dUSD (300 * 2000 * 66.6666666%)\n         * - Assume that the price of WETH is 2000 dUSD\n         *\n         * 1. User has 100 shares\n         * 2. User wants to withdraw 100 WETH\n         * 3. The vault burns 100 shares\n         * 4. The vault transfers 133,333 dUSD (100 * 2000 * 66.6666666%) from the user to the vault\n         *    - 66.6666% is to keep the target leverage 3x\n         * 5. The vault repays 133,333 dUSD to the lending pool\n         *    - The debt is now 266,667 dUSD (400,000 - 133,333)\n         * 6. The vault withdraws 100 WETH from the lending pool\n         *    - The collateral is now 200 WETH (300 - 100)\n         * 7. The vault sends 100 WETH to the receiver\n         *\n         * The current leverage is: (200 * 2000) / (200 * 2000 - 266,667) = 3x\n         */\n\n        // Note that we need the allowance before calling this function\n        // - Allowance for the message sender to spend the shares on behalf of the owner\n        // - Allowance for the vault to burn the shares\n\n        // If the owner is not the caller, then we need to spend the allowance\n        // so that the caller can spend the shares on behalf of the owner\n        if (owner != caller) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // Check user's balance before burning shares\n        uint256 userShares = balanceOf(owner);\n        if (userShares < shares) {\n            revert InsufficientShareBalanceToRedeem(owner, shares, userShares);\n        }\n\n        // Burn the shares\n        _burn(owner, shares);\n\n        // Make sure the current leverage is within the target range\n        if (isTooImbalanced()) {\n            revert TooImbalanced(\n                getCurrentLeverageBps(),\n                lowerBoundTargetLeverageBps,\n                upperBoundTargetLeverageBps\n            );\n        }\n\n        // Withdraw the collateral from the lending pool\n        // After this step, the _withdrawFromPool wrapper function will also assert that\n        // the withdrawn amount is exactly the amount requested.\n        _withdrawFromPoolImplementation(caller, assets);\n\n        // Transfer the asset to the receiver\n        collateralToken.safeTransfer(receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @dev Handles the logic for repaying debt and withdrawing collateral from the pool\n     *      - It calculates the required debt token to repay to keep the current leverage\n     *        given the expected withdraw amount\n     *      - Then performs the actual repay and withdraw\n     * @param caller Address of the caller\n     * @param collateralTokenToWithdraw The amount of collateral token to withdraw\n     * @return repaidDebtTokenAmount The amount of debt token repaid\n     */\n    function _withdrawFromPoolImplementation(\n        address caller,\n        uint256 collateralTokenToWithdraw\n    ) private returns (uint256 repaidDebtTokenAmount) {\n        // Get the current leverage before repaying the debt (IMPORTANT: this is the leverage before repaying the debt)\n        // It is used to calculate the expected withdrawable amount that keeps the current leverage\n        uint256 leverageBpsBeforeRepayDebt = getCurrentLeverageBps();\n\n        repaidDebtTokenAmount = getRepayAmountThatKeepCurrentLeverage(\n            address(collateralToken),\n            address(debtToken),\n            collateralTokenToWithdraw,\n            leverageBpsBeforeRepayDebt\n        );\n\n        // If don't have enough allowance, revert with the error message\n        // This is to early-revert with instruction in the error message\n        if (\n            debtToken.allowance(caller, address(this)) < repaidDebtTokenAmount\n        ) {\n            revert InsufficientAllowanceOfDebtAssetToRepay(\n                caller,\n                address(this),\n                address(debtToken),\n                repaidDebtTokenAmount\n            );\n        }\n\n        // Transfer the debt token to the vault to repay the debt\n        debtToken.safeTransferFrom(\n            caller,\n            address(this),\n            repaidDebtTokenAmount\n        );\n\n        // Repay the debt to withdraw the collateral\n        _repayDebtToPool(\n            address(debtToken),\n            repaidDebtTokenAmount,\n            address(this)\n        );\n\n        // Withdraw the collateral\n        // At this step, the _withdrawFromPool wrapper function will also assert that\n        // the withdrawn amount is exactly the amount requested.\n        _withdrawFromPool(\n            address(collateralToken),\n            collateralTokenToWithdraw,\n            address(this)\n        );\n\n        return repaidDebtTokenAmount;\n    }\n\n    /* Calculate */\n\n    function getRepayAmountThatKeepCurrentLeverage(\n        address collateralAsset,\n        address debtAsset,\n        uint256 targetWithdrawAmount,\n        uint256 leverageBpsBeforeRepayDebt\n    ) public view returns (uint256 repayAmount) {\n        /* Formula definition:\n         * - C1: totalCollateralBase before repay (in base currency)\n         * - D1: totalDebtBase before repay (in base currency)\n         * - C2: totalCollateralBase after repay (in base currency)\n         * - D2: totalDebtBase after repay (in base currency)\n         * - T: target leverage\n         * - x: withdraw amount in base currency\n         * - y: repay amount in base currency\n         *\n         * We have:\n         *        C1 / (C1-D1) = C2 / (C2-D2)\n         *        C2 = C1-x\n         *        D2 = D1-y\n         *        C1 / (C1-D1) = T <=> C1 = (C1-D1) * T <=> C1 = C1*T - D1*T <=> C1*T - C1 = D1*T <=> C1 = D1*T/(T-1)\n         *\n         * Formula expression:\n         *        C1 / (C1-D1) = (C1-x) / (C1-x-D1+y)\n         *    <=> C1 * (C1-x-D1+y) = (C1-x) * (C1-D1)\n         *    <=> C1^2 - C1*x - C1*D1 + C1*y = C1^2 - C1*D1 - C1*x + D1*x\n         *    <=> C1^2 - C1*x - C1*D1 + C1*y = C1^2 - C1*x - C1*D1 + D1*x\n         *    <=> C1*y = x*D1\n         *    <=> y = x*D1 / C1\n         *    <=> y = x*D1 / [D1*T / (T-1)]\n         *    <=> y = x * (T-1)/T\n         *\n         * Suppose that T' = T * ONE_HUNDRED_PERCENT_BPS, then:\n         *\n         *  => T = T' / ONE_HUNDRED_PERCENT_BPS\n         * where T' is the target leverage in basis points unit\n         *\n         * We have:\n         *      y = x * (T-1)/T\n         *  <=> y = x * (T' / ONE_HUNDRED_PERCENT_BPS - 1) / (T' / ONE_HUNDRED_PERCENT_BPS)\n         *  <=> y = x * (T' - ONE_HUNDRED_PERCENT_BPS) / T'\n         */\n\n        // Convert the target withdraw amount to base\n        uint256 targetWithdrawAmountInBase = convertFromTokenAmountToBaseCurrency(\n                targetWithdrawAmount,\n                collateralAsset\n            );\n\n        // Calculate the repay amount in base\n        uint256 repayAmountInBase = (targetWithdrawAmountInBase *\n            (leverageBpsBeforeRepayDebt -\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS)) /\n            leverageBpsBeforeRepayDebt;\n\n        return convertFromBaseCurrencyToToken(repayAmountInBase, debtAsset);\n    }\n\n    /**\n     * @dev Gets the borrow amount that keeps the current leverage\n     * @param collateralAsset The collateral asset\n     * @param debtAsset The debt asset\n     * @param suppliedCollateralAmount The actual supplied amount of collateral asset\n     * @param leverageBpsBeforeSupply Leverage in basis points before supplying\n     * @return expectedBorrowAmount The expected borrow amount that keeps the current leverage\n     */\n    function getBorrowAmountThatKeepCurrentLeverage(\n        address collateralAsset,\n        address debtAsset,\n        uint256 suppliedCollateralAmount,\n        uint256 leverageBpsBeforeSupply\n    ) public view returns (uint256 expectedBorrowAmount) {\n        /* Formula definition:\n         * - C1: totalCollateralBase before supply (in base currency)\n         * - D1: totalDebtBase before supply (in base currency)\n         * - C2: totalCollateralBase after supply (in base currency)\n         * - D2: totalDebtBase after supply (in base currency)\n         * - T: target leverage\n         * - x: supply amount in base currency\n         * - y: borrow amount in base currency\n         *\n         * We have:\n         *      C1 / (C1-D1) = C2 / (C2-D2)\n         *      C2 = C1+x\n         *      D2 = D1+y\n         *      C1 / (C1-D1) = T <=> C1 = (C1-D1) * T <=> C1 = C1*T - D1*T <=> C1*T - C1 = D1*T <=> C1 = D1*T/(T-1)\n         *\n         * Formula expression:\n         *      C1 / (C1-D1) = (C1+x) / (C1+x-D1-y)\n         *  <=> C1 * (C1+x-D1-y) = (C1+x) * (C1-D1)\n         *  <=> C1^2 + C1*x - C1*D1 - C1*y = C1^2 - C1*D1 + C1*x - D1*x\n         *  <=> C1*y = x*D1\n         *  <=> y = x*D1 / C1\n         *  <=> y = x * (T-1)/T\n         *\n         * Suppose that:\n         *      T' = T * ONE_HUNDRED_PERCENT_BPS, then:\n         *   => T = T' / ONE_HUNDRED_PERCENT_BPS\n         * where:\n         *      - T' is the target leverage in basis points unit\n         *\n         * This is the formula to calculate the borrow amount that keeps the current leverage:\n         *      y = x * (T-1)/T\n         *  <=> y = x * (T' / ONE_HUNDRED_PERCENT_BPS - 1) / (T' / ONE_HUNDRED_PERCENT_BPS)\n         *  <=> y = x * (T' - ONE_HUNDRED_PERCENT_BPS) / T'\n         */\n\n        // Convert the actual supplied amount to base\n        uint256 suppliedCollateralAmountInBase = convertFromTokenAmountToBaseCurrency(\n                suppliedCollateralAmount,\n                collateralAsset\n            );\n\n        // Calculate the borrow amount in base currency that keeps the current leverage\n        uint256 borrowAmountInBase = (suppliedCollateralAmountInBase *\n            (leverageBpsBeforeSupply -\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS)) /\n            leverageBpsBeforeSupply;\n\n        return convertFromBaseCurrencyToToken(borrowAmountInBase, debtAsset);\n    }\n\n    /* Rebalance */\n\n    /**\n     * @dev Gets the collateral token amount to reach the target leverage\n     *      - This method is only being called for increasing the leverage quote in getAmountToReachTargetLeverage()\n     * @param expectedTargetLeverageBps The expected target leverage in basis points unit\n     * @param totalCollateralBase The total collateral base\n     * @param totalDebtBase The total debt base\n     * @param subsidyBps The subsidy in basis points unit\n     * @param useVaultTokenBalance Whether to use the current token balance in the vault as the amount to rebalance\n     * @return collateralTokenAmount The collateral token amount to reach the target leverage\n     */\n    function _getCollateralTokenAmountToReachTargetLeverage(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 subsidyBps,\n        bool useVaultTokenBalance\n    ) internal view returns (uint256) {\n        /**\n         * The formula is at getAmountToReachTargetLeverage()\n         *\n         * Calculate the amount of collateral token to supply\n         * The original formula is:\n         *      x = (T'*(C - D) - C*ONE_HUNDRED_PERCENT_BPS) * ONE_HUNDRED_PERCENT_BPS / (ONE_HUNDRED_PERCENT_BPS^2 + T' * k')\n         *\n         * However, the calculation of ONE_HUNDRED_PERCENT_BPS^2 causes arithmetic overflow,\n         * so we need to simplify the formula to avoid the overflow.\n         *\n         * So, the transformed formula is:\n         *      x = (T'*(C - D) - C*ONE_HUNDRED_PERCENT_BPS) / (ONE_HUNDRED_PERCENT_BPS + T' * k' / ONE_HUNDRED_PERCENT_BPS)\n         */\n        if (totalCollateralBase == 0) {\n            revert TotalCollateralBaseIsZero();\n        }\n        if (totalCollateralBase < totalDebtBase) {\n            revert TotalCollateralBaseIsLessThanTotalDebtBase(\n                totalCollateralBase,\n                totalDebtBase\n            );\n        }\n\n        uint256 requiredCollateralTokenAmountInBase = (expectedTargetLeverageBps *\n                (totalCollateralBase - totalDebtBase) -\n                totalCollateralBase *\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n                (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS +\n                    ((expectedTargetLeverageBps * subsidyBps) /\n                        BasisPointConstants.ONE_HUNDRED_PERCENT_BPS));\n\n        // Convert to token unit\n        uint256 requiredCollateralTokenAmount = convertFromBaseCurrencyToToken(\n            requiredCollateralTokenAmountInBase,\n            address(collateralToken)\n        );\n\n        if (useVaultTokenBalance) {\n            // Get the current collateral token balance in the vault to compensate the required collateral amount\n            // when increasing the leverage\n            uint256 collateralBalanceInVault = collateralToken.balanceOf(\n                address(this)\n            );\n\n            // If the required collateral token amount is more than the collateral balance in the vault,\n            // the caller need to call increaseLeverage with the additional collateral token amount\n            if (requiredCollateralTokenAmount > collateralBalanceInVault) {\n                return requiredCollateralTokenAmount - collateralBalanceInVault;\n            }\n\n            // Otherwise, it is a free lunch, the user call increaseLeverage without having to pay\n            // for the collateral token\n            return 0;\n        }\n\n        // Otherwise, the user can call increaseLeverage with the required collateral token amount\n        return requiredCollateralTokenAmount;\n    }\n\n    /**\n     * @dev Gets the debt token amount to reach the target leverage\n     *      - This method is only being called for decreasing the leverage quote in getAmountToReachTargetLeverage()\n     * @param expectedTargetLeverageBps The expected target leverage in basis points unit\n     * @param totalCollateralBase The total collateral base\n     * @param totalDebtBase The total debt base\n     * @param subsidyBps The subsidy in basis points unit\n     * @param useVaultTokenBalance Whether to use the current token balance in the vault as the amount to rebalance\n     * @return requiredDebtTokenAmount The debt token amount to reach the target leverage\n     */\n    function _getDebtTokenAmountToReachTargetLeverage(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 subsidyBps,\n        bool useVaultTokenBalance\n    ) internal view returns (uint256) {\n        /**\n         * The formula is at getAmountToReachTargetLeverage()\n         *\n         * Calculate the amount of debt token to repay\n         * The original formula is:\n         *      x = (C*ONE_HUNDRED_PERCENT_BPS - T'*(C - D)) * ONE_HUNDRED_PERCENT_BPS / (ONE_HUNDRED_PERCENT_BPS^2 + T' * k')\n         *\n         * However, the calculation of ONE_HUNDRED_PERCENT_BPS^2 causes arithmetic overflow,\n         * so we need to simplify the formula to avoid the overflow.\n         *\n         * So, the transformed formula is:\n         *      x = (C*ONE_HUNDRED_PERCENT_BPS - T'*(C - D)) / (ONE_HUNDRED_PERCENT_BPS + T' * k' / ONE_HUNDRED_PERCENT_BPS)\n         */\n        if (totalCollateralBase == 0) {\n            revert TotalCollateralBaseIsZero();\n        }\n        if (totalCollateralBase < totalDebtBase) {\n            revert TotalCollateralBaseIsLessThanTotalDebtBase(\n                totalCollateralBase,\n                totalDebtBase\n            );\n        }\n\n        uint256 requiredDebtTokenAmountInBase = (totalCollateralBase *\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS -\n            expectedTargetLeverageBps *\n            (totalCollateralBase - totalDebtBase)) /\n            (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS +\n                (expectedTargetLeverageBps * subsidyBps) /\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS);\n\n        // Convert to token unit\n        uint256 requiredDebtTokenAmount = convertFromBaseCurrencyToToken(\n            requiredDebtTokenAmountInBase,\n            address(debtToken)\n        );\n\n        if (useVaultTokenBalance) {\n            // Get the current debt token balance in the vault to compensate the required debt amount\n            uint256 debtTokenBalanceInVault = debtToken.balanceOf(\n                address(this)\n            );\n\n            // If the required debt token amount is more than the debt token balance in the vault,\n            // the caller need to call decreaseLeverage with the additional debt token amount\n            if (requiredDebtTokenAmount > debtTokenBalanceInVault) {\n                return requiredDebtTokenAmount - debtTokenBalanceInVault;\n            }\n\n            // Otherwise, it is a free lunch, the user call decreaseLeverage without having to pay\n            // for the debt token\n            return 0;\n        }\n\n        // Otherwise, the user can call decreaseLeverage with the required debt token amount\n        return requiredDebtTokenAmount;\n    }\n\n    /**\n     * @dev Gets the rebalance amount to reach the target leverage in token unit\n     *      - This method is supposed to be used by the rebalancing service which will use it to quote the required\n     *        collateral/debt amount and the corresponding direction (increase or decrease)\n     * @param useVaultTokenBalance Whether to use the current token balance in the vault as the amount to rebalance\n     *      - It will help to save the additional collateral/debt token transfer from the caller to the vault, while getting\n     *        the same effect as calling increaseLeverage or decreaseLeverage with the required collateral/debt token amount\n     * @return tokenAmount The amount of token to call increaseLeverage or decreaseLeverage (in token unit)\n     *         - If the direction is 1, the amount is in collateral token\n     *         - If the direction is -1, the amount is in debt token\n     * @return direction The direction of the rebalance (1 for increase, -1 for decrease, 0 means no rebalance)\n     */\n    function getAmountToReachTargetLeverage(\n        bool useVaultTokenBalance\n    ) public view returns (uint256 tokenAmount, int8 direction) {\n        /**\n         * Formula definition:\n         * - C: totalCollateralBase\n         * - D: totalDebtBase\n         * - T: target leverage\n         * - k: subsidy (0.01 means 1%)\n         * - x: change amount of collateral in base currency\n         * - y: change amount of debt in base currency\n         *\n         * We have:\n         *      y = x*(1+k)\n         *      (C + x) / (C + x - D - y) = T\n         *  <=> (C + x) / (C + x - D - x*(1+k)) = T\n         *  <=> (C + x) = T * (C + x - D - x*(1+k))\n         *  <=> C + x = T*C + T*x - T*D - T*x - T*x*k\n         *  <=> C + x = T*C - T*D - T*x*k\n         *  <=> x + T*x*k = T*C - T*D - C\n         *  <=> x*(1 + T*k) = T*C - T*D - C\n         *  <=> x = (T*(C - D) - C) / (1 + T*k)\n         *\n         * Suppose that:\n         *      T' = T * ONE_HUNDRED_PERCENT_BPS\n         *      k' = k * ONE_HUNDRED_PERCENT_BPS\n         * then:\n         *      T = T' / ONE_HUNDRED_PERCENT_BPS\n         *      k = k' / ONE_HUNDRED_PERCENT_BPS\n         * where:\n         *      - T' is the target leverage in basis points unit\n         *      - k' is the subsidy in basis points unit\n         *\n         * We have:\n         *      x = (T*(C - D) - C) / (1 + T*k)\n         *  <=> x = (T'*(C - D) / ONE_HUNDRED_PERCENT_BPS - C) / (1 + T'*k / ONE_HUNDRED_PERCENT_BPS)\n         *  <=> x = (T'*(C - D) - C*ONE_HUNDRED_PERCENT_BPS) / (ONE_HUNDRED_PERCENT_BPS + T'*k)\n         *  <=> x = (T'*(C - D) - C*ONE_HUNDRED_PERCENT_BPS) / (ONE_HUNDRED_PERCENT_BPS + T' * k' / ONE_HUNDRED_PERCENT_BPS)\n         *  <=> x = (T'*(C - D) - C*ONE_HUNDRED_PERCENT_BPS) * ONE_HUNDRED_PERCENT_BPS / (ONE_HUNDRED_PERCENT_BPS^2 + T' * k')\n         *\n         * If x > 0, it means the user should increase the leverage, so the direction is 1\n         *    => x = (T*(C - D) - C) / (1 + T*k)\n         *    => x = (T'*(C - D) - C*ONE_HUNDRED_PERCENT_BPS) * ONE_HUNDRED_PERCENT_BPS / (ONE_HUNDRED_PERCENT_BPS^2 + T' * k')\n         * If x < 0, it means the user should decrease the leverage, so the direction is -1\n         *    => x = (C - T*(C - D)) / (1 + T*k)\n         *    => x = (C*ONE_HUNDRED_PERCENT_BPS - T'*(C - D)) * ONE_HUNDRED_PERCENT_BPS / (ONE_HUNDRED_PERCENT_BPS^2 + T' * k')\n         * If x = 0, it means the user should not rebalance, so the direction is 0\n         */\n\n        uint256 currentLeverageBps = getCurrentLeverageBps();\n        uint256 subsidyBps = getCurrentSubsidyBps();\n        (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase\n        ) = getTotalCollateralAndDebtOfUserInBase(address(this));\n\n        if (totalCollateralBase == 0) {\n            // No collateral means no debt and no leverage, so no rebalance is needed\n            return (0, 0);\n        }\n\n        // If the current leverage is below the target leverage, the user should increase the leverage\n        if (currentLeverageBps < targetLeverageBps) {\n            return (\n                _getCollateralTokenAmountToReachTargetLeverage(\n                    targetLeverageBps,\n                    totalCollateralBase,\n                    totalDebtBase,\n                    subsidyBps,\n                    useVaultTokenBalance\n                ),\n                1\n            );\n        }\n        // If the current leverage is above the target leverage, the user should decrease the leverage\n        else if (currentLeverageBps > targetLeverageBps) {\n            return (\n                _getDebtTokenAmountToReachTargetLeverage(\n                    targetLeverageBps,\n                    totalCollateralBase,\n                    totalDebtBase,\n                    subsidyBps,\n                    useVaultTokenBalance\n                ),\n                -1\n            );\n        }\n\n        // If the current leverage is equal to the target leverage, the user should not rebalance\n        return (0, 0);\n    }\n\n    /**\n     * @dev Gets the required collateral token amount to reach the target leverage\n     * @param expectedTargetLeverageBps The expected target leverage in basis points unit\n     * @param totalCollateralBase The total collateral base\n     * @param totalDebtBase The total debt base\n     * @param subsidyBps The subsidy in basis points unit\n     * @param additionalCollateralTokenAmount The additional collateral token amount to supply\n     * @return requiredCollateralTokenAmount The required collateral token amount to reach the target leverage\n     */\n    function _getRequiredCollateralTokenAmountToRebalance(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 subsidyBps,\n        uint256 additionalCollateralTokenAmount\n    ) internal view returns (uint256 requiredCollateralTokenAmount) {\n        /* If the additional collateral token amount is 0, it means the expected collateral token amount to reach the target leverage\n         * can be less than or equal to the current collateral token balance in the vault\n         * Thus, we need to calculate the actual required collateral token amount to reach the target leverage\n         * and then use the current collateral token balance in the vault to supply\n         * - It is to avoid the situation where the current collateral token balance in the vault is too high\n         *   and thus cannot call increaseLeverage with this balance as it will increase the leverage above the target leverage\n         *\n         * This function is only being used internally\n         */\n        if (additionalCollateralTokenAmount == 0) {\n            return\n                _getCollateralTokenAmountToReachTargetLeverage(\n                    expectedTargetLeverageBps,\n                    totalCollateralBase,\n                    totalDebtBase,\n                    subsidyBps,\n                    false\n                );\n        }\n\n        // Otherwise, it means the expected collateral token amount to reach the target leverage\n        // is less than the current collateral token balance in the vault\n        uint256 collateralTokenBalanceInVault = collateralToken.balanceOf(\n            address(this)\n        );\n        return collateralTokenBalanceInVault + additionalCollateralTokenAmount;\n    }\n\n    /**\n     * @dev Gets the required debt token amount to reach the target leverage\n     * @param expectedTargetLeverageBps The expected target leverage in basis points unit\n     * @param totalCollateralBase The total collateral base\n     * @param totalDebtBase The total debt base\n     * @param subsidyBps The subsidy in basis points unit\n     * @param additionalDebtTokenAmount The additional debt token amount to repay\n     * @return requiredDebtTokenAmount The required debt token amount to reach the target leverage\n     */\n    function _getRequiredDebtTokenAmountToRebalance(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 subsidyBps,\n        uint256 additionalDebtTokenAmount\n    ) internal view returns (uint256 requiredDebtTokenAmount) {\n        /* If the additional debt token amount is 0, it means the expected debt token amount to reach the target leverage\n         * can be less than or equal to the current debt token balance in the vault\n         * Thus, we need to calculate the actual required debt token amount to reach the target leverage\n         * and then use the current debt token balance in the vault to repay\n         * - It is to avoid the situation where the current debt token balance in the vault is too high\n         *   and thus cannot call decreaseLeverage with this balance as it will decrease the leverage below the target leverage\n         *\n         * This function is only being used internally\n         */\n        if (additionalDebtTokenAmount == 0) {\n            return\n                _getDebtTokenAmountToReachTargetLeverage(\n                    expectedTargetLeverageBps,\n                    totalCollateralBase,\n                    totalDebtBase,\n                    subsidyBps,\n                    false\n                );\n        }\n\n        uint256 debtTokenBalanceInVault = debtToken.balanceOf(address(this));\n        return debtTokenBalanceInVault + additionalDebtTokenAmount;\n    }\n\n    /**\n     * @dev Increases the leverage of the user by supplying collateral token and borrowing more debt token\n     *      - It requires to spend the collateral token from the user's wallet to supply to the pool\n     *      - It will send the borrowed debt token to the user's wallet\n     * @param additionalCollateralTokenAmount The additional amount of collateral token to supply\n     * @param minReceivedDebtTokenAmount The minimum amount of debt token to receive\n     */\n    function increaseLeverage(\n        uint256 additionalCollateralTokenAmount,\n        uint256 minReceivedDebtTokenAmount\n    ) public nonReentrant {\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - Assume that the price of WETH is 2000 dUSD\n         * - The current leverage is 1.25x\n         *   - Total collateral: 100 WETH (100 * 2000 = 200,000 dUSD)\n         *   - Total debt: 40,000 dUSD\n         *   - Leverage: 200,000 / (200,000 - 40,000) = 1.25x\n         *   - Assume that there is 0 collateral token in the vault\n         *\n         * 1. User call increaseLeverage with 50 WETH\n         * 2. The vault transfers 50 WETH from the user's wallet to the vault\n         * 3. The vault supplies 50 WETH to the lending pool\n         * 4. The vault borrows 100,000 dUSD (50 * 2000) from the lending pool\n         * 5. The vault sends 100,000 dUSD to the user\n         *\n         * The current leverage is now increased:\n         *    - Total collateral: 150 WETH (150 * 2000 = 300,000 dUSD)\n         *    - Total debt: 140,000 dUSD\n         *    - Leverage: 300,000 / (300,000 - 140,000) = 1.875x\n         */\n\n        (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase\n        ) = getTotalCollateralAndDebtOfUserInBase(address(this));\n        uint256 subsidyBps = getCurrentSubsidyBps();\n\n        // Make sure only increase the leverage if it is below the target leverage\n        uint256 currentLeverageBps = getCurrentLeverageBps();\n        if (currentLeverageBps >= targetLeverageBps) {\n            revert LeverageExceedsTarget(currentLeverageBps, targetLeverageBps);\n        }\n\n        // Need to calculate the required collateral token amount before transferring the additional collateral token\n        // to the vault as it will change the current collateral token balance in the vault\n        uint256 requiredCollateralTokenAmount = _getRequiredCollateralTokenAmountToRebalance(\n                targetLeverageBps,\n                totalCollateralBase,\n                totalDebtBase,\n                subsidyBps,\n                additionalCollateralTokenAmount\n            );\n\n        // Only transfer the collateral token if there is an additional amount to supply\n        if (additionalCollateralTokenAmount > 0) {\n            // Transfer the additional collateral token from the caller to the vault\n            collateralToken.safeTransferFrom(\n                msg.sender,\n                address(this),\n                additionalCollateralTokenAmount\n            );\n        }\n\n        // Calculate the amount of collateral token in base currency\n        uint256 requiredCollateralTokenAmountInBase = convertFromTokenAmountToBaseCurrency(\n                requiredCollateralTokenAmount,\n                address(collateralToken)\n            );\n\n        // The amount of debt token to borrow (in base currency) is equal to the amount of collateral token supplied\n        // plus the subsidy (bonus for the caller)\n        uint256 borrowedDebtTokenInBase = (requiredCollateralTokenAmountInBase *\n            (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS + subsidyBps)) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        // Calculate the new leverage after increasing the leverage\n        uint256 newLeverageBps = ((totalCollateralBase +\n            requiredCollateralTokenAmountInBase) *\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n            (totalCollateralBase +\n                requiredCollateralTokenAmountInBase -\n                totalDebtBase -\n                borrowedDebtTokenInBase);\n\n        // Make sure the new leverage is increasing and does not exceed the target leverage\n        if (\n            newLeverageBps > targetLeverageBps ||\n            newLeverageBps <= currentLeverageBps\n        ) {\n            revert IncreaseLeverageOutOfRange(\n                newLeverageBps,\n                targetLeverageBps,\n                currentLeverageBps\n            );\n        }\n\n        // Supply the collateral token to the lending pool\n        _supplyToPool(\n            address(collateralToken),\n            requiredCollateralTokenAmount,\n            address(this)\n        );\n\n        // Borrow debt token\n        uint256 borrowedDebtTokenAmount = convertFromBaseCurrencyToToken(\n            borrowedDebtTokenInBase,\n            address(debtToken)\n        );\n\n        // Slippage protection, to make sure the user receives at least minReceivedDebtTokenAmount\n        if (borrowedDebtTokenAmount < minReceivedDebtTokenAmount) {\n            revert RebalanceReceiveLessThanMinAmount(\n                \"increaseLeverage\",\n                borrowedDebtTokenAmount,\n                minReceivedDebtTokenAmount\n            );\n        }\n\n        // At this step, the _borrowFromPool wrapper function will also assert that\n        // the borrowed amount is exactly the amount requested, thus we can safely\n        // have the slippage check before calling this function\n        _borrowFromPool(\n            address(debtToken),\n            borrowedDebtTokenAmount,\n            address(this)\n        );\n\n        // Transfer the debt token to the user\n        debtToken.safeTransfer(msg.sender, borrowedDebtTokenAmount);\n    }\n\n    /**\n     * @dev Decreases the leverage of the user by repaying debt and withdrawing collateral\n     *      - It requires to spend the debt token from the user's wallet to repay the debt to the pool\n     *      - It will send the withdrawn collateral asset to the user's wallet\n     * @param additionalDebtTokenAmount The additional amount of debt token to repay\n     * @param minReceivedAmount The minimum amount of collateral asset to receive\n     */\n    function decreaseLeverage(\n        uint256 additionalDebtTokenAmount,\n        uint256 minReceivedAmount\n    ) public nonReentrant {\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - Assume that the price of WETH is 2000 dUSD\n         * - The current leverage is 4x\n         *   - Total collateral: 100 WETH (100 * 2000 = 200,000 dUSD)\n         *   - Total debt: 150,000 dUSD\n         *   - Leverage: 200,000 / (200,000 - 150,000) = 4x\n         *\n         * 1. User call decreaseLeverage with 20,000 dUSD\n         * 2. The vault transfers 20,000 dUSD from the user's wallet to the vault\n         * 3. The vault repays 20,000 dUSD to the lending pool\n         * 4. The vault withdraws 10 WETH (20,000 / 2000) from the lending pool\n         * 5. The vault sends 10 WETH to the user\n         *\n         * The current leverage is now decreased:\n         *    - Total collateral: 90 WETH (90 * 2000 = 180,000 dUSD)\n         *    - Total debt: 130,000 dUSD\n         *    - Leverage: 180,000 / (180,000 - 130,000) = 3.6x\n         */\n        // Make sure only decrease the leverage if it is above the target leverage\n\n        (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase\n        ) = getTotalCollateralAndDebtOfUserInBase(address(this));\n        uint256 subsidyBps = getCurrentSubsidyBps();\n\n        uint256 currentLeverageBps = getCurrentLeverageBps();\n        if (currentLeverageBps <= targetLeverageBps) {\n            revert LeverageBelowTarget(currentLeverageBps, targetLeverageBps);\n        }\n\n        // Need to calculate the required debt token amount before transferring the additional debt token\n        // to the vault as it will change the current debt token balance in the vault\n        uint256 requiredDebtTokenAmount = _getRequiredDebtTokenAmountToRebalance(\n                targetLeverageBps,\n                totalCollateralBase,\n                totalDebtBase,\n                subsidyBps,\n                additionalDebtTokenAmount\n            );\n\n        // Only transfer the debt token if there is an additional amount to repay\n        if (additionalDebtTokenAmount > 0) {\n            // Transfer the additional debt token from the caller to the vault\n            debtToken.safeTransferFrom(\n                msg.sender,\n                address(this),\n                additionalDebtTokenAmount\n            );\n        }\n\n        // Calculate the amount of debt token in base currency\n        uint256 requiredDebtTokenAmountInBase = convertFromTokenAmountToBaseCurrency(\n                requiredDebtTokenAmount,\n                address(debtToken)\n            );\n\n        // The amount of collateral asset to withdraw is equal to the amount of debt token repaid\n        // plus the subsidy (bonus for the caller)\n        uint256 withdrawCollateralTokenInBase = (requiredDebtTokenAmountInBase *\n            (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS + subsidyBps)) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        // Calculate the new leverage after decreasing the leverage\n        uint256 newLeverageBps = ((totalCollateralBase -\n            withdrawCollateralTokenInBase) *\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n            (totalCollateralBase -\n                withdrawCollateralTokenInBase -\n                totalDebtBase +\n                requiredDebtTokenAmountInBase);\n\n        // Make sure the new leverage is decreasing and is not below the target leverage\n        if (\n            newLeverageBps < targetLeverageBps ||\n            newLeverageBps >= currentLeverageBps\n        ) {\n            revert DecreaseLeverageOutOfRange(\n                newLeverageBps,\n                targetLeverageBps,\n                currentLeverageBps\n            );\n        }\n\n        // Repay the debt token to the lending pool\n        _repayDebtToPool(\n            address(debtToken),\n            requiredDebtTokenAmount,\n            address(this)\n        );\n\n        // Withdraw collateral\n        uint256 withdrawnCollateralTokenAmount = convertFromBaseCurrencyToToken(\n            withdrawCollateralTokenInBase,\n            address(collateralToken)\n        );\n\n        // Slippage protection, to make sure the user receives at least minReceivedAmount\n        if (withdrawnCollateralTokenAmount < minReceivedAmount) {\n            revert RebalanceReceiveLessThanMinAmount(\n                \"decreaseLeverage\",\n                withdrawnCollateralTokenAmount,\n                minReceivedAmount\n            );\n        }\n\n        // At this step, the _withdrawFromPool wrapper function will also assert that\n        // the withdrawn amount is exactly the amount requested, thus we can safely\n        // have the slippage check before calling this function\n        _withdrawFromPool(\n            address(collateralToken),\n            withdrawnCollateralTokenAmount,\n            address(this)\n        );\n\n        // Transfer the collateral asset to the user\n        collateralToken.safeTransfer(\n            msg.sender,\n            withdrawnCollateralTokenAmount\n        );\n    }\n\n    /* Informational */\n\n    /**\n     * @dev Gets the current leverage in basis points\n     * @return uint256 The current leverage in basis points\n     */\n    function getCurrentLeverageBps() public view returns (uint256) {\n        (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase\n        ) = getTotalCollateralAndDebtOfUserInBase(address(this));\n\n        if (totalCollateralBase < totalDebtBase) {\n            revert CollateralLessThanDebt(totalCollateralBase, totalDebtBase);\n        }\n        if (totalCollateralBase == 0) {\n            return 0;\n        }\n        if (totalCollateralBase == totalDebtBase) {\n            return type(uint256).max; // infinite leverage\n        }\n        // The leverage will be 1 if totalDebtBase is 0 (no more debt)\n        uint256 leverageBps = ((totalCollateralBase *\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n            (totalCollateralBase - totalDebtBase));\n        if (leverageBps < BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert InvalidLeverage(leverageBps);\n        }\n        return leverageBps;\n    }\n\n    /**\n     * @dev Gets the current subsidy in basis points\n     * @return uint256 The current subsidy in basis points\n     */\n    function getCurrentSubsidyBps() public view returns (uint256) {\n        uint256 currentLeverageBps = getCurrentLeverageBps();\n\n        uint256 subsidyBps;\n        if (currentLeverageBps > targetLeverageBps) {\n            subsidyBps =\n                ((currentLeverageBps - targetLeverageBps) *\n                    BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n                targetLeverageBps;\n        } else {\n            subsidyBps =\n                ((targetLeverageBps - currentLeverageBps) *\n                    BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n                targetLeverageBps;\n        }\n        if (subsidyBps > maxSubsidyBps) {\n            return maxSubsidyBps;\n        }\n        return subsidyBps;\n    }\n\n    /**\n     * @dev Gets the address of the collateral token\n     * @return address The address of the collateral token\n     */\n    function getCollateralTokenAddress() public view returns (address) {\n        return address(collateralToken);\n    }\n\n    /**\n     * @dev Gets the address of the debt token\n     * @return address The address of the debt token\n     */\n    function getDebtTokenAddress() public view returns (address) {\n        return address(debtToken);\n    }\n\n    /**\n     * @dev Gets the default maximum subsidy in basis points\n     * @return uint256 The default maximum subsidy in basis points\n     */\n    function getDefaultMaxSubsidyBps() public view returns (uint256) {\n        return maxSubsidyBps;\n    }\n\n    /* Admin */\n\n    /**\n     * @dev Sets the maximum subsidy in basis points\n     * @param _maxSubsidyBps New maximum subsidy in basis points\n     */\n    function setMaxSubsidyBps(\n        uint256 _maxSubsidyBps\n    ) public onlyOwner nonReentrant {\n        maxSubsidyBps = _maxSubsidyBps;\n    }\n\n    /**\n     * @dev Sets the lower and upper bounds of target leverage\n     * @param _lowerBoundTargetLeverageBps New lower bound of target leverage in basis points\n     * @param _upperBoundTargetLeverageBps New upper bound of target leverage in basis points\n     */\n    function setLeverageBounds(\n        uint32 _lowerBoundTargetLeverageBps,\n        uint32 _upperBoundTargetLeverageBps\n    ) public onlyOwner nonReentrant {\n        if (\n            _lowerBoundTargetLeverageBps >= targetLeverageBps ||\n            targetLeverageBps >= _upperBoundTargetLeverageBps\n        ) {\n            revert InvalidLeverageBounds(\n                _lowerBoundTargetLeverageBps,\n                targetLeverageBps,\n                _upperBoundTargetLeverageBps\n            );\n        }\n\n        lowerBoundTargetLeverageBps = _lowerBoundTargetLeverageBps;\n        upperBoundTargetLeverageBps = _upperBoundTargetLeverageBps;\n    }\n\n    /* Overrides to add leverage check */\n\n    function maxDeposit(address _user) public view override returns (uint256) {\n        // Don't allow deposit if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        return super.maxDeposit(_user);\n    }\n\n    function maxMint(address _user) public view override returns (uint256) {\n        // Don't allow mint if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        return super.maxMint(_user);\n    }\n\n    function maxWithdraw(address _user) public view override returns (uint256) {\n        // Don't allow withdraw if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        return super.maxWithdraw(_user);\n    }\n\n    function maxRedeem(address _user) public view override returns (uint256) {\n        // Don't allow redeem if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        return super.maxRedeem(_user);\n    }\n}\n"
    },
    "contracts/vaults/dloop/core/venue/dlend/DLoopCoreDLend.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {IPriceOracleGetter} from \"./interface/IPriceOracleGetter.sol\";\nimport {IPool as ILendingPool, DataTypes} from \"./interface/IPool.sol\";\nimport {IPoolAddressesProvider} from \"./interface/IPoolAddressesProvider.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {DLoopCoreBase} from \"../../DLoopCoreBase.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {RewardClaimable} from \"contracts/vaults/rewards_claimable/RewardClaimable.sol\";\nimport {IRewardsController} from \"./interface/IRewardsController.sol\";\n\n/**\n * @title DLoopCoreDLend\n * @dev Read the documentation of DLoopCoreBase for more details\n *      - This contract implement dLEND-specific lending operations for DLoopCoreBase\n */\ncontract DLoopCoreDLend is DLoopCoreBase, RewardClaimable {\n    /* Constants */\n\n    uint8 public constant AAVE_PRICE_ORACLE_DECIMALS = 8;\n\n    // Note that there is a vulnerability in stable interest rate mode, so we will never use it\n    // See contracts/lending/core/protocol/libraries/types/DataTypes.sol\n    uint256 public constant VARIABLE_LENDING_INTERST_RATE_MODE = 2; // 0 = NONE, 1 = STABLE, 2 = VARIABLE\n\n    // Maximum percentage factor (100.00%)\n    uint256 public constant PERCENTAGE_FACTOR = 1e4;\n\n    /* State */\n\n    IPoolAddressesProvider public immutable lendingPoolAddressesProvider;\n    IRewardsController public immutable dLendRewardsController;\n    address public immutable dLendAssetToClaimFor;\n    address public immutable targetStaticATokenWrapper;\n\n    /* Errors */\n\n    error ZeroAddress();\n\n    /**\n     * @dev Constructor for the DLoopCoreDLend contract\n     * @param _name Name of the vault token\n     * @param _symbol Symbol of the vault token\n     * @param _collateralToken Address of the collateral token\n     * @param _debtToken Address of the debt token\n     * @param _lendingPoolAddressesProvider Address of the lending pool addresses provider\n     * @param _targetLeverageBps Target leverage in basis points\n     * @param _lowerBoundTargetLeverageBps Lower bound of target leverage in basis points\n     * @param _upperBoundTargetLeverageBps Upper bound of target leverage in basis points\n     * @param _maxSubsidyBps Maximum subsidy in basis points\n     * @param _rewardsController Address of the dLEND rewards controller\n     * @param _dLendAssetToClaimFor Address of the dLEND asset to claim for\n     * @param _targetStaticATokenWrapper Address of the target static aToken wrapper\n     * @param _treasury Address of the treasury\n     * @param _maxTreasuryFeeBps Maximum treasury fee in basis points\n     * @param _initialTreasuryFeeBps Initial treasury fee in basis points\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        ERC20 _collateralToken,\n        ERC20 _debtToken,\n        IPoolAddressesProvider _lendingPoolAddressesProvider,\n        uint32 _targetLeverageBps,\n        uint32 _lowerBoundTargetLeverageBps,\n        uint32 _upperBoundTargetLeverageBps,\n        uint256 _maxSubsidyBps,\n        IRewardsController _rewardsController,\n        address _dLendAssetToClaimFor,\n        address _targetStaticATokenWrapper,\n        address _treasury,\n        uint256 _maxTreasuryFeeBps,\n        uint256 _initialTreasuryFeeBps,\n        uint256 _initialExchangeThreshold\n    )\n        DLoopCoreBase(\n            _name,\n            _symbol,\n            _collateralToken,\n            _debtToken,\n            _targetLeverageBps,\n            _lowerBoundTargetLeverageBps,\n            _upperBoundTargetLeverageBps,\n            _maxSubsidyBps\n        )\n        RewardClaimable(\n            address(_debtToken),\n            _treasury,\n            _maxTreasuryFeeBps,\n            _initialTreasuryFeeBps,\n            _initialExchangeThreshold\n        )\n    {\n        // Always use the debt token as the exchange asset in reward claim logic\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        dLendRewardsController = _rewardsController;\n        dLendAssetToClaimFor = _dLendAssetToClaimFor;\n        targetStaticATokenWrapper = _targetStaticATokenWrapper;\n\n        if (getLendingOracle().BASE_CURRENCY() != address(0)) {\n            revert(\"Invalid price oracle base currency\");\n        }\n\n        uint256 oracleUnit = getLendingOracle().BASE_CURRENCY_UNIT();\n\n        if (oracleUnit != 10 ** AAVE_PRICE_ORACLE_DECIMALS) {\n            revert(\"Invalid price oracle unit\");\n        }\n    }\n\n    /**\n     * @inheritdoc DLoopCoreBase\n     * @return address[] Additional rescue tokens\n     */\n    function _getAdditionalRescueTokensImplementation()\n        internal\n        view\n        override\n        returns (address[] memory)\n    {\n        DataTypes.ReserveData memory reserveData = _getReserveData(\n            address(collateralToken)\n        );\n        address[] memory additionalRescueTokens = new address[](3);\n        additionalRescueTokens[0] = reserveData.aTokenAddress;\n        additionalRescueTokens[1] = reserveData.variableDebtTokenAddress;\n        additionalRescueTokens[2] = reserveData.stableDebtTokenAddress;\n        return additionalRescueTokens;\n    }\n\n    /**\n     * @dev Gets the asset price from the oracle\n     * @param asset Address of the asset\n     * @return uint256 Price of the asset\n     */\n    function _getAssetPriceFromOracleImplementation(\n        address asset\n    ) internal view override returns (uint256) {\n        return getLendingOracle().getAssetPrice(asset);\n    }\n\n    /**\n     * @dev Supply tokens to the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to supply\n     * @param onBehalfOf Address to supply on behalf of\n     */\n    function _supplyToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        ILendingPool lendingPool = getLendingPool();\n\n        // Approve the lending pool to spend the token\n        require(\n            ERC20(token).approve(address(lendingPool), amount),\n            \"approve failed for lending pool in supply\"\n        );\n\n        // Supply the token to the lending pool\n        lendingPool.supply(token, amount, onBehalfOf, 0);\n    }\n\n    /**\n     * @dev Borrow tokens from the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to borrow\n     * @param onBehalfOf Address to borrow on behalf of\n     */\n    function _borrowFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        getLendingPool().borrow(\n            token,\n            amount,\n            VARIABLE_LENDING_INTERST_RATE_MODE,\n            0,\n            onBehalfOf\n        );\n    }\n\n    /**\n     * @dev Repay debt to the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to repay\n     * @param onBehalfOf Address to repay on behalf of\n     */\n    function _repayDebtToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        ILendingPool lendingPool = getLendingPool();\n\n        // Approve the lending pool to spend the token\n        require(\n            ERC20(token).approve(address(lendingPool), amount),\n            \"approve failed for lending pool in repay\"\n        );\n\n        // Repay the debt\n        lendingPool.repay(\n            token,\n            amount,\n            VARIABLE_LENDING_INTERST_RATE_MODE,\n            onBehalfOf\n        );\n    }\n\n    /**\n     * @dev Withdraw tokens from the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to withdraw\n     * @param onBehalfOf Address to withdraw on behalf of\n     */\n    function _withdrawFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        getLendingPool().withdraw(token, amount, onBehalfOf);\n    }\n\n    /**\n     * @dev Gets the total collateral and debt of a user in base currency\n     * @param user Address of the user\n     * @return totalCollateralBase Total collateral in base currency\n     * @return totalDebtBase Total debt in base currency\n     */\n    function getTotalCollateralAndDebtOfUserInBase(\n        address user\n    )\n        public\n        view\n        override\n        returns (uint256 totalCollateralBase, uint256 totalDebtBase)\n    {\n        (totalCollateralBase, totalDebtBase, , , , ) = getLendingPool()\n            .getUserAccountData(user);\n        return (totalCollateralBase, totalDebtBase);\n    }\n\n    /* Helper functions */\n\n    /**\n     * @dev Gets the lending oracle\n     * @return IPriceOracleGetter The lending oracle interface\n     */\n    function getLendingOracle() public view returns (IPriceOracleGetter) {\n        return\n            IPriceOracleGetter(lendingPoolAddressesProvider.getPriceOracle());\n    }\n\n    /**\n     * @dev Gets the lending pool\n     * @return ILendingPool The lending pool interface\n     */\n    function getLendingPool() public view returns (ILendingPool) {\n        return ILendingPool(lendingPoolAddressesProvider.getPool());\n    }\n\n    /**\n     * @dev Gets the lending pool address\n     * @return address The lending pool address\n     */\n    function getLendingPoolAddress() public view returns (address) {\n        return address(getLendingPool());\n    }\n\n    /**\n     * @dev Gets the oracle address\n     * @return address The oracle address\n     */\n    function getOracleAddress() public view returns (address) {\n        return address(getLendingOracle());\n    }\n\n    /**\n     * @dev Gets the reserve data for a token\n     * @param tokenAddress The address of the token\n     * @return DataTypes.ReserveData The reserve data\n     */\n    function _getReserveData(\n        address tokenAddress\n    ) internal view returns (DataTypes.ReserveData memory) {\n        return getLendingPool().getReserveData(tokenAddress);\n    }\n\n    /**\n     * @dev Gets the DToken address for a token\n     * @param tokenAddress The address of the token\n     * @return address The DToken address\n     */\n    function _getDTokenAddress(\n        address tokenAddress\n    ) internal view returns (address) {\n        return _getReserveData(tokenAddress).aTokenAddress;\n    }\n\n    /**\n     * @dev Gets the DToken balance of the vault\n     * @param tokenAddress The address of the token\n     * @return uint256 The DToken balance of the vault\n     */\n    function getDTokenBalance(\n        address tokenAddress\n    ) public view returns (uint256) {\n        return ERC20(_getDTokenAddress(tokenAddress)).balanceOf(address(this));\n    }\n\n    /* RewardClaimable functions */\n\n    /**\n     * @dev Claims multiple rewards\n     * @param rewardTokens The reward tokens to claim\n     * @param receiver The address to receive the claimed rewards\n     * @return rewardAmounts The amount of rewards claimed for each token (have the same length as the tokens array)\n     */\n    function _claimRewards(\n        address[] calldata rewardTokens,\n        address receiver\n    ) internal override returns (uint256[] memory rewardAmounts) {\n        if (rewardTokens.length == 0) {\n            revert ZeroRewardTokens();\n        }\n        if (receiver == address(0)) {\n            revert ZeroReceiverAddress();\n        }\n\n        rewardAmounts = new uint256[](rewardTokens.length);\n        address[] memory assetsToClaimForPayload = new address[](1);\n        assetsToClaimForPayload[0] = dLendAssetToClaimFor;\n\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            address rewardToken = rewardTokens[i];\n            if (rewardToken == address(0)) {\n                revert ZeroAddress(); // Cannot claim zero address token\n            }\n\n            uint256 balanceBefore = ERC20(rewardToken).balanceOf(receiver);\n\n            // Claim all available amount of the specific reward token\n            dLendRewardsController.claimRewardsOnBehalf(\n                assetsToClaimForPayload, // Asset held by the wrapper in dLEND\n                type(uint256).max, // Claim all\n                targetStaticATokenWrapper, // User earning rewards is the wrapper\n                receiver,\n                rewardToken // The reward token to claim\n            );\n\n            uint256 balanceAfter = ERC20(rewardToken).balanceOf(receiver);\n            rewardAmounts[i] = balanceAfter - balanceBefore;\n        }\n        return rewardAmounts;\n    }\n\n    /**\n     * @dev Processes the exchange asset deposit from the caller\n     * @param amount The amount of exchange asset to deposit\n     */\n    function _processExchangeAssetDeposit(uint256 amount) internal override {\n        // As the exchange asset is the debt token, we use it to repay the debt,\n        // which means to reduce the borrowing interest to be paid\n        _repayDebtToPoolImplementation(exchangeAsset, amount, address(this));\n    }\n}\n"
    },
    "contracts/vaults/dloop/core/venue/dlend/interface/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\nimport {DataTypes} from \"./types/DataTypes.sol\";\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n    /**\n     * @dev Emitted on mintUnbacked()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the supply\n     * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n     * @param amount The amount of supplied assets\n     * @param referralCode The referral code used\n     */\n    event MintUnbacked(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on backUnbacked()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param backer The address paying for the backing\n     * @param amount The amount added as backing\n     * @param fee The amount paid in fees\n     */\n    event BackUnbacked(\n        address indexed reserve,\n        address indexed backer,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /**\n     * @dev Emitted on supply()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the supply\n     * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n     * @param amount The amount supplied\n     * @param referralCode The referral code used\n     */\n    event Supply(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlying asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to The address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     */\n    event Withdraw(\n        address indexed reserve,\n        address indexed user,\n        address indexed to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n     * @param referralCode The referral code used\n     */\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 borrowRate,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the funds\n     * @param amount The amount repaid\n     * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n     */\n    event Repay(\n        address indexed reserve,\n        address indexed user,\n        address indexed repayer,\n        uint256 amount,\n        bool useATokens\n    );\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n     */\n    event SwapBorrowRateMode(\n        address indexed reserve,\n        address indexed user,\n        DataTypes.InterestRateMode interestRateMode\n    );\n\n    /**\n     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n     * @param asset The address of the underlying asset of the reserve\n     * @param totalDebt The total isolation mode debt for the reserve\n     */\n    event IsolationModeTotalDebtUpdated(\n        address indexed asset,\n        uint256 totalDebt\n    );\n\n    /**\n     * @dev Emitted when the user selects a certain asset category for eMode\n     * @param user The address of the user\n     * @param categoryId The category id\n     */\n    event UserEModeSet(address indexed user, uint8 categoryId);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     */\n    event ReserveUsedAsCollateralEnabled(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     */\n    event ReserveUsedAsCollateralDisabled(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     */\n    event RebalanceStableBorrowRate(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     */\n    event FlashLoan(\n        address indexed target,\n        address initiator,\n        address indexed asset,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 premium,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted when a borrower is liquidated.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     */\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated.\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The next liquidity rate\n     * @param stableBorrowRate The next stable borrow rate\n     * @param variableBorrowRate The next variable borrow rate\n     * @param liquidityIndex The next liquidity index\n     * @param variableBorrowIndex The next variable borrow index\n     */\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n     * @param reserve The address of the reserve\n     * @param amountMinted The amount minted to the treasury\n     */\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n    /**\n     * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n     * @param asset The address of the underlying asset to mint\n     * @param amount The amount to mint\n     * @param onBehalfOf The address that will receive the aTokens\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function mintUnbacked(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n     * @param asset The address of the underlying asset to back\n     * @param amount The amount to back\n     * @param fee The amount paid in fees\n     * @return The backed amount\n     */\n    function backUnbacked(\n        address asset,\n        uint256 amount,\n        uint256 fee\n    ) external returns (uint256);\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function supply(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Supply with transfer approval of asset to be supplied done via permit function\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     */\n    function supplyWithPermit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external;\n\n    /**\n     * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to The address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     */\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     */\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     */\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @notice Repay with transfer approval of asset to be repaid done via permit function\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     * @return The final amount repaid\n     */\n    function repayWithPermit(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external returns (uint256);\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n     * equivalent debt tokens\n     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n     * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n     * balance is not enough to cover the whole debt\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @return The final amount repaid\n     */\n    function repayWithATokens(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n     * @param asset The address of the underlying asset borrowed\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n     */\n    function swapBorrowRateMode(\n        address asset,\n        uint256 interestRateMode\n    ) external;\n\n    /**\n     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n     *        much has been borrowed at a stable rate and suppliers are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     */\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n     * @param asset The address of the underlying asset supplied\n     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n     */\n    function setUserUseReserveAsCollateral(\n        address asset,\n        bool useAsCollateral\n    ) external;\n\n    /**\n     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     */\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n     * into consideration. For further details please visit https://docs.aave.com/developers/\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts of the assets being flash-borrowed\n     * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata interestRateModes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n     * into consideration. For further details please visit https://docs.aave.com/developers/\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n     * @param asset The address of the asset being flash-borrowed\n     * @param amount The amount of the asset being flash-borrowed\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function flashLoanSimple(\n        address receiverAddress,\n        address asset,\n        uint256 amount,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n     * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n     * @return currentLiquidationThreshold The liquidation threshold of the user\n     * @return ltv The loan to value of The user\n     * @return healthFactor The current health factor of the user\n     */\n    function getUserAccountData(\n        address user\n    )\n        external\n        view\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    /**\n     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n     * interest rate strategy\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n     * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\n     */\n    function initReserve(\n        address asset,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    /**\n     * @notice Drop a reserve\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     */\n    function dropReserve(address asset) external;\n\n    /**\n     * @notice Updates the address of the interest rate strategy contract\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param rateStrategyAddress The address of the interest rate strategy contract\n     */\n    function setReserveInterestRateStrategyAddress(\n        address asset,\n        address rateStrategyAddress\n    ) external;\n\n    /**\n     * @notice Sets the configuration bitmap of the reserve as a whole\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param configuration The new configuration bitmap\n     */\n    function setConfiguration(\n        address asset,\n        DataTypes.ReserveConfigurationMap calldata configuration\n    ) external;\n\n    /**\n     * @notice Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     */\n    function getConfiguration(\n        address asset\n    ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @notice Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     */\n    function getUserConfiguration(\n        address user\n    ) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @notice Returns the normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(\n        address asset\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the normalized variable debt per unit of asset\n     * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n     * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n     * moment (approx. a borrower would get if opening a position). This means that is always used in\n     * combination with variable debt supply/balances.\n     * If using this function externally, consider that is possible to have an increasing normalized\n     * variable debt that is not equivalent to how the variable debt index would be updated in storage\n     * (e.g. only updates with non-zero variable debt supply)\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(\n        address asset\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state and configuration data of the reserve\n     */\n    function getReserveData(\n        address asset\n    ) external view returns (DataTypes.ReserveData memory);\n\n    /**\n     * @notice Validates and finalizes an aToken transfer\n     * @dev Only callable by the overlying aToken of the `asset`\n     * @param asset The address of the underlying asset of the aToken\n     * @param from The user from which the aTokens are transferred\n     * @param to The user receiving the aTokens\n     * @param amount The amount being transferred/withdrawn\n     * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n     * @param balanceToBefore The aToken balance of the `to` user before the transfer\n     */\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromBefore,\n        uint256 balanceToBefore\n    ) external;\n\n    /**\n     * @notice Returns the list of the underlying assets of all the initialized reserves\n     * @dev It does not include dropped reserves\n     * @return The addresses of the underlying assets of the initialized reserves\n     */\n    function getReservesList() external view returns (address[] memory);\n\n    /**\n     * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n     * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n     * @return The address of the reserve associated with id\n     */\n    function getReserveAddressById(uint16 id) external view returns (address);\n\n    /**\n     * @notice Returns the PoolAddressesProvider connected to this contract\n     * @return The address of the PoolAddressesProvider\n     */\n    function ADDRESSES_PROVIDER()\n        external\n        view\n        returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Updates the protocol fee on the bridging\n     * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n     */\n    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n    /**\n     * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n     * - A part is sent to aToken holders as extra, one time accumulated interest\n     * - A part is collected by the protocol treasury\n     * @dev The total premium is calculated on the total borrowed amount\n     * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n     * @dev Only callable by the PoolConfigurator contract\n     * @param flashLoanPremiumTotal The total premium, expressed in bps\n     * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n     */\n    function updateFlashloanPremiums(\n        uint128 flashLoanPremiumTotal,\n        uint128 flashLoanPremiumToProtocol\n    ) external;\n\n    /**\n     * @notice Configures a new category for the eMode.\n     * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n     * The category 0 is reserved as it's the default for volatile assets\n     * @param id The id of the category\n     * @param config The configuration of the category\n     */\n    function configureEModeCategory(\n        uint8 id,\n        DataTypes.EModeCategory memory config\n    ) external;\n\n    /**\n     * @notice Returns the data of an eMode category\n     * @param id The id of the category\n     * @return The configuration data of the category\n     */\n    function getEModeCategoryData(\n        uint8 id\n    ) external view returns (DataTypes.EModeCategory memory);\n\n    /**\n     * @notice Allows a user to use the protocol in eMode\n     * @param categoryId The id of the category\n     */\n    function setUserEMode(uint8 categoryId) external;\n\n    /**\n     * @notice Returns the eMode the user is using\n     * @param user The address of the user\n     * @return The eMode id\n     */\n    function getUserEMode(address user) external view returns (uint256);\n\n    /**\n     * @notice Resets the isolation mode total debt of the given asset to zero\n     * @dev It requires the given asset has zero debt ceiling\n     * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n     */\n    function resetIsolationModeTotalDebt(address asset) external;\n\n    /**\n     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n     * @return The percentage of available liquidity to borrow, expressed in bps\n     */\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT()\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the total fee on flash loans\n     * @return The total fee on flashloans\n     */\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n    /**\n     * @notice Returns the part of the bridge fees sent to protocol\n     * @return The bridge fee sent to the protocol treasury\n     */\n    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n    /**\n     * @notice Returns the part of the flashloan fees sent to protocol\n     * @return The flashloan fee sent to the protocol treasury\n     */\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n    /**\n     * @notice Returns the maximum number of reserves supported to be listed in this Pool\n     * @return The maximum number of reserves supported\n     */\n    function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n    /**\n     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n     * @param assets The list of reserves for which the minting needs to be executed\n     */\n    function mintToTreasury(address[] calldata assets) external;\n\n    /**\n     * @notice Rescue and transfer tokens locked in this contract\n     * @param token The address of the token\n     * @param to The address of the recipient\n     * @param amount The amount of token to transfer\n     */\n    function rescueTokens(address token, address to, uint256 amount) external;\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n     * @dev Deprecated: Use the `supply` function instead\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n}\n"
    },
    "contracts/vaults/dloop/core/venue/dlend/interface/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n    /**\n     * @dev Emitted when the market identifier is updated.\n     * @param oldMarketId The old id of the market\n     * @param newMarketId The new id of the market\n     */\n    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n    /**\n     * @dev Emitted when the pool is updated.\n     * @param oldAddress The old address of the Pool\n     * @param newAddress The new address of the Pool\n     */\n    event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the pool configurator is updated.\n     * @param oldAddress The old address of the PoolConfigurator\n     * @param newAddress The new address of the PoolConfigurator\n     */\n    event PoolConfiguratorUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the price oracle is updated.\n     * @param oldAddress The old address of the PriceOracle\n     * @param newAddress The new address of the PriceOracle\n     */\n    event PriceOracleUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the ACL manager is updated.\n     * @param oldAddress The old address of the ACLManager\n     * @param newAddress The new address of the ACLManager\n     */\n    event ACLManagerUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the ACL admin is updated.\n     * @param oldAddress The old address of the ACLAdmin\n     * @param newAddress The new address of the ACLAdmin\n     */\n    event ACLAdminUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the price oracle sentinel is updated.\n     * @param oldAddress The old address of the PriceOracleSentinel\n     * @param newAddress The new address of the PriceOracleSentinel\n     */\n    event PriceOracleSentinelUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the pool data provider is updated.\n     * @param oldAddress The old address of the PoolDataProvider\n     * @param newAddress The new address of the PoolDataProvider\n     */\n    event PoolDataProviderUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when a new proxy is created.\n     * @param id The identifier of the proxy\n     * @param proxyAddress The address of the created proxy contract\n     * @param implementationAddress The address of the implementation contract\n     */\n    event ProxyCreated(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address indexed implementationAddress\n    );\n\n    /**\n     * @dev Emitted when a new non-proxied contract address is registered.\n     * @param id The identifier of the contract\n     * @param oldAddress The address of the old contract\n     * @param newAddress The address of the new contract\n     */\n    event AddressSet(\n        bytes32 indexed id,\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the implementation of the proxy registered with id is updated\n     * @param id The identifier of the contract\n     * @param proxyAddress The address of the proxy contract\n     * @param oldImplementationAddress The address of the old implementation contract\n     * @param newImplementationAddress The address of the new implementation contract\n     */\n    event AddressSetAsProxy(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address oldImplementationAddress,\n        address indexed newImplementationAddress\n    );\n\n    /**\n     * @notice Returns the id of the Aave market to which this contract points to.\n     * @return The market id\n     */\n    function getMarketId() external view returns (string memory);\n\n    /**\n     * @notice Associates an id with a specific PoolAddressesProvider.\n     * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n     * identify and validate multiple Aave markets.\n     * @param newMarketId The market id\n     */\n    function setMarketId(string calldata newMarketId) external;\n\n    /**\n     * @notice Returns an address by its identifier.\n     * @dev The returned address might be an EOA or a contract, potentially proxied\n     * @dev It returns ZERO if there is no registered address with the given id\n     * @param id The id\n     * @return The address of the registered for the specified id\n     */\n    function getAddressFromID(bytes32 id) external view returns (address);\n\n    /**\n     * @notice General function to update the implementation of a proxy registered with\n     * certain `id`. If there is no proxy registered, it will instantiate one and\n     * set as implementation the `newImplementationAddress`.\n     * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n     * setter function, in order to avoid unexpected consequences\n     * @param id The id\n     * @param newImplementationAddress The address of the new implementation\n     */\n    function setAddressAsProxy(\n        bytes32 id,\n        address newImplementationAddress\n    ) external;\n\n    /**\n     * @notice Sets an address for an id replacing the address saved in the addresses map.\n     * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n     * @param id The id\n     * @param newAddress The address to set\n     */\n    function setAddress(bytes32 id, address newAddress) external;\n\n    /**\n     * @notice Returns the address of the Pool proxy.\n     * @return The Pool proxy address\n     */\n    function getPool() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the Pool, or creates a proxy\n     * setting the new `pool` implementation when the function is called for the first time.\n     * @param newPoolImpl The new Pool implementation\n     */\n    function setPoolImpl(address newPoolImpl) external;\n\n    /**\n     * @notice Returns the address of the PoolConfigurator proxy.\n     * @return The PoolConfigurator proxy address\n     */\n    function getPoolConfigurator() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n     * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n     * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n     */\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n    /**\n     * @notice Returns the address of the price oracle.\n     * @return The address of the PriceOracle\n     */\n    function getPriceOracle() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle.\n     * @param newPriceOracle The address of the new PriceOracle\n     */\n    function setPriceOracle(address newPriceOracle) external;\n\n    /**\n     * @notice Returns the address of the ACL manager.\n     * @return The address of the ACLManager\n     */\n    function getACLManager() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL manager.\n     * @param newAclManager The address of the new ACLManager\n     */\n    function setACLManager(address newAclManager) external;\n\n    /**\n     * @notice Returns the address of the ACL admin.\n     * @return The address of the ACL admin\n     */\n    function getACLAdmin() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL admin.\n     * @param newAclAdmin The address of the new ACL admin\n     */\n    function setACLAdmin(address newAclAdmin) external;\n\n    /**\n     * @notice Returns the address of the price oracle sentinel.\n     * @return The address of the PriceOracleSentinel\n     */\n    function getPriceOracleSentinel() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle sentinel.\n     * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n     */\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n    /**\n     * @notice Returns the address of the data provider.\n     * @return The address of the DataProvider\n     */\n    function getPoolDataProvider() external view returns (address);\n\n    /**\n     * @notice Updates the address of the data provider.\n     * @param newDataProvider The address of the new DataProvider\n     */\n    function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "contracts/vaults/dloop/core/venue/dlend/interface/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n    /**\n     * @notice Returns the base currency address\n     * @dev Address 0x0 is reserved for USD as base currency.\n     * @return Returns the base currency address.\n     */\n    function BASE_CURRENCY() external view returns (address);\n\n    /**\n     * @notice Returns the base currency unit\n     * @dev 1 ether for ETH, 1e8 for USD.\n     * @return Returns the base currency unit.\n     */\n    function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n    /**\n     * @notice Returns the asset price in the base currency\n     * @param asset The address of the asset\n     * @return The price of the asset\n     */\n    function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/vaults/dloop/core/venue/dlend/interface/IRewardsController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IRewardsController simplified interface\n * @author Aave\n * @notice Defines the basic interface for a Rewards Controller.\n */\ninterface IRewardsController {\n    /**\n     * @dev Claims reward for a user to the desired address, on all the assets of the pool, accumulating the pending rewards\n     * @param assets List of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param to The address that will be receiving the rewards\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to,\n        address reward\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards. The\n     * caller must be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param user The address to check and claim rewards\n     * @param to The address that will be receiving the rewards\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to,\n        address reward\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewardsToSelf(\n        address[] calldata assets,\n        uint256 amount,\n        address reward\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims all rewards for a user to the desired address, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param to The address that will be receiving the rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardList\"\n     **/\n    function claimAllRewards(\n        address[] calldata assets,\n        address to\n    )\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @dev Claims all rewards for a user on behalf, on all the assets of the pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param user The address to check and claim rewards\n     * @param to The address that will be receiving the rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n     **/\n    function claimAllRewardsOnBehalf(\n        address[] calldata assets,\n        address user,\n        address to\n    )\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @dev Claims all reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n     **/\n    function claimAllRewardsToSelf(\n        address[] calldata assets\n    )\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n}\n"
    },
    "contracts/vaults/dloop/core/venue/dlend/interface/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        //timestamp of last update\n        uint40 lastUpdateTimestamp;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint16 id;\n        //aToken address\n        address aTokenAddress;\n        //stableDebtToken address\n        address stableDebtTokenAddress;\n        //variableDebtToken address\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the current treasury balance, scaled\n        uint128 accruedToTreasury;\n        //the outstanding unbacked aTokens minted through the bridging feature\n        uint128 unbacked;\n        //the outstanding debt borrowed against this asset in isolation mode\n        uint128 isolationModeTotalDebt;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60: asset is paused\n        //bit 61: borrowing in isolation mode is enabled\n        //bit 62: siloed borrowing enabled\n        //bit 63: flashloaning enabled\n        //bit 64-79: reserve factor\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n        //bit 152-167 liquidation protocol fee\n        //bit 168-175 eMode category\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n        //bit 252-255 unused\n\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        /**\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\n         * asset is borrowed by the user.\n         */\n        uint256 data;\n    }\n\n    struct EModeCategory {\n        // each eMode category has a custom ltv and liquidation threshold\n        uint16 ltv;\n        uint16 liquidationThreshold;\n        uint16 liquidationBonus;\n        // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n        address priceSource;\n        string label;\n    }\n\n    enum InterestRateMode {\n        NONE,\n        STABLE,\n        VARIABLE\n    }\n\n    struct ReserveCache {\n        uint256 currScaledVariableDebt;\n        uint256 nextScaledVariableDebt;\n        uint256 currPrincipalStableDebt;\n        uint256 currAvgStableBorrowRate;\n        uint256 currTotalStableDebt;\n        uint256 nextAvgStableBorrowRate;\n        uint256 nextTotalStableDebt;\n        uint256 currLiquidityIndex;\n        uint256 nextLiquidityIndex;\n        uint256 currVariableBorrowIndex;\n        uint256 nextVariableBorrowIndex;\n        uint256 currLiquidityRate;\n        uint256 currVariableBorrowRate;\n        uint256 reserveFactor;\n        ReserveConfigurationMap reserveConfiguration;\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        uint40 reserveLastUpdateTimestamp;\n        uint40 stableDebtLastUpdateTimestamp;\n    }\n\n    struct ExecuteLiquidationCallParams {\n        uint256 reservesCount;\n        uint256 debtToCover;\n        address collateralAsset;\n        address debtAsset;\n        address user;\n        bool receiveAToken;\n        address priceOracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteSupplyParams {\n        address asset;\n        uint256 amount;\n        address onBehalfOf;\n        uint16 referralCode;\n    }\n\n    struct ExecuteBorrowParams {\n        address asset;\n        address user;\n        address onBehalfOf;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        uint16 referralCode;\n        bool releaseUnderlying;\n        uint256 maxStableRateBorrowSizePercent;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteRepayParams {\n        address asset;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        address onBehalfOf;\n        bool useATokens;\n    }\n\n    struct ExecuteWithdrawParams {\n        address asset;\n        uint256 amount;\n        address to;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n    }\n\n    struct ExecuteSetUserEModeParams {\n        uint256 reservesCount;\n        address oracle;\n        uint8 categoryId;\n    }\n\n    struct FinalizeTransferParams {\n        address asset;\n        address from;\n        address to;\n        uint256 amount;\n        uint256 balanceFromBefore;\n        uint256 balanceToBefore;\n        uint256 reservesCount;\n        address oracle;\n        uint8 fromEModeCategory;\n    }\n\n    struct FlashloanParams {\n        address receiverAddress;\n        address[] assets;\n        uint256[] amounts;\n        uint256[] interestRateModes;\n        address onBehalfOf;\n        bytes params;\n        uint16 referralCode;\n        uint256 flashLoanPremiumToProtocol;\n        uint256 flashLoanPremiumTotal;\n        uint256 maxStableRateBorrowSizePercent;\n        uint256 reservesCount;\n        address addressesProvider;\n        uint8 userEModeCategory;\n        bool isAuthorizedFlashBorrower;\n    }\n\n    struct FlashloanSimpleParams {\n        address receiverAddress;\n        address asset;\n        uint256 amount;\n        bytes params;\n        uint16 referralCode;\n        uint256 flashLoanPremiumToProtocol;\n        uint256 flashLoanPremiumTotal;\n    }\n\n    struct FlashLoanRepaymentParams {\n        uint256 amount;\n        uint256 totalPremium;\n        uint256 flashLoanPremiumToProtocol;\n        address asset;\n        address receiverAddress;\n        uint16 referralCode;\n    }\n\n    struct CalculateUserAccountDataParams {\n        UserConfigurationMap userConfig;\n        uint256 reservesCount;\n        address user;\n        address oracle;\n        uint8 userEModeCategory;\n    }\n\n    struct ValidateBorrowParams {\n        ReserveCache reserveCache;\n        UserConfigurationMap userConfig;\n        address asset;\n        address userAddress;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        uint256 maxStableLoanPercent;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n        bool isolationModeActive;\n        address isolationModeCollateralAddress;\n        uint256 isolationModeDebtCeiling;\n    }\n\n    struct ValidateLiquidationCallParams {\n        ReserveCache debtReserveCache;\n        uint256 totalDebt;\n        uint256 healthFactor;\n        address priceOracleSentinel;\n    }\n\n    struct CalculateInterestRatesParams {\n        uint256 unbacked;\n        uint256 liquidityAdded;\n        uint256 liquidityTaken;\n        uint256 totalStableDebt;\n        uint256 totalVariableDebt;\n        uint256 averageStableBorrowRate;\n        uint256 reserveFactor;\n        address reserve;\n        address aToken;\n    }\n\n    struct InitReserveParams {\n        address asset;\n        address aTokenAddress;\n        address stableDebtAddress;\n        address variableDebtAddress;\n        address interestRateStrategyAddress;\n        uint16 reservesCount;\n        uint16 maxNumberReserves;\n    }\n}\n"
    },
    "contracts/vaults/dloop/core/venue/mock/DLoopCoreMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {DLoopCoreBase} from \"../../DLoopCoreBase.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {BasisPointConstants} from \"contracts/common/BasisPointConstants.sol\";\nimport {PercentageMath} from \"contracts/dlend/core/protocol/libraries/math/PercentageMath.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title DLoopCoreMock\n * @dev Simple mock implementation of DLoopCoreBase for testing\n */\ncontract DLoopCoreMock is DLoopCoreBase {\n    // Mock state for prices and balances\n    mapping(address => uint256) public mockPrices;\n    mapping(address => mapping(address => uint256)) private mockCollateral; // user => token => amount\n    mapping(address => address[]) private mockCollateralTokens; // user => tokens\n    mapping(address => mapping(address => uint256)) private mockDebt; // user => token => amount\n    mapping(address => address[]) private mockDebtTokens; // user => tokens\n    address public mockPool;\n\n    // This is used to test the supply, borrow, repay, withdraw wrapper validation\n    uint256 public transferPortionBps;\n\n    uint8 public constant PRICE_DECIMALS = 8;\n    uint256 public constant PERCENTAGE_FACTOR = 1e4;\n    uint256 public constant LIQUIDATION_THRESHOLD = 8500; // 85% in basis points\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        ERC20 _collateralToken,\n        ERC20 _debtToken,\n        uint32 _targetLeverageBps,\n        uint32 _lowerBoundTargetLeverageBps,\n        uint32 _upperBoundTargetLeverageBps,\n        uint256 _maxSubsidyBps,\n        address _mockPool\n    )\n        DLoopCoreBase(\n            _name,\n            _symbol,\n            _collateralToken,\n            _debtToken,\n            _targetLeverageBps,\n            _lowerBoundTargetLeverageBps,\n            _upperBoundTargetLeverageBps,\n            _maxSubsidyBps\n        )\n    {\n        mockPool = _mockPool;\n\n        // Require large allowance from mockPool to this contract as this mock contract will\n        // transfer tokens to mockPool when supply, repay. It will take the token from mockPool\n        // and send back to the contract when withdraw, borrow.\n        // Set transfer portion bps to 100% as it is the default value\n        transferPortionBps = BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n    }\n\n    // Allow setting transfer portion bps for testing\n    function setTransferPortionBps(uint256 _transferPortionBps) external {\n        require(\n            _transferPortionBps <= BasisPointConstants.ONE_HUNDRED_PERCENT_BPS,\n            \"Mock: transferPortionBps must be at most 100%\"\n        );\n        transferPortionBps = _transferPortionBps;\n    }\n\n    // Allow setting mock prices for assets\n    function setMockPrice(address asset, uint256 price) external {\n        mockPrices[asset] = price;\n    }\n\n    // Allow setting mock collateral and debt for a user\n    function setMockCollateral(\n        address user,\n        address token,\n        uint256 amount\n    ) external {\n        _setMockCollateral(user, token, amount);\n    }\n    function _setMockCollateral(\n        address user,\n        address token,\n        uint256 amount\n    ) internal {\n        if (mockCollateral[user][token] == 0 && amount > 0) {\n            mockCollateralTokens[user].push(token);\n        }\n        mockCollateral[user][token] = amount;\n\n        // Remove token from array if amount becomes 0\n        if (amount == 0) {\n            for (uint256 i = 0; i < mockCollateralTokens[user].length; i++) {\n                if (mockCollateralTokens[user][i] == token) {\n                    // Replace with last element and pop\n                    mockCollateralTokens[user][i] = mockCollateralTokens[user][\n                        mockCollateralTokens[user].length - 1\n                    ];\n                    mockCollateralTokens[user].pop();\n                    break;\n                }\n            }\n        }\n    }\n\n    function setMockDebt(address user, address token, uint256 amount) external {\n        _setMockDebt(user, token, amount);\n    }\n    function _setMockDebt(\n        address user,\n        address token,\n        uint256 amount\n    ) internal {\n        if (mockDebt[user][token] == 0 && amount > 0) {\n            mockDebtTokens[user].push(token);\n        }\n        mockDebt[user][token] = amount;\n\n        // Remove token from array if amount becomes 0\n        if (amount == 0) {\n            for (uint256 i = 0; i < mockDebtTokens[user].length; i++) {\n                if (mockDebtTokens[user][i] == token) {\n                    // Replace with last element and pop\n                    mockDebtTokens[user][i] = mockDebtTokens[user][\n                        mockDebtTokens[user].length - 1\n                    ];\n                    mockDebtTokens[user].pop();\n                    break;\n                }\n            }\n        }\n    }\n\n    // Check all required allowances for mockPool to this contract\n    // so that the vault can spend tokens from mockPool\n    function _checkRequiredAllowance() internal view {\n        require(\n            ERC20(collateralToken).allowance(mockPool, address(this)) >=\n                type(uint256).max / 2,\n            \"Mock: mockPool does not have allowance for this contract for collateralToken\"\n        );\n        require(\n            ERC20(debtToken).allowance(mockPool, address(this)) >=\n                type(uint256).max / 2,\n            \"Mock: mockPool does not have allowance for this contract for debtToken\"\n        );\n    }\n\n    // --- Overrides ---\n\n    /**\n     * @inheritdoc DLoopCoreBase\n     * @return address[] Additional rescue tokens\n     */\n    function _getAdditionalRescueTokensImplementation()\n        internal\n        pure\n        override\n        returns (address[] memory)\n    {\n        return new address[](0);\n    }\n\n    function _getAssetPriceFromOracleImplementation(\n        address asset\n    ) internal view override returns (uint256) {\n        uint256 price = mockPrices[asset];\n        require(price > 0, \"Mock price not set\");\n        return price;\n    }\n\n    function _supplyToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        _checkRequiredAllowance();\n\n        // Calculate the amount to supply based on transfer portion bps\n        amount =\n            (amount * transferPortionBps) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        // Make sure target user has enough balance to supply\n        require(\n            ERC20(token).balanceOf(onBehalfOf) >= amount,\n            \"Mock: not enough balance to supply\"\n        );\n\n        if (amount > 0) {\n            // Switch between transfer and transferFrom based on the onBehalfOf\n            if (onBehalfOf == address(this)) {\n                // If the onBehalfOf is the vault itself, use transfer\n                require(\n                    ERC20(token).transfer(mockPool, amount),\n                    \"Mock: supply transfer failed (onBehalfOf is the vault itself)\"\n                );\n            } else {\n                // Transfer from target user to mockPool\n                require(\n                    ERC20(token).transferFrom(onBehalfOf, mockPool, amount),\n                    \"Mock: supply transfer failed\"\n                );\n            }\n        }\n\n        // Reset transfer portion bps to 100%\n        transferPortionBps = BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        // Increase collateral after successful transfer\n        _setMockCollateral(\n            onBehalfOf,\n            token,\n            mockCollateral[onBehalfOf][token] + amount\n        );\n    }\n    function _borrowFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        _checkRequiredAllowance();\n\n        // Calculate the amount to borrow based on transfer portion bps\n        amount =\n            (amount * transferPortionBps) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        // Make sure having mockPool having enough balance to borrow\n        require(\n            ERC20(token).balanceOf(mockPool) >= amount,\n            \"Mock: not enough tokens in pool to borrow\"\n        );\n\n        if (amount > 0) {\n            // Transfer from mockPool to target user\n            require(\n                ERC20(token).transferFrom(mockPool, onBehalfOf, amount),\n                \"Mock: borrow transfer failed\"\n            );\n        }\n\n        // Reset transfer portion bps to 100%\n        transferPortionBps = BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        // Increase debt after successful transfer\n        _setMockDebt(onBehalfOf, token, mockDebt[onBehalfOf][token] + amount);\n    }\n\n    function _repayDebtToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        _checkRequiredAllowance();\n\n        // Calculate the amount to repay based on transfer portion bps\n        amount =\n            (amount * transferPortionBps) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        // Make sure target user has enough debt to repay\n        require(\n            ERC20(token).balanceOf(onBehalfOf) >= amount,\n            \"Mock: not enough balance to repay\"\n        );\n\n        if (amount > 0) {\n            // Switch between transfer and transferFrom based on the onBehalfOf\n            if (onBehalfOf == address(this)) {\n                // If the onBehalfOf is the vault itself, use transfer\n                require(\n                    ERC20(token).transfer(mockPool, amount),\n                    \"Mock: repay transfer failed (onBehalfOf is the vault itself)\"\n                );\n            } else {\n                // Transfer from target user to mockPool\n                require(\n                    ERC20(token).transferFrom(onBehalfOf, mockPool, amount),\n                    \"Mock: repay transfer failed\"\n                );\n            }\n        }\n\n        // Reset transfer portion bps to 100%\n        transferPortionBps = BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        // Decrease debt after successful transfer\n        _setMockDebt(onBehalfOf, token, mockDebt[onBehalfOf][token] - amount);\n    }\n\n    function _withdrawFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        _checkRequiredAllowance();\n\n        // Calculate the amount to withdraw based on transfer portion bps\n        amount =\n            (amount * transferPortionBps) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        // Make sure mockPool has enough balance to withdraw\n        require(\n            ERC20(token).balanceOf(mockPool) >= amount,\n            \"Mock: not enough tokens in pool to withdraw\"\n        );\n\n        if (amount > 0) {\n            // Transfer from mockPool to target user\n            require(\n                ERC20(token).transferFrom(mockPool, onBehalfOf, amount),\n                \"Mock: withdraw transfer failed\"\n            );\n        }\n\n        // Reset transfer portion bps to 100%\n        transferPortionBps = BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        // Decrease collateral after successful transfer\n        _setMockCollateral(\n            onBehalfOf,\n            token,\n            mockCollateral[onBehalfOf][token] - amount\n        );\n    }\n\n    function getTotalCollateralAndDebtOfUserInBase(\n        address user\n    )\n        public\n        view\n        override\n        returns (uint256 totalCollateralBase, uint256 totalDebtBase)\n    {\n        totalCollateralBase = 0;\n        totalDebtBase = 0;\n\n        // Calculate total collateral in base unit (from mockCollateral)\n        // Get all users' tokens from mockCollateral[user]\n        for (uint256 i = 0; i < mockCollateralTokens[user].length; i++) {\n            address token = mockCollateralTokens[user][i];\n\n            // Convert collateral to base unit\n            uint256 price = mockPrices[token];\n            require(price > 0, \"Mock price not set\");\n            uint256 amount = mockCollateral[user][token];\n            uint256 assetTokenUnit = 10 ** ERC20(token).decimals();\n            uint256 amountInBase = (amount * price) / assetTokenUnit;\n\n            totalCollateralBase += amountInBase;\n        }\n        for (uint256 i = 0; i < mockDebtTokens[user].length; i++) {\n            address token = mockDebtTokens[user][i];\n\n            // Convert debt to base unit\n            uint256 price = mockPrices[token];\n            require(price > 0, \"Mock price not set\");\n            uint256 amount = mockDebt[user][token];\n            uint256 assetTokenUnit = 10 ** ERC20(token).decimals();\n            uint256 amountInBase = (amount * price) / assetTokenUnit;\n\n            totalDebtBase += amountInBase;\n        }\n        return (totalCollateralBase, totalDebtBase);\n    }\n\n    // --- Test-only public wrappers for internal pool logic ---\n    function testSupplyToPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        _supplyToPool(token, amount, onBehalfOf);\n    }\n    function testBorrowFromPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        _borrowFromPool(token, amount, onBehalfOf);\n    }\n    function testRepayDebtToPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        _repayDebtToPool(token, amount, onBehalfOf);\n    }\n    function testWithdrawFromPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        _withdrawFromPool(token, amount, onBehalfOf);\n    }\n\n    // --- Additional Test Wrappers for Internal Methods ---\n\n    /**\n     * @dev Test wrapper for _getAdditionalRescueTokensImplementation\n     */\n    function testGetAdditionalRescueTokensImplementation()\n        external\n        pure\n        returns (address[] memory)\n    {\n        return _getAdditionalRescueTokensImplementation();\n    }\n\n    /**\n     * @dev Test wrapper for _supplyToPoolImplementation\n     */\n    function testSupplyToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        _supplyToPoolImplementation(token, amount, onBehalfOf);\n    }\n\n    /**\n     * @dev Test wrapper for _borrowFromPoolImplementation\n     */\n    function testBorrowFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        _borrowFromPoolImplementation(token, amount, onBehalfOf);\n    }\n\n    /**\n     * @dev Test wrapper for _repayDebtToPoolImplementation\n     */\n    function testRepayDebtToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        _repayDebtToPoolImplementation(token, amount, onBehalfOf);\n    }\n\n    /**\n     * @dev Test wrapper for _withdrawFromPoolImplementation\n     */\n    function testWithdrawFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        _withdrawFromPoolImplementation(token, amount, onBehalfOf);\n    }\n\n    /**\n     * @dev Test wrapper for _getCollateralTokenAmountToReachTargetLeverage\n     */\n    function testGetCollateralTokenAmountToReachTargetLeverage(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 subsidyBps,\n        bool useVaultTokenBalance\n    ) external view returns (uint256) {\n        return\n            _getCollateralTokenAmountToReachTargetLeverage(\n                expectedTargetLeverageBps,\n                totalCollateralBase,\n                totalDebtBase,\n                subsidyBps,\n                useVaultTokenBalance\n            );\n    }\n\n    /**\n     * @dev Test wrapper for _getDebtTokenAmountToReachTargetLeverage\n     */\n    function testGetDebtTokenAmountToReachTargetLeverage(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 subsidyBps,\n        bool useVaultTokenBalance\n    ) external view returns (uint256) {\n        return\n            _getDebtTokenAmountToReachTargetLeverage(\n                expectedTargetLeverageBps,\n                totalCollateralBase,\n                totalDebtBase,\n                subsidyBps,\n                useVaultTokenBalance\n            );\n    }\n\n    /**\n     * @dev Test wrapper for _getRequiredCollateralTokenAmountToRebalance\n     */\n    function testGetRequiredCollateralTokenAmountToRebalance(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 subsidyBps,\n        uint256 additionalCollateralTokenAmount\n    ) external view returns (uint256) {\n        return\n            _getRequiredCollateralTokenAmountToRebalance(\n                expectedTargetLeverageBps,\n                totalCollateralBase,\n                totalDebtBase,\n                subsidyBps,\n                additionalCollateralTokenAmount\n            );\n    }\n\n    /**\n     * @dev Test wrapper for _getRequiredDebtTokenAmountToRebalance\n     */\n    function testGetRequiredDebtTokenAmountToRebalance(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 subsidyBps,\n        uint256 additionalDebtTokenAmount\n    ) external view returns (uint256) {\n        return\n            _getRequiredDebtTokenAmountToRebalance(\n                expectedTargetLeverageBps,\n                totalCollateralBase,\n                totalDebtBase,\n                subsidyBps,\n                additionalDebtTokenAmount\n            );\n    }\n\n    // --- Mock State Getters for Testing ---\n\n    /**\n     * @dev Get mock collateral for a user and token\n     */\n    function getMockCollateral(\n        address user,\n        address token\n    ) external view returns (uint256) {\n        return mockCollateral[user][token];\n    }\n\n    /**\n     * @dev Get mock debt for a user and token\n     */\n    function getMockDebt(\n        address user,\n        address token\n    ) external view returns (uint256) {\n        return mockDebt[user][token];\n    }\n\n    /**\n     * @dev Get all collateral tokens for a user\n     */\n    function getMockCollateralTokens(\n        address user\n    ) external view returns (address[] memory) {\n        return mockCollateralTokens[user];\n    }\n\n    /**\n     * @dev Get all debt tokens for a user\n     */\n    function getMockDebtTokens(\n        address user\n    ) external view returns (address[] memory) {\n        return mockDebtTokens[user];\n    }\n\n    /**\n     * @dev Get mock price for an asset\n     */\n    function getMockPrice(address asset) external view returns (uint256) {\n        return mockPrices[asset];\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/DLoopDecreaseLeverageBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interface/flashloan/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interface/flashloan/IERC3156FlashLender.sol\";\nimport {DLoopCoreBase} from \"../core/DLoopCoreBase.sol\";\nimport {SwappableVault} from \"contracts/common/SwappableVault.sol\";\nimport {RescuableVault} from \"contracts/common/RescuableVault.sol\";\nimport {BasisPointConstants} from \"contracts/common/BasisPointConstants.sol\";\n\n/**\n * @title DLoopDecreaseLeverageBase\n * @dev A helper contract for decreasing leverage with flash loans\n *      - Suppose the core contract current leverage is 4x, target leverage is 3x, collateral token is WETH, debt token is dUSD\n *      - User wants to decrease leverage to target (3x) but doesn't have enough debt tokens\n *      - This contract will flashloan debt tokens, call decreaseLeverage on core to get collateral tokens,\n *        swap the received collateral tokens to debt tokens, and use the debt tokens to repay the flashloan\n *      - Example: Flash loan 50,000 dUSD -> call decreaseLeverage with 50,000 dUSD -> receive 25+ WETH -> swap to 50,000+ dUSD -> repay flash loan\n */\nabstract contract DLoopDecreaseLeverageBase is\n    IERC3156FlashBorrower,\n    Ownable,\n    ReentrancyGuard,\n    SwappableVault,\n    RescuableVault\n{\n    using SafeERC20 for ERC20;\n\n    /* Constants */\n\n    bytes32 public constant FLASHLOAN_CALLBACK =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /* Core state */\n\n    IERC3156FlashLender public immutable flashLender;\n    // [dLoopCore][tokenAddress] -> leftOverAmount\n    mapping(address => mapping(address => uint256))\n        public minLeftoverCollateralTokenAmount;\n    // [tokenAddress] -> exists (for gas efficient token tracking)\n    mapping(address => bool) private _existingCollateralTokensMap;\n    address[] public existingCollateralTokens;\n\n    /* Errors */\n\n    error UnknownLender(address msgSender, address flashLender);\n    error UnknownInitiator(address initiator, address thisContract);\n    error IncompatibleDLoopCoreDebtToken(\n        address currentDebtToken,\n        address dLoopCoreDebtToken\n    );\n    error CollateralTokenBalanceNotIncreasedAfterDecreaseLeverage(\n        uint256 collateralTokenBalanceBeforeDecrease,\n        uint256 collateralTokenBalanceAfterDecrease\n    );\n    error FlashLoanAmountExceedsMaxAvailable(\n        uint256 requiredFlashLoanAmount,\n        uint256 maxFlashLoanAmount\n    );\n    error LeverageNotDecreased(\n        uint256 leverageBeforeDecrease,\n        uint256 leverageAfterDecrease\n    );\n    error ReceivedCollateralTokenNotMetMinReceiveAmount(\n        uint256 receivedCollateralTokenAmount,\n        uint256 minOutputCollateralTokenAmount\n    );\n    error FlashLenderNotSameAsDebtToken(address flashLender, address debtToken);\n\n    /* Events */\n\n    event LeftoverCollateralTokensTransferred(\n        address indexed dLoopCore,\n        address indexed collateralToken,\n        uint256 amount\n    );\n    event MinLeftoverCollateralTokenAmountSet(\n        address indexed dLoopCore,\n        address indexed collateralToken,\n        uint256 minAmount\n    );\n\n    /* Structs */\n\n    struct FlashLoanParams {\n        address user;\n        uint256 additionalDebtFromUser;\n        uint256 requiredDebtAmount;\n        bytes collateralToDebtTokenSwapData;\n        DLoopCoreBase dLoopCore;\n    }\n\n    // Struct to group decrease leverage operation state to reduce stack depth\n    struct DecreaseLeverageState {\n        uint256 leverageBeforeDecrease;\n        uint256 leverageAfterDecrease;\n        uint256 collateralTokenBalanceBeforeDecrease;\n        uint256 collateralTokenBalanceAfterDecrease;\n        uint256 requiredFlashLoanAmount;\n        uint256 debtFromUser;\n        uint256 requiredDebtFromFlashLoan;\n    }\n\n    /**\n     * @dev Constructor for the DLoopDecreaseLeverageBase contract\n     * @param _flashLender Address of the flash loan provider\n     */\n    constructor(IERC3156FlashLender _flashLender) Ownable(msg.sender) {\n        flashLender = _flashLender;\n    }\n\n    /* RescuableVault Override */\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return restrictedTokens Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens()\n        public\n        view\n        virtual\n        override\n        returns (address[] memory restrictedTokens)\n    {\n        // Return the existing tokens as we handle leftover collateral tokens\n        return existingCollateralTokens;\n    }\n\n    /* Decrease Leverage */\n\n    /**\n     * @dev Decreases leverage with flash loans\n     *      - Flash loans debt tokens, calls decreaseLeverage, swaps received collateral tokens to debt tokens, uses debt tokens to repay flash loan\n     * @param additionalDebtFromUser Additional debt token amount from user (can be 0)\n     * @param minOutputCollateralTokenAmount Minimum amount of collateral token to receive (slippage protection)\n     * @param collateralToDebtTokenSwapData Swap data from collateral token to debt token\n     * @param dLoopCore Address of the DLoopCore contract to use\n     * @return receivedCollateralTokenAmount Amount of collateral tokens received from decrease leverage operation\n     */\n    function decreaseLeverage(\n        uint256 additionalDebtFromUser,\n        uint256 minOutputCollateralTokenAmount,\n        bytes calldata collateralToDebtTokenSwapData,\n        DLoopCoreBase dLoopCore\n    ) public nonReentrant returns (uint256 receivedCollateralTokenAmount) {\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n\n        // Transfer any additional debt token from user if provided\n        if (additionalDebtFromUser > 0) {\n            debtToken.safeTransferFrom(\n                msg.sender,\n                address(this),\n                additionalDebtFromUser\n            );\n        }\n\n        // Calculate the required debt amount to reach target leverage\n        (uint256 requiredDebtAmount, int8 direction) = dLoopCore\n            .getAmountToReachTargetLeverage(true); // Use vault token balance\n\n        // Verify we need to decrease leverage\n        if (direction != -1) {\n            revert(\"Current leverage is already at or below target\");\n        }\n\n        // Use struct to group related variables and reduce stack depth\n        DecreaseLeverageState memory state;\n\n        // Calculate how much we need from flash loan\n        state.debtFromUser =\n            additionalDebtFromUser +\n            debtToken.balanceOf(address(this));\n        if (requiredDebtAmount > state.debtFromUser) {\n            state.requiredDebtFromFlashLoan =\n                requiredDebtAmount -\n                state.debtFromUser;\n\n            // Check if flash loan amount is available\n            uint256 maxFlashLoanAmount = flashLender.maxFlashLoan(\n                address(debtToken)\n            );\n            if (state.requiredDebtFromFlashLoan > maxFlashLoanAmount) {\n                revert FlashLoanAmountExceedsMaxAvailable(\n                    state.requiredDebtFromFlashLoan,\n                    maxFlashLoanAmount\n                );\n            }\n\n            // Create flash loan params\n            FlashLoanParams memory params = FlashLoanParams(\n                msg.sender,\n                additionalDebtFromUser,\n                requiredDebtAmount,\n                collateralToDebtTokenSwapData,\n                dLoopCore\n            );\n            bytes memory data = _encodeParamsToData(params);\n\n            // Record initial leverage\n            state.leverageBeforeDecrease = dLoopCore.getCurrentLeverageBps();\n\n            // This value is used to check if the collateral token balance increased after decrease leverage\n            state.collateralTokenBalanceBeforeDecrease = collateralToken\n                .balanceOf(address(this));\n\n            // Approve flash lender to spend debt tokens for repayment\n            debtToken.forceApprove(\n                address(flashLender),\n                state.requiredDebtFromFlashLoan +\n                    flashLender.flashFee(\n                        address(debtToken),\n                        state.requiredDebtFromFlashLoan\n                    )\n            );\n\n            // Make sure the flashLender is the same as the debt token\n            if (address(flashLender) != address(debtToken)) {\n                revert FlashLenderNotSameAsDebtToken(\n                    address(flashLender),\n                    address(debtToken)\n                );\n            }\n\n            // Execute flash loan - main logic in onFlashLoan\n            flashLender.flashLoan(\n                this,\n                address(debtToken),\n                state.requiredDebtFromFlashLoan,\n                data\n            );\n\n            // Verify leverage decreased\n            state.leverageAfterDecrease = dLoopCore.getCurrentLeverageBps();\n            if (state.leverageAfterDecrease >= state.leverageBeforeDecrease) {\n                revert LeverageNotDecreased(\n                    state.leverageBeforeDecrease,\n                    state.leverageAfterDecrease\n                );\n            }\n\n            // Calculate received collateral tokens\n            state.collateralTokenBalanceAfterDecrease = collateralToken\n                .balanceOf(address(this));\n            if (\n                state.collateralTokenBalanceAfterDecrease <=\n                state.collateralTokenBalanceBeforeDecrease\n            ) {\n                revert CollateralTokenBalanceNotIncreasedAfterDecreaseLeverage(\n                    state.collateralTokenBalanceBeforeDecrease,\n                    state.collateralTokenBalanceAfterDecrease\n                );\n            }\n\n            receivedCollateralTokenAmount =\n                state.collateralTokenBalanceAfterDecrease -\n                state.collateralTokenBalanceBeforeDecrease;\n        } else {\n            // No flash loan needed, direct decrease leverage\n            state.leverageBeforeDecrease = dLoopCore.getCurrentLeverageBps();\n            state.collateralTokenBalanceBeforeDecrease = collateralToken\n                .balanceOf(address(this));\n\n            // Approve debt token for core contract\n            debtToken.forceApprove(address(dLoopCore), state.debtFromUser);\n\n            // Call decrease leverage directly\n            dLoopCore.decreaseLeverage(\n                additionalDebtFromUser,\n                minOutputCollateralTokenAmount\n            );\n\n            // Verify leverage decreased\n            state.leverageAfterDecrease = dLoopCore.getCurrentLeverageBps();\n            if (state.leverageAfterDecrease >= state.leverageBeforeDecrease) {\n                revert LeverageNotDecreased(\n                    state.leverageBeforeDecrease,\n                    state.leverageAfterDecrease\n                );\n            }\n\n            // Calculate received collateral tokens\n            state.collateralTokenBalanceAfterDecrease = collateralToken\n                .balanceOf(address(this));\n            if (\n                state.collateralTokenBalanceAfterDecrease <=\n                state.collateralTokenBalanceBeforeDecrease\n            ) {\n                revert CollateralTokenBalanceNotIncreasedAfterDecreaseLeverage(\n                    state.collateralTokenBalanceBeforeDecrease,\n                    state.collateralTokenBalanceAfterDecrease\n                );\n            }\n\n            receivedCollateralTokenAmount =\n                state.collateralTokenBalanceAfterDecrease -\n                state.collateralTokenBalanceBeforeDecrease;\n        }\n\n        // Slippage protection\n        if (receivedCollateralTokenAmount < minOutputCollateralTokenAmount) {\n            revert ReceivedCollateralTokenNotMetMinReceiveAmount(\n                receivedCollateralTokenAmount,\n                minOutputCollateralTokenAmount\n            );\n        }\n\n        // Handle any leftover collateral tokens\n        uint256 leftoverAmount = collateralToken.balanceOf(address(this));\n        if (\n            leftoverAmount >\n            minLeftoverCollateralTokenAmount[address(dLoopCore)][\n                address(collateralToken)\n            ]\n        ) {\n            collateralToken.safeTransfer(address(dLoopCore), leftoverAmount);\n            emit LeftoverCollateralTokensTransferred(\n                address(dLoopCore),\n                address(collateralToken),\n                leftoverAmount\n            );\n        }\n\n        // Transfer received collateral tokens to user\n        collateralToken.safeTransfer(msg.sender, receivedCollateralTokenAmount);\n\n        return receivedCollateralTokenAmount;\n    }\n\n    /* Flash loan entrypoint */\n\n    /**\n     * @dev Callback function for flash loans\n     * @param initiator Address that initiated the flash loan\n     * @param token Address of the flash-borrowed token\n     * @param fee Flash loan fee\n     * @param data Additional data passed to the flash loan\n     * @return bytes32 The flash loan callback success bytes\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256, // amount (flash loan amount)\n        uint256 fee,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        // This function does not need nonReentrant as the flash loan will be called by decreaseLeverage() public\n        // function, which is already protected by nonReentrant\n        // Moreover, this function is only be able to be called by the address(this) (check the initiator condition)\n        // thus even though the flash loan is public and not protected by nonReentrant, it is still safe\n        if (msg.sender != address(flashLender))\n            revert UnknownLender(msg.sender, address(flashLender));\n        if (initiator != address(this))\n            revert UnknownInitiator(initiator, address(this));\n\n        // Decode flash loan params\n        FlashLoanParams memory flashLoanParams = _decodeDataToParams(data);\n        DLoopCoreBase dLoopCore = flashLoanParams.dLoopCore;\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n\n        // Verify token compatibility\n        if (token != address(debtToken))\n            revert IncompatibleDLoopCoreDebtToken(token, address(debtToken));\n\n        // Record collateral token balance before decrease leverage\n        uint256 collateralTokenBalanceBeforeDecrease = collateralToken\n            .balanceOf(address(this));\n\n        // Approve debt for core contract\n        debtToken.forceApprove(\n            address(dLoopCore),\n            flashLoanParams.requiredDebtAmount\n        );\n\n        // Call decrease leverage on core contract\n        dLoopCore.decreaseLeverage(\n            flashLoanParams.additionalDebtFromUser,\n            0 // No min amount check here, will be checked in main function\n        );\n\n        // Verify we received collateral tokens\n        uint256 collateralTokenBalanceAfterDecrease = collateralToken.balanceOf(\n            address(this)\n        );\n        if (\n            collateralTokenBalanceAfterDecrease <=\n            collateralTokenBalanceBeforeDecrease\n        ) {\n            revert CollateralTokenBalanceNotIncreasedAfterDecreaseLeverage(\n                collateralTokenBalanceBeforeDecrease,\n                collateralTokenBalanceAfterDecrease\n            );\n        }\n\n        // Swap collateral tokens to debt tokens to repay flash loan\n        uint256 requiredDebtFromFlashLoan = flashLoanParams.requiredDebtAmount -\n            flashLoanParams.additionalDebtFromUser -\n            debtToken.balanceOf(address(this));\n\n        _swapExactOutput(\n            collateralToken,\n            debtToken,\n            requiredDebtFromFlashLoan + fee,\n            type(uint256).max, // No slippage protection here\n            address(this),\n            block.timestamp,\n            flashLoanParams.collateralToDebtTokenSwapData\n        );\n\n        return FLASHLOAN_CALLBACK;\n    }\n\n    /* Setters */\n\n    /**\n     * @dev Sets the minimum leftover collateral token amount for a given dLoopCore and collateral token\n     * @param dLoopCore Address of the dLoopCore contract\n     * @param collateralToken Address of the collateral token\n     * @param minAmount Minimum leftover collateral token amount for the given dLoopCore and collateral token\n     */\n    function setMinLeftoverCollateralTokenAmount(\n        address dLoopCore,\n        address collateralToken,\n        uint256 minAmount\n    ) external nonReentrant onlyOwner {\n        minLeftoverCollateralTokenAmount[dLoopCore][\n            collateralToken\n        ] = minAmount;\n        if (!_existingCollateralTokensMap[collateralToken]) {\n            _existingCollateralTokensMap[collateralToken] = true;\n            existingCollateralTokens.push(collateralToken);\n        }\n        emit MinLeftoverCollateralTokenAmountSet(\n            dLoopCore,\n            collateralToken,\n            minAmount\n        );\n    }\n\n    /* Data encoding/decoding helpers */\n\n    /**\n     * @dev Encodes flash loan parameters to data\n     * @param _flashLoanParams Flash loan parameters\n     * @return data Encoded data\n     */\n    function _encodeParamsToData(\n        FlashLoanParams memory _flashLoanParams\n    ) internal pure returns (bytes memory data) {\n        data = abi.encode(\n            _flashLoanParams.user,\n            _flashLoanParams.additionalDebtFromUser,\n            _flashLoanParams.requiredDebtAmount,\n            _flashLoanParams.collateralToDebtTokenSwapData,\n            _flashLoanParams.dLoopCore\n        );\n    }\n\n    /**\n     * @dev Decodes data to flash loan parameters\n     * @param data Encoded data\n     * @return _flashLoanParams Decoded flash loan parameters\n     */\n    function _decodeDataToParams(\n        bytes memory data\n    ) internal pure returns (FlashLoanParams memory _flashLoanParams) {\n        (\n            _flashLoanParams.user,\n            _flashLoanParams.additionalDebtFromUser,\n            _flashLoanParams.requiredDebtAmount,\n            _flashLoanParams.collateralToDebtTokenSwapData,\n            _flashLoanParams.dLoopCore\n        ) = abi.decode(data, (address, uint256, uint256, bytes, DLoopCoreBase));\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/DLoopDepositorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interface/flashloan/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interface/flashloan/IERC3156FlashLender.sol\";\nimport {DLoopCoreBase} from \"../core/DLoopCoreBase.sol\";\nimport {SwappableVault} from \"contracts/common/SwappableVault.sol\";\nimport {RescuableVault} from \"contracts/common/RescuableVault.sol\";\nimport {BasisPointConstants} from \"contracts/common/BasisPointConstants.sol\";\n\n/**\n * @title DLoopDepositorBase\n * @dev A helper contract for depositing leveraged assets into the core vault with flash loans\n *      - Suppose that the core contract has leverage of 3x, and the collateral token is WETH, debt token is dUSD, price of WETH is 1000, price of dUSD is 2000\n *      - ie, given user has 100 WETH, and wants to deposit 300 WETH, this contract will do a flash loan to get 200 * 2000 dUSD, then swap to get 200 WETH\n *        and then deposit totally 200+100=300 WETH into the core vault, then user receive 300 shares. The contract uses the received 200 * 2000 dUSD\n *        to repay the flash loan.\n *      - In the final state, the user has 300 shares representing 300 WETH, and the core contract has 300 WETH as collateral, 200 dUSD as debt\n *      - NOTE: This contract only support deposit() to DLoopCore contracts, not mint()\n */\nabstract contract DLoopDepositorBase is\n    IERC3156FlashBorrower,\n    Ownable,\n    ReentrancyGuard,\n    SwappableVault,\n    RescuableVault\n{\n    using SafeERC20 for ERC20;\n\n    /* Constants */\n\n    bytes32 public constant FLASHLOAN_CALLBACK =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /* Core state */\n\n    IERC3156FlashLender public immutable flashLender;\n    // [dLoopCore][tokenAddress] -> leftOverAmount\n    mapping(address => mapping(address => uint256))\n        public minLeftoverDebtTokenAmount;\n    // [tokenAddress] -> exists (for gas efficient token tracking)\n    mapping(address => bool) private _existingDebtTokensMap;\n    address[] public existingDebtTokens;\n\n    /* Errors */\n\n    error UnknownLender(address msgSender, address flashLender);\n    error UnknownInitiator(address initiator, address thisContract);\n    error IncompatibleDLoopCoreDebtToken(\n        address currentDebtToken,\n        address dLoopCoreDebtToken\n    );\n    error SharesNotIncreasedAfterFlashLoan(\n        uint256 sharesBeforeDeposit,\n        uint256 sharesAfterDeposit\n    );\n    error DebtTokenBalanceNotIncreasedAfterDeposit(\n        uint256 debtTokenBalanceBeforeDeposit,\n        uint256 debtTokenBalanceAfterDeposit\n    );\n    error ReceivedSharesNotMetMinReceiveAmount(\n        uint256 receivedShares,\n        uint256 minOutputShares\n    );\n    error DebtTokenReceivedNotMetUsedAmountWithFlashLoanFee(\n        uint256 debtTokenReceived,\n        uint256 debtTokenUsed,\n        uint256 flashLoanFee\n    );\n    error LeveragedCollateralAmountLessThanDepositCollateralAmount(\n        uint256 leveragedCollateralAmount,\n        uint256 depositCollateralAmount\n    );\n    error EstimatedSharesLessThanMinOutputShares(\n        uint256 currentEstimatedShares,\n        uint256 minOutputShares\n    );\n    error EstimatedOverallSlippageBpsCannotExceedOneHundredPercent(\n        uint256 estimatedOverallSlippageBps\n    );\n    error FlashLenderNotSameAsDebtToken(address flashLender, address debtToken);\n    error SlippageBpsCannotExceedOneHundredPercent(uint256 slippageBps);\n\n    /* Events */\n\n    event LeftoverDebtTokensTransferred(\n        address indexed dLoopCore,\n        address indexed debtToken,\n        uint256 amount\n    );\n    event MinLeftoverDebtTokenAmountSet(\n        address indexed dLoopCore,\n        address indexed debtToken,\n        uint256 minAmount\n    );\n\n    /* Structs */\n\n    struct FlashLoanParams {\n        address receiver;\n        uint256 depositCollateralAmount;\n        uint256 leveragedCollateralAmount;\n        bytes debtTokenToCollateralSwapData;\n        DLoopCoreBase dLoopCore;\n    }\n\n    /**\n     * @dev Constructor for the DLoopDepositorBase contract\n     * @param _flashLender Address of the flash loan provider\n     */\n    constructor(IERC3156FlashLender _flashLender) Ownable(msg.sender) {\n        flashLender = _flashLender;\n    }\n\n    /* RescuableVault Override */\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return restrictedTokens Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens()\n        public\n        view\n        virtual\n        override\n        returns (address[] memory restrictedTokens)\n    {\n        // Return the existing tokens as we handle leftover debt tokens\n        return existingDebtTokens;\n    }\n\n    /* Deposit */\n\n    /**\n     * @dev Calculates the minimum output shares for a given deposit amount and slippage bps\n     * @param depositAmount Amount of collateral token to deposit\n     * @param slippageBps Slippage bps\n     * @param dLoopCore Address of the DLoopCore contract\n     * @return minOutputShares Minimum output shares\n     */\n    function calculateMinOutputShares(\n        uint256 depositAmount,\n        uint256 slippageBps,\n        DLoopCoreBase dLoopCore\n    ) public view returns (uint256) {\n        if (slippageBps > BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert SlippageBpsCannotExceedOneHundredPercent(slippageBps);\n        }\n        uint256 expectedLeveragedAssets = dLoopCore.getLeveragedAssets(\n            depositAmount\n        );\n        uint256 expectedShares = dLoopCore.convertToShares(\n            expectedLeveragedAssets\n        );\n        return\n            (expectedShares *\n                (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS - slippageBps)) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n    }\n\n    /**\n     * @dev Calculates the estimated overall slippage bps\n     * @param currentEstimatedShares Current estimated shares\n     * @param minOutputShares Minimum output shares\n     * @return estimatedOverallSlippageBps Estimated overall slippage bps\n     */\n    function _calculateEstimatedOverallSlippageBps(\n        uint256 currentEstimatedShares,\n        uint256 minOutputShares\n    ) internal pure returns (uint256) {\n        /*\n         * According to the formula in getBorrowAmountThatKeepCurrentLeverage() of DLoopCoreBase,\n         * we have:\n         *      y = x * (T-1)/T\n         *  and\n         *      y = x * (T' - ONE_HUNDRED_PERCENT_BPS) / T'\n         *  and\n         *      T' = T * ONE_HUNDRED_PERCENT_BPS\n         * where:\n         *      - T: target leverage\n         *      - T': target leverage in basis points unit\n         *      - x: supply amount in base currency\n         *      - y: borrow amount in base currency\n         *\n         * We have:\n         *      x = (d + f) * (1 - s)\n         *   => y = (d + f) * (1 - s) * (T-1) / T\n         * where:\n         *      - d is the user's deposit collateral amount (original deposit amount) in base currency\n         *      - f is the flash loan amount of debt token in base currency\n         *      - s is the swap slippage (0.01 means 1%)\n         *\n         * We want find what is the condition of f so that we can borrow the debt token\n         * which is sufficient to cover up the flash loan amount. We want:\n         *      y >= f\n         *  <=> (d+f) * (1-s) * (T-1) / T >= f\n         *  <=> (d+f) * (1-s) * (T-1) >= T*f\n         *  <=> d * (1-s) * (T-1) >= T*f - f * (1-s) * (T-1)\n         *  <=> d * (1-s) * (T-1) >= f * (T - (1-s) * (T-1))\n         *  <=> (d * (1-s) * (T-1)) / (T - (1-s) * (T-1)) >= f    (as the denominator is greater than 0)\n         *  <=> f <= (d * (1-s) * (T-1)) / (T - (1-s) * (T-1))\n         *  <=> f <= (d * (1-s) * (T-1)) / (T - T + 1 + T*s - s)\n         *  <=> f <= (d * (1-s) * (T-1)) / (1 + T*s - s)\n         *\n         * Based on the above inequation, it means we can just adjust the flashloan amount to make\n         * sure the flashloan can be covered by the borrow amount.\n         *\n         * Thus, just need to infer the estimated slippage based on the provided min output shares\n         * and the current estimated shares\n         */\n        if (currentEstimatedShares < minOutputShares) {\n            revert EstimatedSharesLessThanMinOutputShares(\n                currentEstimatedShares,\n                minOutputShares\n            );\n        }\n        return\n            ((currentEstimatedShares - minOutputShares) *\n                (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS)) /\n            currentEstimatedShares;\n    }\n\n    /**\n     * @dev Deposits assets into the core vault with flash loans\n     *      - The required collateral token to reeach the leveraged amount will be flash loaned from the flash lender\n     * @param assets Amount of assets to deposit\n     * @param receiver Address to receive the minted shares\n     * @param minOutputShares Minimum amount of shares to receive (slippage protection)\n     * @param debtTokenToCollateralSwapData Swap data from debt token to collateral token\n     * @param dLoopCore Address of the DLoopCore contract to use\n     * @return shares Amount of shares minted\n     */\n    function deposit(\n        uint256 assets, // deposit amount\n        address receiver,\n        uint256 minOutputShares,\n        bytes calldata debtTokenToCollateralSwapData,\n        DLoopCoreBase dLoopCore\n    ) public nonReentrant returns (uint256 shares) {\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n\n        // Transfer the collateral token to the vault (need the allowance before calling this function)\n        // The remaining amount of collateral token will be flash loaned from the flash lender\n        // to reach the leveraged amount\n        collateralToken.safeTransferFrom(msg.sender, address(this), assets);\n\n        // Calculate the estimated overall slippage bps\n        uint256 estimatedOverallSlippageBps = _calculateEstimatedOverallSlippageBps(\n                dLoopCore.convertToShares(dLoopCore.getLeveragedAssets(assets)),\n                minOutputShares\n            );\n\n        // Make sure the estimated overall slippage bps does not exceed 100%\n        if (\n            estimatedOverallSlippageBps >\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS\n        ) {\n            revert EstimatedOverallSlippageBpsCannotExceedOneHundredPercent(\n                estimatedOverallSlippageBps\n            );\n        }\n\n        // Calculate the leveraged collateral amount to deposit with slippage included\n        // Explained with formula in _calculateEstimatedOverallSlippageBps()\n        uint256 leveragedCollateralAmount = (dLoopCore.getLeveragedAssets(\n            assets\n        ) *\n            (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS -\n                estimatedOverallSlippageBps)) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        // Create the flash loan params data\n        FlashLoanParams memory params = FlashLoanParams(\n            receiver,\n            assets,\n            leveragedCollateralAmount,\n            debtTokenToCollateralSwapData,\n            dLoopCore\n        );\n        bytes memory data = _encodeParamsToData(params);\n        uint256 maxFlashLoanAmount = flashLender.maxFlashLoan(\n            address(debtToken)\n        );\n\n        // This value is used to check if the shares increased after the flash loan\n        uint256 sharesBeforeDeposit = dLoopCore.balanceOf(address(this));\n\n        // Approve the flash lender to spend the flash loan amount of debt token from this contract\n        ERC20(debtToken).forceApprove(\n            address(flashLender),\n            maxFlashLoanAmount +\n                flashLender.flashFee(address(debtToken), maxFlashLoanAmount)\n        );\n\n        // Make sure the flashLender is the same as the debt token\n        if (address(flashLender) != address(debtToken)) {\n            revert FlashLenderNotSameAsDebtToken(\n                address(flashLender),\n                address(debtToken)\n            );\n        }\n\n        // The main logic will be done in the onFlashLoan function\n        flashLender.flashLoan(\n            this,\n            address(debtToken),\n            maxFlashLoanAmount,\n            data\n        );\n\n        // The received debt token after deposit was used to repay the flash loan\n\n        // Check if the shares increased after the flash loan\n        uint256 sharesAfterDeposit = dLoopCore.balanceOf(address(this));\n        if (sharesAfterDeposit <= sharesBeforeDeposit) {\n            revert SharesNotIncreasedAfterFlashLoan(\n                sharesBeforeDeposit,\n                sharesAfterDeposit\n            );\n        }\n\n        // Finalize deposit and transfer shares\n        return\n            _finalizeDepositAndTransfer(\n                dLoopCore,\n                debtToken,\n                receiver,\n                sharesBeforeDeposit,\n                sharesAfterDeposit,\n                minOutputShares\n            );\n    }\n\n    /* Flash loan entrypoint */\n\n    /**\n     * @dev Callback function for flash loans\n     * @param initiator Address that initiated the flash loan\n     * @param token Address of the flash-borrowed token\n     * @param data Additional data passed to the flash loan\n     * @return bytes32 The flash loan callback success bytes\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256, // amount (flash loan amount)\n        uint256 flashLoanFee, // fee (flash loan fee)\n        bytes calldata data\n    ) external override returns (bytes32) {\n        // This function does not need nonReentrant as the flash loan will be called by deposit() public\n        // function, which is already protected by nonReentrant\n        // Moreover, this function is only be able to be called by the address(this) (check the initiator condition)\n        // thus even though the flash loan is public and not protected by nonReentrant, it is still safe\n        if (msg.sender != address(flashLender))\n            revert UnknownLender(msg.sender, address(flashLender));\n        if (initiator != address(this))\n            revert UnknownInitiator(initiator, address(this));\n\n        // Decode the flash loan params data\n        FlashLoanParams memory flashLoanParams = _decodeDataToParams(data);\n        DLoopCoreBase dLoopCore = flashLoanParams.dLoopCore;\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n\n        // Make sure the input dLoopCore is compatible with this periphery contract\n        if (token != address(debtToken))\n            revert IncompatibleDLoopCoreDebtToken(token, address(debtToken));\n\n        // Calculate and validate the required additional collateral amount\n        uint256 requiredAdditionalCollateralAmount = _calculateRequiredAdditionalCollateral(\n                flashLoanParams\n            );\n\n        /**\n         * Swap the flash loan debt token to the collateral token\n         *\n         * Slippage protection is not needed here as the debt token to be used\n         * is from flash loan, which is required to repay the flash loan later\n         * Otherwise, the flash loan will be reverted\n         */\n        uint256 debtTokenAmountUsedInSwap = _swapExactOutput(\n            debtToken,\n            collateralToken,\n            requiredAdditionalCollateralAmount, // exact output amount\n            type(uint256).max, // no slippage protection\n            address(this),\n            block.timestamp,\n            flashLoanParams.debtTokenToCollateralSwapData\n        );\n\n        // Execute deposit and validate debt token received\n        _executeDepositAndValidate(\n            flashLoanParams,\n            collateralToken,\n            debtToken,\n            debtTokenAmountUsedInSwap,\n            flashLoanFee\n        );\n\n        // Return the success bytes\n        return FLASHLOAN_CALLBACK;\n    }\n\n    /* Setters */\n\n    /**\n     * @dev Sets the minimum leftover debt token amount for a given dLoopCore and debt token\n     * @param dLoopCore Address of the dLoopCore contract\n     * @param debtToken Address of the debt token\n     * @param minAmount Minimum leftover debt token amount for the given dLoopCore and debt token\n     */\n    function setMinLeftoverDebtTokenAmount(\n        address dLoopCore,\n        address debtToken,\n        uint256 minAmount\n    ) external nonReentrant onlyOwner {\n        minLeftoverDebtTokenAmount[dLoopCore][debtToken] = minAmount;\n        if (!_existingDebtTokensMap[debtToken]) {\n            _existingDebtTokensMap[debtToken] = true;\n            existingDebtTokens.push(debtToken);\n        }\n        emit MinLeftoverDebtTokenAmountSet(dLoopCore, debtToken, minAmount);\n    }\n\n    /* Internal helpers */\n\n    /**\n     * @dev Handles leftover debt tokens by transferring them to the dLoopCore contract if above minimum threshold\n     * @param dLoopCore The dLoopCore contract\n     * @param debtToken The debt token to handle\n     */\n    function _handleLeftoverDebtTokens(\n        DLoopCoreBase dLoopCore,\n        ERC20 debtToken\n    ) internal {\n        uint256 leftoverAmount = debtToken.balanceOf(address(this));\n        if (\n            leftoverAmount >\n            minLeftoverDebtTokenAmount[address(dLoopCore)][address(debtToken)]\n        ) {\n            // Transfer any leftover debt tokens to the core contract\n            debtToken.safeTransfer(address(dLoopCore), leftoverAmount);\n            emit LeftoverDebtTokensTransferred(\n                address(dLoopCore),\n                address(debtToken),\n                leftoverAmount\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates and validates the required additional collateral amount\n     * @param flashLoanParams Flash loan parameters\n     * @return requiredAdditionalCollateralAmount The required additional collateral amount\n     */\n    function _calculateRequiredAdditionalCollateral(\n        FlashLoanParams memory flashLoanParams\n    ) internal pure returns (uint256 requiredAdditionalCollateralAmount) {\n        // Calculate the required additional collateral amount to reach the leveraged amount\n        // and make sure the overall slippage is included, which is to make sure the output\n        // shares can be at least the min output shares (proven with formula)\n        if (\n            flashLoanParams.leveragedCollateralAmount <\n            flashLoanParams.depositCollateralAmount\n        ) {\n            revert LeveragedCollateralAmountLessThanDepositCollateralAmount(\n                flashLoanParams.leveragedCollateralAmount,\n                flashLoanParams.depositCollateralAmount\n            );\n        }\n        requiredAdditionalCollateralAmount = (flashLoanParams\n            .leveragedCollateralAmount -\n            flashLoanParams.depositCollateralAmount);\n    }\n\n    /**\n     * @dev Executes deposit to dLoop core and validates debt token received\n     * @param flashLoanParams Flash loan parameters\n     * @param collateralToken The collateral token\n     * @param debtToken The debt token\n     * @param debtTokenAmountUsedInSwap Amount of debt token used in swap\n     * @param flashLoanFee Flash loan fee\n     */\n    function _executeDepositAndValidate(\n        FlashLoanParams memory flashLoanParams,\n        ERC20 collateralToken,\n        ERC20 debtToken,\n        uint256 debtTokenAmountUsedInSwap,\n        uint256 flashLoanFee\n    ) internal {\n        // This value is used to check if the debt token balance increased after the deposit\n        uint256 debtTokenBalanceBeforeDeposit = debtToken.balanceOf(\n            address(this)\n        );\n\n        /**\n         * Deposit the collateral token to the core vault\n         *\n         * The receiver is this periphery contract as the core contract will send both debt token and\n         * the minted shares to the receiver. This contract needs the debt token to repay the flash loan.\n         *\n         * The minted shares will be sent to the receiver later (outside of the flash loan callback)\n         */\n        collateralToken.forceApprove(\n            address(flashLoanParams.dLoopCore),\n            flashLoanParams.leveragedCollateralAmount\n        );\n        flashLoanParams.dLoopCore.deposit(\n            flashLoanParams.leveragedCollateralAmount,\n            address(this)\n        );\n\n        // Debt token balance after deposit, which is used to sanity check the debt token balance increased after the deposit\n        uint256 debtTokenBalanceAfterDeposit = debtToken.balanceOf(\n            address(this)\n        );\n\n        // Make sure to receive the debt token from the core vault to repay the flash loan\n        if (debtTokenBalanceAfterDeposit <= debtTokenBalanceBeforeDeposit) {\n            revert DebtTokenBalanceNotIncreasedAfterDeposit(\n                debtTokenBalanceBeforeDeposit,\n                debtTokenBalanceAfterDeposit\n            );\n        }\n\n        // Calculate the debt token received after the deposit\n        uint256 debtTokenReceivedAfterDeposit = debtTokenBalanceAfterDeposit -\n            debtTokenBalanceBeforeDeposit;\n\n        // Make sure the debt token received after the deposit is not less than the debt token used in the swap\n        // to allow repaying the flash loan\n        if (\n            debtTokenReceivedAfterDeposit <\n            debtTokenAmountUsedInSwap + flashLoanFee\n        ) {\n            revert DebtTokenReceivedNotMetUsedAmountWithFlashLoanFee(\n                debtTokenReceivedAfterDeposit,\n                debtTokenAmountUsedInSwap,\n                flashLoanFee\n            );\n        }\n    }\n\n    /**\n     * @dev Finalizes deposit by validating shares and transferring to receiver\n     * @param dLoopCore The dLoopCore contract\n     * @param debtToken The debt token\n     * @param receiver Address to receive the shares\n     * @param sharesBeforeDeposit Shares before deposit\n     * @param sharesAfterDeposit Shares after deposit\n     * @param minOutputShares Minimum output shares for slippage protection\n     * @return shares Amount of shares minted\n     */\n    function _finalizeDepositAndTransfer(\n        DLoopCoreBase dLoopCore,\n        ERC20 debtToken,\n        address receiver,\n        uint256 sharesBeforeDeposit,\n        uint256 sharesAfterDeposit,\n        uint256 minOutputShares\n    ) internal returns (uint256 shares) {\n        /**\n         * Make sure the shares minted is not less than the minimum output shares\n         * for slippage protection\n         *\n         * We only perform slippage protection outside of the flash loan callback\n         * as we only need to care about the last state after the flash loan\n         */\n        shares = sharesAfterDeposit - sharesBeforeDeposit;\n        if (shares < minOutputShares) {\n            revert ReceivedSharesNotMetMinReceiveAmount(\n                shares,\n                minOutputShares\n            );\n        }\n\n        // There is no leftover collateral token, as all swapped collateral token\n        // (using flash loaned debt token) is used to deposit to the core contract\n\n        // Handle any leftover debt tokens and transfer them to the dLoopCore contract\n        _handleLeftoverDebtTokens(dLoopCore, debtToken);\n\n        // Transfer the minted shares to the receiver\n        SafeERC20.safeTransfer(dLoopCore, receiver, shares);\n    }\n\n    /* Data encoding/decoding helpers */\n\n    /**\n     * @dev Encodes flash loan parameters to data\n     * @param _flashLoanParams Flash loan parameters\n     * @return data Encoded data\n     */\n    function _encodeParamsToData(\n        FlashLoanParams memory _flashLoanParams\n    ) internal pure returns (bytes memory data) {\n        data = abi.encode(\n            _flashLoanParams.receiver,\n            _flashLoanParams.depositCollateralAmount,\n            _flashLoanParams.leveragedCollateralAmount,\n            _flashLoanParams.debtTokenToCollateralSwapData,\n            _flashLoanParams.dLoopCore\n        );\n    }\n\n    /**\n     * @dev Decodes data to flash loan deposit parameters\n     * @param data Encoded data\n     * @return _flashLoanParams Decoded flash loan parameters\n     */\n    function _decodeDataToParams(\n        bytes memory data\n    ) internal pure returns (FlashLoanParams memory _flashLoanParams) {\n        (\n            _flashLoanParams.receiver,\n            _flashLoanParams.depositCollateralAmount,\n            _flashLoanParams.leveragedCollateralAmount,\n            _flashLoanParams.debtTokenToCollateralSwapData,\n            _flashLoanParams.dLoopCore\n        ) = abi.decode(data, (address, uint256, uint256, bytes, DLoopCoreBase));\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/DLoopIncreaseLeverageBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interface/flashloan/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interface/flashloan/IERC3156FlashLender.sol\";\nimport {DLoopCoreBase} from \"../core/DLoopCoreBase.sol\";\nimport {SwappableVault} from \"contracts/common/SwappableVault.sol\";\nimport {RescuableVault} from \"contracts/common/RescuableVault.sol\";\nimport {BasisPointConstants} from \"contracts/common/BasisPointConstants.sol\";\n\n/**\n * @title DLoopIncreaseLeverageBase\n * @dev A helper contract for increasing leverage with flash loans\n *      - Suppose the core contract current leverage is 2x, target leverage is 3x, collateral token is WETH, debt token is dUSD\n *      - User wants to increase leverage to target (3x) but doesn't have enough collateral tokens\n *      - This contract will flashloan debt tokens, swap them to collateral tokens, call increaseLeverage on core,\n *        and use the received debt tokens to repay the flashloan\n *      - Example: Flash loan 50,000 dUSD -> swap to 25 WETH -> call increaseLeverage with 25 WETH -> receive 50,000+ dUSD -> repay flash loan\n */\nabstract contract DLoopIncreaseLeverageBase is\n    IERC3156FlashBorrower,\n    Ownable,\n    ReentrancyGuard,\n    SwappableVault,\n    RescuableVault\n{\n    using SafeERC20 for ERC20;\n\n    /* Constants */\n\n    bytes32 public constant FLASHLOAN_CALLBACK =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /* Core state */\n\n    IERC3156FlashLender public immutable flashLender;\n    // [dLoopCore][tokenAddress] -> leftOverAmount\n    mapping(address => mapping(address => uint256))\n        public minLeftoverDebtTokenAmount;\n    // [tokenAddress] -> exists (for gas efficient token tracking)\n    mapping(address => bool) private _existingDebtTokensMap;\n    address[] public existingDebtTokens;\n\n    /* Errors */\n\n    error UnknownLender(address msgSender, address flashLender);\n    error UnknownInitiator(address initiator, address thisContract);\n    error IncompatibleDLoopCoreDebtToken(\n        address currentDebtToken,\n        address dLoopCoreDebtToken\n    );\n    error DebtTokenBalanceNotIncreasedAfterIncreaseLeverage(\n        uint256 debtTokenBalanceBeforeIncrease,\n        uint256 debtTokenBalanceAfterIncrease\n    );\n    error DebtTokenReceivedNotMetUsedAmountWithFlashLoanFee(\n        uint256 debtTokenReceived,\n        uint256 debtTokenUsed,\n        uint256 flashLoanFee\n    );\n    error RequiredCollateralAmountExceedsUserBalance(\n        uint256 requiredCollateralAmount,\n        uint256 userCollateralBalance,\n        uint256 additionalCollateralFromUser\n    );\n    error FlashLoanAmountExceedsMaxAvailable(\n        uint256 requiredFlashLoanAmount,\n        uint256 maxFlashLoanAmount\n    );\n    error LeverageNotIncreased(\n        uint256 leverageBeforeIncrease,\n        uint256 leverageAfterIncrease\n    );\n    error ReceivedDebtTokenNotMetMinReceiveAmount(\n        uint256 receivedDebtTokenAmount,\n        uint256 minOutputDebtTokenAmount\n    );\n    error FlashLenderNotSameAsDebtToken(address flashLender, address debtToken);\n\n    /* Events */\n\n    event LeftoverDebtTokensTransferred(\n        address indexed dLoopCore,\n        address indexed debtToken,\n        uint256 amount\n    );\n    event MinLeftoverDebtTokenAmountSet(\n        address indexed dLoopCore,\n        address indexed debtToken,\n        uint256 minAmount\n    );\n\n    /* Structs */\n\n    struct FlashLoanParams {\n        address user;\n        uint256 additionalCollateralFromUser;\n        uint256 requiredCollateralAmount;\n        bytes debtTokenToCollateralSwapData;\n        DLoopCoreBase dLoopCore;\n    }\n\n    /**\n     * @dev Constructor for the DLoopIncreaseLeverageBase contract\n     * @param _flashLender Address of the flash loan provider\n     */\n    constructor(IERC3156FlashLender _flashLender) Ownable(msg.sender) {\n        flashLender = _flashLender;\n    }\n\n    /* RescuableVault Override */\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return restrictedTokens Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens()\n        public\n        view\n        virtual\n        override\n        returns (address[] memory restrictedTokens)\n    {\n        // Return the existing tokens as we handle leftover debt tokens\n        return existingDebtTokens;\n    }\n\n    /* Increase Leverage */\n\n    /**\n     * @dev Increases leverage with flash loans\n     *      - Flash loans debt tokens, swaps to collateral tokens, calls increaseLeverage, uses received debt tokens to repay flash loan\n     * @param additionalCollateralFromUser Additional collateral token amount from user (can be 0)\n     * @param minOutputDebtTokenAmount Minimum amount of debt token to receive (slippage protection)\n     * @param debtTokenToCollateralSwapData Swap data from debt token to collateral token\n     * @param dLoopCore Address of the DLoopCore contract to use\n     * @return receivedDebtTokenAmount Amount of debt tokens received from increase leverage operation\n     */\n    function increaseLeverage(\n        uint256 additionalCollateralFromUser,\n        uint256 minOutputDebtTokenAmount,\n        bytes calldata debtTokenToCollateralSwapData,\n        DLoopCoreBase dLoopCore\n    ) public nonReentrant returns (uint256 receivedDebtTokenAmount) {\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n\n        // Transfer any additional collateral token from user if provided\n        if (additionalCollateralFromUser > 0) {\n            collateralToken.safeTransferFrom(\n                msg.sender,\n                address(this),\n                additionalCollateralFromUser\n            );\n        }\n\n        // Calculate the required collateral amount to reach target leverage\n        (uint256 requiredCollateralAmount, int8 direction) = dLoopCore\n            .getAmountToReachTargetLeverage(true); // Use vault token balance\n\n        // Verify we need to increase leverage\n        if (direction != 1) {\n            revert(\"Current leverage is already at or above target\");\n        }\n\n        // Calculate how much we need from flash loan\n        uint256 collateralFromUser = additionalCollateralFromUser +\n            collateralToken.balanceOf(address(this));\n        if (requiredCollateralAmount > collateralFromUser) {\n            receivedDebtTokenAmount = _increaseLeverageWithFlashLoan(\n                requiredCollateralAmount,\n                collateralFromUser,\n                additionalCollateralFromUser,\n                debtTokenToCollateralSwapData,\n                dLoopCore,\n                collateralToken,\n                debtToken\n            );\n        } else {\n            // No flash loan needed, direct increase leverage\n            uint256 leverageBeforeIncrease = dLoopCore.getCurrentLeverageBps();\n            uint256 debtTokenBalanceBeforeIncrease = debtToken.balanceOf(\n                address(this)\n            );\n\n            // Approve collateral token for core contract\n            collateralToken.forceApprove(\n                address(dLoopCore),\n                collateralFromUser\n            );\n\n            // Call increase leverage directly\n            dLoopCore.increaseLeverage(\n                additionalCollateralFromUser,\n                minOutputDebtTokenAmount\n            );\n\n            // Verify leverage increased\n            uint256 leverageAfterIncrease = dLoopCore.getCurrentLeverageBps();\n            if (leverageAfterIncrease <= leverageBeforeIncrease) {\n                revert LeverageNotIncreased(\n                    leverageBeforeIncrease,\n                    leverageAfterIncrease\n                );\n            }\n\n            // Calculate received debt tokens\n            uint256 debtTokenBalanceAfterIncrease = debtToken.balanceOf(\n                address(this)\n            );\n            if (\n                debtTokenBalanceAfterIncrease <= debtTokenBalanceBeforeIncrease\n            ) {\n                revert DebtTokenBalanceNotIncreasedAfterIncreaseLeverage(\n                    debtTokenBalanceBeforeIncrease,\n                    debtTokenBalanceAfterIncrease\n                );\n            }\n\n            receivedDebtTokenAmount =\n                debtTokenBalanceAfterIncrease -\n                debtTokenBalanceBeforeIncrease;\n        }\n\n        // Slippage protection\n        if (receivedDebtTokenAmount < minOutputDebtTokenAmount) {\n            revert ReceivedDebtTokenNotMetMinReceiveAmount(\n                receivedDebtTokenAmount,\n                minOutputDebtTokenAmount\n            );\n        }\n\n        // Handle any leftover debt tokens\n        uint256 leftoverAmount = debtToken.balanceOf(address(this));\n        if (\n            leftoverAmount >\n            minLeftoverDebtTokenAmount[address(dLoopCore)][address(debtToken)]\n        ) {\n            debtToken.safeTransfer(address(dLoopCore), leftoverAmount);\n            emit LeftoverDebtTokensTransferred(\n                address(dLoopCore),\n                address(debtToken),\n                leftoverAmount\n            );\n        }\n\n        // Transfer received debt tokens to user\n        debtToken.safeTransfer(msg.sender, receivedDebtTokenAmount);\n\n        return receivedDebtTokenAmount;\n    }\n\n    /* Flash loan entrypoint */\n\n    /**\n     * @dev Callback function for flash loans\n     * @param initiator Address that initiated the flash loan\n     * @param token Address of the flash-borrowed token\n     * @param fee Flash loan fee\n     * @param data Additional data passed to the flash loan\n     * @return bytes32 The flash loan callback success bytes\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 /* amount */,\n        uint256 fee,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        // This function does not need nonReentrant as the flash loan will be called by increaseLeverage() public\n        // function, which is already protected by nonReentrant\n        // Moreover, this function is only be able to be called by the address(this) (check the initiator condition)\n        // thus even though the flash loan is public and not protected by nonReentrant, it is still safe\n        if (msg.sender != address(flashLender))\n            revert UnknownLender(msg.sender, address(flashLender));\n        if (initiator != address(this))\n            revert UnknownInitiator(initiator, address(this));\n\n        // Decode flash loan params\n        FlashLoanParams memory flashLoanParams = _decodeDataToParams(data);\n        DLoopCoreBase dLoopCore = flashLoanParams.dLoopCore;\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n\n        // Verify token compatibility\n        if (token != address(debtToken))\n            revert IncompatibleDLoopCoreDebtToken(token, address(debtToken));\n\n        // Swap flash loaned debt tokens to collateral tokens\n        uint256 requiredCollateralFromFlashLoan = flashLoanParams\n            .requiredCollateralAmount -\n            flashLoanParams.additionalCollateralFromUser -\n            collateralToken.balanceOf(address(this));\n\n        uint256 debtTokenUsedInSwap = _swapExactOutput(\n            debtToken,\n            collateralToken,\n            requiredCollateralFromFlashLoan,\n            type(uint256).max, // No slippage protection here\n            address(this),\n            block.timestamp,\n            flashLoanParams.debtTokenToCollateralSwapData\n        );\n\n        // Record debt token balance before increase leverage\n        uint256 debtTokenBalanceBeforeIncrease = debtToken.balanceOf(\n            address(this)\n        );\n\n        // Approve collateral for core contract\n        collateralToken.forceApprove(\n            address(dLoopCore),\n            flashLoanParams.requiredCollateralAmount\n        );\n\n        // Call increase leverage on core contract\n        dLoopCore.increaseLeverage(\n            flashLoanParams.additionalCollateralFromUser,\n            0 // No min amount check here, will be checked in main function\n        );\n\n        // Verify we received enough debt tokens to repay flash loan\n        uint256 debtTokenBalanceAfterIncrease = debtToken.balanceOf(\n            address(this)\n        );\n        if (debtTokenBalanceAfterIncrease <= debtTokenBalanceBeforeIncrease) {\n            revert DebtTokenBalanceNotIncreasedAfterIncreaseLeverage(\n                debtTokenBalanceBeforeIncrease,\n                debtTokenBalanceAfterIncrease\n            );\n        }\n\n        uint256 debtTokenReceived = debtTokenBalanceAfterIncrease -\n            debtTokenBalanceBeforeIncrease;\n\n        // Ensure we can repay flash loan\n        if (debtTokenReceived < debtTokenUsedInSwap + fee) {\n            revert DebtTokenReceivedNotMetUsedAmountWithFlashLoanFee(\n                debtTokenReceived,\n                debtTokenUsedInSwap,\n                fee\n            );\n        }\n\n        return FLASHLOAN_CALLBACK;\n    }\n\n    /* Setters */\n\n    /**\n     * @dev Sets the minimum leftover debt token amount for a given dLoopCore and debt token\n     * @param dLoopCore Address of the dLoopCore contract\n     * @param debtToken Address of the debt token\n     * @param minAmount Minimum leftover debt token amount for the given dLoopCore and debt token\n     */\n    function setMinLeftoverDebtTokenAmount(\n        address dLoopCore,\n        address debtToken,\n        uint256 minAmount\n    ) external nonReentrant onlyOwner {\n        minLeftoverDebtTokenAmount[dLoopCore][debtToken] = minAmount;\n        if (!_existingDebtTokensMap[debtToken]) {\n            _existingDebtTokensMap[debtToken] = true;\n            existingDebtTokens.push(debtToken);\n        }\n        emit MinLeftoverDebtTokenAmountSet(dLoopCore, debtToken, minAmount);\n    }\n\n    /* Internal helpers */\n\n    /**\n     * @dev Executes increase leverage with flash loan\n     * @param requiredCollateralAmount Required collateral amount\n     * @param collateralFromUser Collateral from user\n     * @param additionalCollateralFromUser Additional collateral from user\n     * @param debtTokenToCollateralSwapData Swap data\n     * @param dLoopCore DLoop core contract\n     * @param collateralToken Collateral token\n     * @param debtToken Debt token\n     * @return receivedDebtTokenAmount Amount of debt tokens received\n     */\n    function _increaseLeverageWithFlashLoan(\n        uint256 requiredCollateralAmount,\n        uint256 collateralFromUser,\n        uint256 additionalCollateralFromUser,\n        bytes calldata debtTokenToCollateralSwapData,\n        DLoopCoreBase dLoopCore,\n        ERC20 collateralToken,\n        ERC20 debtToken\n    ) internal returns (uint256 receivedDebtTokenAmount) {\n        uint256 requiredCollateralFromFlashLoan = requiredCollateralAmount -\n            collateralFromUser;\n\n        // Convert collateral amount to debt token amount for flash loan\n        uint256 requiredFlashLoanAmount = dLoopCore\n            .convertFromTokenAmountToBaseCurrency(\n                requiredCollateralFromFlashLoan,\n                address(collateralToken)\n            );\n        requiredFlashLoanAmount = dLoopCore.convertFromBaseCurrencyToToken(\n            requiredFlashLoanAmount,\n            address(debtToken)\n        );\n\n        // Check if flash loan amount is available\n        uint256 maxFlashLoanAmount = flashLender.maxFlashLoan(\n            address(debtToken)\n        );\n        if (requiredFlashLoanAmount > maxFlashLoanAmount) {\n            revert FlashLoanAmountExceedsMaxAvailable(\n                requiredFlashLoanAmount,\n                maxFlashLoanAmount\n            );\n        }\n\n        // Create flash loan params\n        FlashLoanParams memory params = FlashLoanParams(\n            msg.sender,\n            additionalCollateralFromUser,\n            requiredCollateralAmount,\n            debtTokenToCollateralSwapData,\n            dLoopCore\n        );\n        bytes memory data = _encodeParamsToData(params);\n\n        // Record initial state\n        uint256 leverageBeforeIncrease = dLoopCore.getCurrentLeverageBps();\n        uint256 debtTokenBalanceBeforeIncrease = debtToken.balanceOf(\n            address(this)\n        );\n\n        // Approve flash lender to spend debt tokens\n        debtToken.forceApprove(\n            address(flashLender),\n            requiredFlashLoanAmount +\n                flashLender.flashFee(\n                    address(debtToken),\n                    requiredFlashLoanAmount\n                )\n        );\n\n        // Execute flash loan - main logic in onFlashLoan\n        flashLender.flashLoan(\n            this,\n            address(debtToken),\n            requiredFlashLoanAmount,\n            data\n        );\n\n        // Verify leverage increased\n        uint256 leverageAfterIncrease = dLoopCore.getCurrentLeverageBps();\n        if (leverageAfterIncrease <= leverageBeforeIncrease) {\n            revert LeverageNotIncreased(\n                leverageBeforeIncrease,\n                leverageAfterIncrease\n            );\n        }\n\n        // Calculate received debt tokens\n        uint256 debtTokenBalanceAfterIncrease = debtToken.balanceOf(\n            address(this)\n        );\n        if (debtTokenBalanceAfterIncrease <= debtTokenBalanceBeforeIncrease) {\n            revert DebtTokenBalanceNotIncreasedAfterIncreaseLeverage(\n                debtTokenBalanceBeforeIncrease,\n                debtTokenBalanceAfterIncrease\n            );\n        }\n\n        receivedDebtTokenAmount =\n            debtTokenBalanceAfterIncrease -\n            debtTokenBalanceBeforeIncrease;\n    }\n\n    /* Data encoding/decoding helpers */\n\n    /**\n     * @dev Encodes flash loan parameters to data\n     * @param _flashLoanParams Flash loan parameters\n     * @return data Encoded data\n     */\n    function _encodeParamsToData(\n        FlashLoanParams memory _flashLoanParams\n    ) internal pure returns (bytes memory data) {\n        data = abi.encode(\n            _flashLoanParams.user,\n            _flashLoanParams.additionalCollateralFromUser,\n            _flashLoanParams.requiredCollateralAmount,\n            _flashLoanParams.debtTokenToCollateralSwapData,\n            _flashLoanParams.dLoopCore\n        );\n    }\n\n    /**\n     * @dev Decodes data to flash loan parameters\n     * @param data Encoded data\n     * @return _flashLoanParams Decoded flash loan parameters\n     */\n    function _decodeDataToParams(\n        bytes memory data\n    ) internal pure returns (FlashLoanParams memory _flashLoanParams) {\n        (\n            _flashLoanParams.user,\n            _flashLoanParams.additionalCollateralFromUser,\n            _flashLoanParams.requiredCollateralAmount,\n            _flashLoanParams.debtTokenToCollateralSwapData,\n            _flashLoanParams.dLoopCore\n        ) = abi.decode(data, (address, uint256, uint256, bytes, DLoopCoreBase));\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/DLoopRedeemerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {BasisPointConstants} from \"contracts/common/BasisPointConstants.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interface/flashloan/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interface/flashloan/IERC3156FlashLender.sol\";\nimport {DLoopCoreBase} from \"../core/DLoopCoreBase.sol\";\nimport {SwappableVault} from \"contracts/common/SwappableVault.sol\";\nimport {RescuableVault} from \"contracts/common/RescuableVault.sol\";\n\n/**\n * @title DLoopRedeemerBase\n * @dev A helper contract for withdrawing assets from the core vault with flash loans\n *      - Suppose that the core contract has leverage of 3x, and the collateral token is WETH, debt token is dUSD, price of WETH is 1000, price of dUSD is 2000\n *      - ie, given user has 300 shares representing 300 WETH, and wants to withdraw 300 WETH, this contract will do a flash loan to get 200 * 2000 dUSD\n *        to repay the debt in the core vault, then withdraw 300 WETH from the core vault. The contract will swap 200 WETH to 200 * 2000 dUSD to repay the flash loan.\n *      - In the final state, the user has 100 WETH (300 - 200), and the core contract has 0 WETH as collateral, 0 dUSD as debt\n *      - NOTE: This contract only support redeem() from DLoopCore contracts, not withdraw()\n */\nabstract contract DLoopRedeemerBase is\n    IERC3156FlashBorrower,\n    Ownable,\n    ReentrancyGuard,\n    SwappableVault,\n    RescuableVault\n{\n    using SafeERC20 for ERC20;\n\n    /* Constants */\n\n    bytes32 public constant FLASHLOAN_CALLBACK =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /* Core state */\n\n    IERC3156FlashLender public immutable flashLender;\n    // [dLoopCore][tokenAddress] -> leftOverAmount\n    mapping(address => mapping(address => uint256))\n        public minLeftoverCollateralTokenAmount;\n    // [tokenAddress] -> exists (for gas efficient token tracking)\n    mapping(address => bool) private _existingCollateralTokensMap;\n    address[] public existingCollateralTokens;\n\n    /* Errors */\n\n    error UnknownLender(address msgSender, address flashLender);\n    error UnknownInitiator(address initiator, address thisContract);\n    error IncompatibleDLoopCoreDebtToken(\n        address currentDebtToken,\n        address dLoopCoreDebtToken\n    );\n    error SharesNotDecreasedAfterFlashLoan(\n        uint256 sharesBeforeWithdraw,\n        uint256 sharesAfterWithdraw\n    );\n    error InsufficientOutput(uint256 received, uint256 expected);\n    error UnexpectedIncreaseInDebtToken(\n        uint256 debtTokenBalanceBefore,\n        uint256 debtTokenBalanceAfter\n    );\n    error UnexpectedDecreaseInCollateralToken(\n        uint256 collateralTokenBalanceBefore,\n        uint256 collateralTokenBalanceAfter\n    );\n    error UnexpectedDecreaseInCollateralTokenAfterFlashLoan(\n        uint256 collateralTokenBalanceBefore,\n        uint256 collateralTokenBalanceAfter\n    );\n    error IncorrectSharesBurned(uint256 expected, uint256 actual);\n    error WithdrawnCollateralTokenAmountNotMetMinReceiveAmount(\n        uint256 withdrawnCollateralTokenAmount,\n        uint256 minReceiveCollateralTokenAmount\n    );\n    error EstimatedCollateralTokenAmountLessThanMinOutputCollateralAmount(\n        uint256 currentCollateralTokenAmount,\n        uint256 minOutputCollateralAmount\n    );\n    error FlashLenderNotSameAsDebtToken(address flashLender, address debtToken);\n    error SlippageBpsCannotExceedOneHundredPercent(uint256 slippageBps);\n\n    /* Events */\n\n    event LeftoverCollateralTokenTransferred(\n        address indexed dLoopCore,\n        address indexed collateralToken,\n        uint256 amount\n    );\n    event MinLeftoverCollateralTokenAmountSet(\n        address indexed dLoopCore,\n        address indexed collateralToken,\n        uint256 minAmount\n    );\n\n    /* Structs */\n\n    struct FlashLoanParams {\n        uint256 shares;\n        bytes collateralToDebtTokenSwapData;\n        DLoopCoreBase dLoopCore;\n    }\n\n    /**\n     * @dev Constructor for the DLoopRedeemerBase contract\n     * @param _flashLender Address of the flash loan provider\n     */\n    constructor(IERC3156FlashLender _flashLender) Ownable(msg.sender) {\n        flashLender = _flashLender;\n    }\n\n    /* RescuableVault Override */\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return restrictedTokens Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens()\n        public\n        view\n        virtual\n        override\n        returns (address[] memory restrictedTokens)\n    {\n        // Return the existing tokens as we handle leftover collateral tokens\n        return existingCollateralTokens;\n    }\n\n    /* Redeem */\n\n    /**\n     * @dev Calculates the minimum output collateral amount for a given shares and slippage bps\n     * @param shares Amount of shares to redeem\n     * @param slippageBps Slippage bps\n     * @param dLoopCore Address of the DLoopCore contract\n     * @return minOutputCollateralAmount Minimum output collateral amount\n     */\n    function calculateMinOutputCollateral(\n        uint256 shares,\n        uint256 slippageBps,\n        DLoopCoreBase dLoopCore\n    ) public view returns (uint256) {\n        if (slippageBps > BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert SlippageBpsCannotExceedOneHundredPercent(slippageBps);\n        }\n        uint256 expectedLeverageCollateral = dLoopCore.previewRedeem(shares);\n        uint256 unleveragedCollateral = dLoopCore.getUnleveragedAssets(\n            expectedLeverageCollateral\n        );\n        return\n            (unleveragedCollateral *\n                (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS - slippageBps)) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n    }\n\n    /**\n     * @dev Redeems shares from the core vault with flash loans\n     *      - The required debt token to withdraw will be flash loaned from the flash lender\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to receive the assets\n     * @param minOutputCollateralAmount Minimum amount of collateral token to receive (slippage protection)\n     * @param collateralToDebtTokenSwapData Swap data from collateral token to debt token\n     * @param dLoopCore Address of the DLoopCore contract to use\n     * @return assets Amount of assets redeemed\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        uint256 minOutputCollateralAmount,\n        bytes calldata collateralToDebtTokenSwapData,\n        DLoopCoreBase dLoopCore\n    ) public nonReentrant returns (uint256 assets) {\n        // Transfer the shares to the periphery contract to prepare for the redeeming process\n        SafeERC20.safeTransferFrom(\n            dLoopCore,\n            msg.sender,\n            address(this),\n            shares\n        );\n\n        // Do not need to transfer the debt token to repay the lending pool, as it will be done with flash loan\n\n        /**\n         * In redeeming, we do not need to calculate the _calculateEstimatedOverallSlippageBps(), as the\n         * withdrawn collateral token amount is always larger than the flashloan debt token amount (due to the leverage logic):\n         *\n         * According to the formula in DLoopCoreBase.getRepayAmountThatKeepCurrentLeverage():\n         *       y = x * (T-1)/T\n         *   and\n         *       y = x * (T' - ONE_HUNDRED_PERCENT_BPS) / T'\n         *   and\n         *       T = T' / ONE_HUNDRED_PERCENT_BPS\n         * where:\n         *      - x is the collateral token amount\n         *      - y is the debt token amount\n         *      - T is the target leverage\n         *      - T' is the target leverage in basis points unit\n         *\n         * We want find what is the condition of m so that we can withdraw the collateral token and swap\n         * to the debt token which is sufficient to repay the flash loan amount and meet user minimum receiving\n         * collateral amount. We want:\n         *      y <= x * (1-s) - m\n         * where:\n         *      - m is the minimum receiving collateral amount in base currency\n         *      - s is the swap slippage (0.01 means 1%)\n         *\n         * We have:\n         *      y <= x * (1-s) - m\n         *  <=> x * (T-1)/T <= x * (1-s) - m\n         *  <=> x * (1-s) - x * (T-1)/T >= m\n         *  <=> x * (1 - s - (T-1)/T) >= m\n         *  <=> m <= x * (1 - s - (T-1)/T)\n         *\n         * Thus, the only thing to make the transaction works is to adjust the minOutputCollateralAmount\n         * to be larger than the flashloan debt token amount, which is the leveraged amount\n         */\n\n        // Create the flash loan params data\n        FlashLoanParams memory params = FlashLoanParams(\n            shares,\n            collateralToDebtTokenSwapData,\n            dLoopCore\n        );\n        bytes memory data = _encodeParamsToData(params);\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n        uint256 maxFlashLoanAmount = flashLender.maxFlashLoan(\n            address(debtToken)\n        );\n\n        // This value is used to calculate the shares burned after the flash loan\n        uint256 sharesBeforeRedeem = dLoopCore.balanceOf(address(this));\n\n        // This value is used to calculate the received collateral token amount after the flash loan\n        uint256 collateralTokenBalanceBefore = collateralToken.balanceOf(\n            address(this)\n        );\n\n        // Approve the flash lender to spend the flash loan amount of debt token from this contract\n        debtToken.forceApprove(\n            address(flashLender),\n            maxFlashLoanAmount +\n                flashLender.flashFee(address(debtToken), maxFlashLoanAmount)\n        );\n\n        // Make sure the flashLender is the same as the debt token\n        if (address(flashLender) != address(debtToken)) {\n            revert FlashLenderNotSameAsDebtToken(\n                address(flashLender),\n                address(debtToken)\n            );\n        }\n\n        // The main logic will be done in the onFlashLoan function\n        flashLender.flashLoan(\n            this,\n            address(debtToken),\n            maxFlashLoanAmount,\n            data\n        );\n\n        // Check if the shares decreased after the flash loan\n        uint256 sharesAfterRedeem = dLoopCore.balanceOf(address(this));\n        if (sharesAfterRedeem >= sharesBeforeRedeem) {\n            revert SharesNotDecreasedAfterFlashLoan(\n                sharesBeforeRedeem,\n                sharesAfterRedeem\n            );\n        }\n\n        // Calculate received collateral tokens\n        uint256 collateralTokenBalanceAfter = collateralToken.balanceOf(\n            address(this)\n        );\n        if (collateralTokenBalanceAfter <= collateralTokenBalanceBefore) {\n            revert UnexpectedDecreaseInCollateralTokenAfterFlashLoan(\n                collateralTokenBalanceBefore,\n                collateralTokenBalanceAfter\n            );\n        }\n\n        uint256 receivedCollateralTokenAmount = collateralTokenBalanceAfter -\n            collateralTokenBalanceBefore;\n\n        // Slippage protection\n        if (receivedCollateralTokenAmount < minOutputCollateralAmount) {\n            revert WithdrawnCollateralTokenAmountNotMetMinReceiveAmount(\n                receivedCollateralTokenAmount,\n                minOutputCollateralAmount\n            );\n        }\n\n        // Transfer the received collateral token to the receiver\n        collateralToken.safeTransfer(receiver, receivedCollateralTokenAmount);\n\n        // There is no leftover debt token, as all flash loaned debt token is used to repay the debt\n        // when calling the redeem() function\n\n        // Handle any leftover collateral token and transfer them to the dLoopCore contract\n        uint256 leftoverCollateralTokenAmount = collateralToken.balanceOf(\n            address(this)\n        );\n        if (\n            leftoverCollateralTokenAmount >\n            minLeftoverCollateralTokenAmount[address(dLoopCore)][\n                address(collateralToken)\n            ]\n        ) {\n            collateralToken.safeTransfer(\n                address(dLoopCore),\n                leftoverCollateralTokenAmount\n            );\n            emit LeftoverCollateralTokenTransferred(\n                address(dLoopCore),\n                address(collateralToken),\n                leftoverCollateralTokenAmount\n            );\n        }\n\n        // Return the received collateral token amount\n        return receivedCollateralTokenAmount;\n    }\n\n    /* Flash loan entrypoint */\n\n    /**\n     * @dev Callback function for flash loans\n     * @param initiator Address that initiated the flash loan\n     * @param token Address of the flash-borrowed token\n     * @param data Encoded flash loan parameters\n     * @return bytes32 The flash loan callback success bytes\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256, // amount (flash loan amount)\n        uint256 flashLoanFee, // fee (flash loan fee)\n        bytes calldata data\n    ) external override returns (bytes32) {\n        // This function does not need nonReentrant as the flash loan will be called by redeem() public\n        // function, which is already protected by nonReentrant\n        // Moreover, this function is only be able to be called by the address(this) (check the initiator condition)\n        // thus even though the flash loan is public and not protected by nonReentrant, it is still safe\n        if (msg.sender != address(flashLender))\n            revert UnknownLender(msg.sender, address(flashLender));\n        if (initiator != address(this))\n            revert UnknownInitiator(initiator, address(this));\n\n        // Decode the flash loan params data\n        FlashLoanParams memory flashLoanParams = _decodeDataToParams(data);\n        DLoopCoreBase dLoopCore = flashLoanParams.dLoopCore;\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n\n        // Make sure the input dLoopCore is compatible with this periphery contract\n        if (token != address(debtToken))\n            revert IncompatibleDLoopCoreDebtToken(token, address(debtToken));\n\n        // This value is used to calculate the debt token was used from the flash loan\n        uint256 debtTokenBalanceBefore = debtToken.balanceOf(address(this));\n\n        /**\n         * Redeem the shares to get the collateral token\n         * The core vault will also take the debt token from the periphery contract\n         * to repay the debt and then withdraw the collateral token\n         *\n         * The receiver is this periphery contract as it needs to use the collateral token\n         * to swap to the debt token to repay the flash loan\n         *\n         * The owner is the owner of the shares as it needs to burn the shares\n         */\n        debtToken.forceApprove(\n            address(dLoopCore),\n            type(uint256).max // No slippage tolerance\n        );\n        dLoopCore.redeem(\n            flashLoanParams.shares,\n            address(this), // receiver\n            // the owner is the periphery contract as the shares were transferred from the owner to the periphery contract\n            address(this) // owner\n        );\n        // Approve back to 0 to avoid any potential exploits later\n        debtToken.forceApprove(address(dLoopCore), 0);\n\n        // Calculate the debt token was used from the flash loan\n        uint256 debtTokenBalanceAfter = debtToken.balanceOf(address(this));\n        if (debtTokenBalanceAfter > debtTokenBalanceBefore) {\n            revert UnexpectedIncreaseInDebtToken(\n                debtTokenBalanceBefore,\n                debtTokenBalanceAfter\n            );\n        }\n        uint256 debtTokenUsed = debtTokenBalanceBefore - debtTokenBalanceAfter;\n\n        /**\n         * Swap the collateral token to the debt token to repay the flash loan\n         *\n         * Slippage protection is not needed here as the received collateral token\n         * will be protected by the minOutputCollateralAmount of the redeem() function\n         * - It means, if the swap has too high slippage, the final output collateral token\n         *   amount will be less than the minOutputCollateralAmount, which will be reverted\n         *   by the redeem() function\n         */\n        _swapExactOutput(\n            collateralToken,\n            debtToken,\n            debtTokenUsed + flashLoanFee,\n            type(uint256).max, // No slippage tolerance\n            address(this),\n            block.timestamp,\n            flashLoanParams.collateralToDebtTokenSwapData\n        );\n\n        // If the swapped debt token amount is less than the debt token used,\n        // the flash loan fee will be reverted\n\n        // Return the success bytes\n        return FLASHLOAN_CALLBACK;\n    }\n\n    /* Setters */\n\n    /**\n     * @dev Sets the minimum leftover collateral token amount for a given dLoopCore and collateral token\n     * @param dLoopCore Address of the dLoopCore contract\n     * @param collateralToken Address of the collateral token\n     * @param minAmount Minimum leftover collateral token amount for the given dLoopCore and collateral token\n     */\n    function setMinLeftoverCollateralTokenAmount(\n        address dLoopCore,\n        address collateralToken,\n        uint256 minAmount\n    ) external nonReentrant onlyOwner {\n        minLeftoverCollateralTokenAmount[dLoopCore][\n            collateralToken\n        ] = minAmount;\n        if (!_existingCollateralTokensMap[collateralToken]) {\n            _existingCollateralTokensMap[collateralToken] = true;\n            existingCollateralTokens.push(collateralToken);\n        }\n        emit MinLeftoverCollateralTokenAmountSet(\n            dLoopCore,\n            collateralToken,\n            minAmount\n        );\n    }\n\n    /* Internal helpers */\n\n    /**\n     * @dev Handles leftover collateral tokens by transferring them to the dLoopCore contract if above minimum threshold\n     * @param dLoopCore The dLoopCore contract\n     * @param collateralToken The collateral token to handle\n     */\n    function _handleLeftoverCollateralTokens(\n        DLoopCoreBase dLoopCore,\n        ERC20 collateralToken\n    ) internal {\n        uint256 leftoverCollateralTokenAmount = collateralToken.balanceOf(\n            address(this)\n        );\n        if (\n            leftoverCollateralTokenAmount >\n            minLeftoverCollateralTokenAmount[address(dLoopCore)][\n                address(collateralToken)\n            ]\n        ) {\n            collateralToken.safeTransfer(\n                address(dLoopCore),\n                leftoverCollateralTokenAmount\n            );\n            emit LeftoverCollateralTokenTransferred(\n                address(dLoopCore),\n                address(collateralToken),\n                leftoverCollateralTokenAmount\n            );\n        }\n    }\n\n    /**\n     * @dev Validates that shares were burned correctly\n     * @param dLoopCore The dLoopCore contract\n     * @param owner The owner of the shares\n     * @param shares Expected shares to be burned\n     * @param sharesBeforeRedeem Shares balance before redeem\n     */\n    function _validateSharesBurned(\n        DLoopCoreBase dLoopCore,\n        address owner,\n        uint256 shares,\n        uint256 sharesBeforeRedeem\n    ) internal view {\n        // Check if the shares decreased after the flash loan\n        uint256 sharesAfterRedeem = dLoopCore.balanceOf(owner);\n        if (sharesAfterRedeem >= sharesBeforeRedeem) {\n            revert SharesNotDecreasedAfterFlashLoan(\n                sharesBeforeRedeem,\n                sharesAfterRedeem\n            );\n        }\n\n        // Make sure the burned shares is exactly the shares amount\n        uint256 actualBurnedShares = sharesBeforeRedeem - sharesAfterRedeem;\n        if (actualBurnedShares != shares) {\n            revert IncorrectSharesBurned(shares, actualBurnedShares);\n        }\n    }\n\n    /**\n     * @dev Finalizes redeem by validating shares and transferring assets to receiver\n     * @param dLoopCore The dLoopCore contract\n     * @param collateralToken The collateral token\n     * @param owner The owner of the shares\n     * @param receiver Address to receive the assets\n     * @param shares Expected shares to be burned\n     * @param sharesBeforeRedeem Shares balance before redeem\n     * @param collateralTokenBalanceBefore Collateral balance before redeem\n     * @param minOutputCollateralAmount Minimum output collateral amount\n     * @return receivedCollateralTokenAmount Amount of collateral tokens received\n     */\n    function _finalizeRedeemAndTransfer(\n        DLoopCoreBase dLoopCore,\n        ERC20 collateralToken,\n        address owner,\n        address receiver,\n        uint256 shares,\n        uint256 sharesBeforeRedeem,\n        uint256 collateralTokenBalanceBefore,\n        uint256 minOutputCollateralAmount\n    ) internal returns (uint256 receivedCollateralTokenAmount) {\n        // Validate shares burned correctly\n        _validateSharesBurned(dLoopCore, owner, shares, sharesBeforeRedeem);\n\n        // Collateral balance after the flash loan\n        uint256 collateralTokenBalanceAfter = collateralToken.balanceOf(\n            address(this)\n        );\n\n        // Calculate the received collateral token amount after the flash loan\n        if (collateralTokenBalanceAfter <= collateralTokenBalanceBefore) {\n            revert UnexpectedDecreaseInCollateralTokenAfterFlashLoan(\n                collateralTokenBalanceBefore,\n                collateralTokenBalanceAfter\n            );\n        }\n\n        // Make sure the received collateral token amount is not less than the minimum output collateral amount\n        // for slippage protection\n        receivedCollateralTokenAmount =\n            collateralTokenBalanceAfter -\n            collateralTokenBalanceBefore;\n        if (receivedCollateralTokenAmount < minOutputCollateralAmount) {\n            revert WithdrawnCollateralTokenAmountNotMetMinReceiveAmount(\n                receivedCollateralTokenAmount,\n                minOutputCollateralAmount\n            );\n        }\n\n        // There is no leftover debt token, as all flash loaned debt token is used to repay the debt\n        // when calling the redeem() function\n\n        // Handle leftovers and transfer tokens\n        _handleLeftoverCollateralTokens(dLoopCore, collateralToken);\n        collateralToken.safeTransfer(receiver, receivedCollateralTokenAmount);\n    }\n\n    /* Data encoding/decoding helpers */\n\n    /**\n     * @dev Encodes flash loan parameters to data\n     * @param _flashLoanParams Flash loan parameters\n     * @return data Encoded data\n     */\n    function _encodeParamsToData(\n        FlashLoanParams memory _flashLoanParams\n    ) internal pure returns (bytes memory data) {\n        data = abi.encode(\n            _flashLoanParams.shares,\n            _flashLoanParams.collateralToDebtTokenSwapData,\n            _flashLoanParams.dLoopCore\n        );\n    }\n\n    /**\n     * @dev Decodes data to flash loan withdraw parameters\n     * @param data Encoded data\n     * @return _flashLoanParams Decoded flash loan parameters\n     */\n    function _decodeDataToParams(\n        bytes memory data\n    ) internal pure returns (FlashLoanParams memory _flashLoanParams) {\n        (\n            _flashLoanParams.shares,\n            _flashLoanParams.collateralToDebtTokenSwapData,\n            _flashLoanParams.dLoopCore\n        ) = abi.decode(data, (uint256, bytes, DLoopCoreBase));\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/interface/flashloan/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/vaults/dloop/periphery/interface/flashloan/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(\n        address token,\n        uint256 amount\n    ) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "contracts/vaults/dloop/periphery/venue/mock/DLoopDecreaseLeverageMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {DLoopDecreaseLeverageBase, ERC20, IERC3156FlashLender} from \"../../DLoopDecreaseLeverageBase.sol\";\nimport {SimpleDEXMock} from \"contracts/testing/dex/SimpleDEXMock.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @title DLoopDecreaseLeverageMock\n * @dev Implementation of DLoopDecreaseLeverageBase with SimpleDEXMock swap functionality\n */\ncontract DLoopDecreaseLeverageMock is DLoopDecreaseLeverageBase {\n    SimpleDEXMock public immutable simpleDEXMock;\n\n    /**\n     * @dev Constructor for the DLoopDecreaseLeverageMock contract\n     * @param _flashLender Address of the flash loan provider\n     * @param _simpleDEXMock Address of the SimpleDEXMock contract\n     */\n    constructor(\n        IERC3156FlashLender _flashLender,\n        SimpleDEXMock _simpleDEXMock\n    ) DLoopDecreaseLeverageBase(_flashLender) {\n        simpleDEXMock = _simpleDEXMock;\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for the minimum input tokens using SimpleDEXMock\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256, // deadline\n        bytes memory // collateralToDebtTokenSwapData\n    ) internal override returns (uint256) {\n        // Approve the SimpleDEXMock to spend the input token\n        require(\n            inputToken.approve(address(simpleDEXMock), amountInMaximum),\n            \"Approve simpleDEXMock to spend input token failed\"\n        );\n\n        return\n            simpleDEXMock.executeSwapExactOutput(\n                IERC20Metadata(address(inputToken)),\n                IERC20Metadata(address(outputToken)),\n                amountOut,\n                amountInMaximum,\n                receiver\n            );\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/venue/mock/DLoopDepositorMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {DLoopDepositorBase, ERC20, IERC3156FlashLender} from \"../../DLoopDepositorBase.sol\";\nimport {SimpleDEXMock} from \"contracts/testing/dex/SimpleDEXMock.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @title DLoopDepositorMock\n * @dev Implementation of DLoopDepositorBase with SimpleDEXMock swap functionality\n */\ncontract DLoopDepositorMock is DLoopDepositorBase {\n    SimpleDEXMock public immutable simpleDEXMock;\n\n    /**\n     * @dev Constructor for the DLoopDepositorMock contract\n     * @param _flashLender Address of the flash loan provider\n     * @param _simpleDEXMock Address of the SimpleDEXMock contract\n     */\n    constructor(\n        IERC3156FlashLender _flashLender,\n        SimpleDEXMock _simpleDEXMock\n    ) DLoopDepositorBase(_flashLender) {\n        simpleDEXMock = _simpleDEXMock;\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for the minimum input tokens using Odos\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256, // deadline\n        bytes memory // dStableToUnderlyingSwapData\n    ) internal override returns (uint256) {\n        // Approve the SimpleDEXMock to spend the input token\n        require(\n            inputToken.approve(address(simpleDEXMock), amountInMaximum),\n            \"Approve simpleDEXMock to spend input token failed\"\n        );\n\n        return\n            simpleDEXMock.executeSwapExactOutput(\n                IERC20Metadata(address(inputToken)),\n                IERC20Metadata(address(outputToken)),\n                amountOut,\n                amountInMaximum,\n                receiver\n            );\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/venue/mock/DLoopIncreaseLeverageMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/     \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {DLoopIncreaseLeverageBase, ERC20, IERC3156FlashLender} from \"../../DLoopIncreaseLeverageBase.sol\";\nimport {SimpleDEXMock} from \"contracts/testing/dex/SimpleDEXMock.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @title DLoopIncreaseLeverageMock\n * @dev Implementation of DLoopIncreaseLeverageBase with SimpleDEXMock swap functionality\n */\ncontract DLoopIncreaseLeverageMock is DLoopIncreaseLeverageBase {\n    SimpleDEXMock public immutable simpleDEXMock;\n\n    /**\n     * @dev Constructor for the DLoopIncreaseLeverageMock contract\n     * @param _flashLender Address of the flash loan provider\n     * @param _simpleDEXMock Address of the SimpleDEXMock contract\n     */\n    constructor(\n        IERC3156FlashLender _flashLender,\n        SimpleDEXMock _simpleDEXMock\n    ) DLoopIncreaseLeverageBase(_flashLender) {\n        simpleDEXMock = _simpleDEXMock;\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for the minimum input tokens using SimpleDEXMock\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256, // deadline\n        bytes memory // debtTokenToCollateralSwapData\n    ) internal override returns (uint256) {\n        // Approve the SimpleDEXMock to spend the input token\n        require(\n            inputToken.approve(address(simpleDEXMock), amountInMaximum),\n            \"Approve simpleDEXMock to spend input token failed\"\n        );\n\n        return\n            simpleDEXMock.executeSwapExactOutput(\n                IERC20Metadata(address(inputToken)),\n                IERC20Metadata(address(outputToken)),\n                amountOut,\n                amountInMaximum,\n                receiver\n            );\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/venue/mock/DLoopRedeemerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {DLoopRedeemerBase, ERC20, IERC3156FlashLender} from \"../../DLoopRedeemerBase.sol\";\nimport {SimpleDEXMock} from \"contracts/testing/dex/SimpleDEXMock.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @title DLoopRedeemerMock\n * @dev Implementation of DLoopRedeemerBase with SimpleDEXMock swap functionality\n */\ncontract DLoopRedeemerMock is DLoopRedeemerBase {\n    SimpleDEXMock public immutable simpleDEXMock;\n\n    /**\n     * @dev Constructor for the DLoopRedeemerMock contract\n     * @param _flashLender Address of the flash loan provider\n     * @param _simpleDEXMock Address of the SimpleDEXMock contract\n     */\n    constructor(\n        IERC3156FlashLender _flashLender,\n        SimpleDEXMock _simpleDEXMock\n    ) DLoopRedeemerBase(_flashLender) {\n        simpleDEXMock = _simpleDEXMock;\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for the minimum input tokens using SimpleDEXMock\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256, // deadline\n        bytes memory // underlyingToDStableSwapData\n    ) internal override returns (uint256) {\n        // Approve the SimpleDEXMock to spend the input token\n        require(\n            inputToken.approve(address(simpleDEXMock), amountInMaximum),\n            \"Approve simpleDEXMock to spend input token failed\"\n        );\n\n        return\n            simpleDEXMock.executeSwapExactOutput(\n                IERC20Metadata(address(inputToken)),\n                IERC20Metadata(address(outputToken)),\n                amountOut,\n                amountInMaximum,\n                receiver\n            );\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/venue/odos/DLoopDecreaseLeverageOdos.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {DLoopDecreaseLeverageBase, ERC20, IERC3156FlashLender} from \"../../DLoopDecreaseLeverageBase.sol\";\nimport {OdosSwapLogic, IOdosRouterV2} from \"./OdosSwapLogic.sol\";\n\n/**\n * @title DLoopDecreaseLeverageOdos\n * @dev Implementation of DLoopDecreaseLeverageBase with Odos swap functionality\n */\ncontract DLoopDecreaseLeverageOdos is DLoopDecreaseLeverageBase {\n    IOdosRouterV2 public immutable odosRouter;\n\n    /**\n     * @dev Constructor for the DLoopDecreaseLeverageOdos contract\n     * @param _flashLender Address of the flash loan provider\n     * @param _odosRouter Address of the Odos router\n     */\n    constructor(\n        IERC3156FlashLender _flashLender,\n        IOdosRouterV2 _odosRouter\n    ) DLoopDecreaseLeverageBase(_flashLender) {\n        odosRouter = _odosRouter;\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for the minimum input tokens using Odos\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory collateralToDebtTokenSwapData\n    ) internal override returns (uint256) {\n        return\n            OdosSwapLogic.swapExactOutput(\n                inputToken,\n                outputToken,\n                amountOut,\n                amountInMaximum,\n                receiver,\n                deadline,\n                collateralToDebtTokenSwapData,\n                odosRouter\n            );\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/venue/odos/DLoopDepositorOdos.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {DLoopDepositorBase, ERC20, IERC3156FlashLender} from \"../../DLoopDepositorBase.sol\";\nimport {OdosSwapLogic, IOdosRouterV2} from \"./OdosSwapLogic.sol\";\n\n/**\n * @title DLoopDepositorOdos\n * @dev Implementation of DLoopDepositorBase with Odos swap functionality\n */\ncontract DLoopDepositorOdos is DLoopDepositorBase {\n    IOdosRouterV2 public immutable odosRouter;\n\n    /**\n     * @dev Constructor for the DLoopDepositorOdos contract\n     * @param _flashLender Address of the flash loan provider\n     * @param _odosRouter Address of the Odos router\n     */\n    constructor(\n        IERC3156FlashLender _flashLender,\n        IOdosRouterV2 _odosRouter\n    ) DLoopDepositorBase(_flashLender) {\n        odosRouter = _odosRouter;\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for the minimum input tokens using Odos\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory dStableToUnderlyingSwapData\n    ) internal override returns (uint256) {\n        return\n            OdosSwapLogic.swapExactOutput(\n                inputToken,\n                outputToken,\n                amountOut,\n                amountInMaximum,\n                receiver,\n                deadline,\n                dStableToUnderlyingSwapData,\n                odosRouter\n            );\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/venue/odos/DLoopIncreaseLeverageOdos.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {DLoopIncreaseLeverageBase, ERC20, IERC3156FlashLender} from \"../../DLoopIncreaseLeverageBase.sol\";\nimport {OdosSwapLogic, IOdosRouterV2} from \"./OdosSwapLogic.sol\";\n\n/**\n * @title DLoopIncreaseLeverageOdos\n * @dev Implementation of DLoopIncreaseLeverageBase with Odos swap functionality\n */\ncontract DLoopIncreaseLeverageOdos is DLoopIncreaseLeverageBase {\n    IOdosRouterV2 public immutable odosRouter;\n\n    /**\n     * @dev Constructor for the DLoopIncreaseLeverageOdos contract\n     * @param _flashLender Address of the flash loan provider\n     * @param _odosRouter Address of the Odos router\n     */\n    constructor(\n        IERC3156FlashLender _flashLender,\n        IOdosRouterV2 _odosRouter\n    ) DLoopIncreaseLeverageBase(_flashLender) {\n        odosRouter = _odosRouter;\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for the minimum input tokens using Odos\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory debtTokenToCollateralSwapData\n    ) internal override returns (uint256) {\n        return\n            OdosSwapLogic.swapExactOutput(\n                inputToken,\n                outputToken,\n                amountOut,\n                amountInMaximum,\n                receiver,\n                deadline,\n                debtTokenToCollateralSwapData,\n                odosRouter\n            );\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/venue/odos/DLoopRedeemerOdos.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {DLoopRedeemerBase, ERC20, IERC3156FlashLender} from \"../../DLoopRedeemerBase.sol\";\nimport {OdosSwapLogic, IOdosRouterV2} from \"./OdosSwapLogic.sol\";\n\n/**\n * @title DLoopRedeemerOdos\n * @dev Implementation of DLoopRedeemerBase with Odos swap functionality\n */\ncontract DLoopRedeemerOdos is DLoopRedeemerBase {\n    IOdosRouterV2 public immutable odosRouter;\n\n    /**\n     * @dev Constructor for the DLoopRedeemerOdos contract\n     * @param _flashLender Address of the flash loan provider\n     * @param _odosRouter Address of the Odos router\n     */\n    constructor(\n        IERC3156FlashLender _flashLender,\n        IOdosRouterV2 _odosRouter\n    ) DLoopRedeemerBase(_flashLender) {\n        odosRouter = _odosRouter;\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for the minimum input tokens using Odos\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory underlyingToDStableSwapData\n    ) internal override returns (uint256) {\n        return\n            OdosSwapLogic.swapExactOutput(\n                inputToken,\n                outputToken,\n                amountOut,\n                amountInMaximum,\n                receiver,\n                deadline,\n                underlyingToDStableSwapData,\n                odosRouter\n            );\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/venue/odos/OdosSwapLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity 0.8.20;\n\nimport {ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {IOdosRouterV2} from \"contracts/odos/interface/IOdosRouterV2.sol\";\nimport {OdosSwapUtils} from \"contracts/odos/OdosSwapUtils.sol\";\n\n/**\n * @title OdosSwapLogic\n * @dev Library for common Odos swap functions used in dLOOP contracts\n */\nlibrary OdosSwapLogic {\n    using SafeERC20 for ERC20;\n\n    /**\n     * @dev Swaps an exact amount of output tokens for input tokens using Odos router\n     * @param inputToken Input token to be swapped\n     * @param outputToken Output token to receive (used for validating the swap direction)\n     * @param amountOut Exact amount of output tokens to receive\n     * @param amountInMaximum Maximum amount of input tokens to spend\n     * @param receiver Address to receive the output tokens (not used directly in Odos, but kept for interface consistency)\n     * @param swapData Encoded swap data for Odos router\n     * @param odosRouter Odos router instance\n     * @return uint256 Amount of input tokens used\n     */\n    function swapExactOutput(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256, // deadline, not used in Odos\n        bytes memory swapData,\n        IOdosRouterV2 odosRouter\n    ) external returns (uint256) {\n        // Use the OdosSwapUtils library to execute the swap\n        uint256 actualAmountOut = OdosSwapUtils.executeSwapOperation(\n            odosRouter,\n            address(inputToken),\n            amountInMaximum,\n            amountOut,\n            swapData\n        );\n\n        // If we received more than requested, transfer the surplus to the receiver\n        if (actualAmountOut > amountOut && receiver != address(this)) {\n            uint256 surplus = actualAmountOut - amountOut;\n            ERC20(outputToken).safeTransfer(receiver, surplus);\n        }\n\n        // Return the actual output amount\n        return actualAmountOut;\n    }\n}\n"
    },
    "contracts/vaults/dpool/core/DPoolVaultCurveLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"./DPoolVaultLP.sol\";\nimport \"./interfaces/ICurveStableSwapNG.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport \"./interfaces/IDPoolVaultLP.sol\";\n\n/**\n * @title DPoolVaultCurveLP\n * @author dTRINITY Protocol\n * @notice Curve-specific dPOOL vault implementation\n * @dev Handles Curve LP tokens as the primary asset, uses Curve's calc_withdraw_one_coin for external valuation only\n */\ncontract DPoolVaultCurveLP is DPoolVaultLP {\n    // --- Errors ---\n\n    /// @notice Thrown when base asset is not found in the Curve pool\n    error BaseAssetNotFoundInPool();\n\n    // --- Immutables ---\n\n    /// @notice Address of the Curve pool (same as LP token for Curve)\n    address public immutable POOL;\n\n    /// @notice Index of the base asset in the Curve pool (0 or 1) - used only for previewLPValue\n    int128 public immutable BASE_ASSET_INDEX;\n\n    // --- Constructor ---\n\n    /**\n     * @notice Initialize the Curve vault\n     * @param baseAsset Address of the base asset for external valuation (used only in previewLPValue)\n     * @param _lpToken Address of the Curve LP token (same as pool address)\n     * @param _pool Address of the Curve pool (same as LP token for Curve)\n     * @param name Vault token name\n     * @param symbol Vault token symbol\n     * @param admin Address to grant admin role\n     */\n    constructor(\n        address baseAsset,\n        address _lpToken,\n        address _pool,\n        string memory name,\n        string memory symbol,\n        address admin\n    ) DPoolVaultLP(_lpToken, name, symbol, admin) {\n        if (_pool == address(0)) revert ZeroAddress();\n\n        POOL = _pool;\n\n        // Auto-determine base asset index in pool for external valuation\n        ICurveStableSwapNG curvePool = ICurveStableSwapNG(_pool);\n        address coin0 = curvePool.coins(0);\n        address coin1 = curvePool.coins(1);\n\n        int128 calculatedIndex;\n        if (baseAsset == coin0) {\n            calculatedIndex = 0;\n        } else if (baseAsset == coin1) {\n            calculatedIndex = 1;\n        } else {\n            revert BaseAssetNotFoundInPool();\n        }\n\n        BASE_ASSET_INDEX = calculatedIndex;\n    }\n\n    // --- View functions ---\n\n    /**\n     * @notice Get the DEX pool address\n     * @return Address of the DEX pool\n     */\n    function pool() external view override returns (address) {\n        return POOL;\n    }\n\n    /**\n     * @notice Get the base asset index in the Curve pool\n     * @return Index of the base asset\n     */\n    function baseAssetIndex() external view returns (uint256) {\n        return uint256(int256(BASE_ASSET_INDEX));\n    }\n\n    /**\n     * @notice Preview base asset value for a given amount of LP tokens\n     * @dev This is an auxiliary function for external valuation, not used in core ERC4626 mechanics\n     * @param lpAmount Amount of LP tokens\n     * @return Base asset value\n     */\n    function previewLPValue(\n        uint256 lpAmount\n    ) external view override returns (uint256) {\n        if (lpAmount == 0) {\n            return 0;\n        }\n        return\n            ICurveStableSwapNG(POOL).calc_withdraw_one_coin(\n                lpAmount,\n                BASE_ASSET_INDEX\n            );\n    }\n}\n"
    },
    "contracts/vaults/dpool/core/DPoolVaultLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IDPoolVaultLP.sol\";\nimport \"../../../common/BasisPointConstants.sol\";\nimport \"../../../common/SupportsWithdrawalFee.sol\";\n\n/**\n * @title DPoolVaultLP\n * @author dTRINITY Protocol\n * @notice Abstract base ERC4626 vault that accepts LP tokens as the primary asset\n * @dev Each vault represents a specific LP position on a specific DEX. The vault's asset() is the LP token itself.\n */\nabstract contract DPoolVaultLP is\n    ERC4626,\n    AccessControl,\n    ReentrancyGuard,\n    IDPoolVaultLP,\n    SupportsWithdrawalFee\n{\n    using SafeERC20 for IERC20;\n\n    // --- Constants ---\n\n    /// @notice Role identifier for fee management\n    bytes32 public constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\n\n    /// @notice Maximum withdrawal fee (5%)\n    uint256 public constant MAX_WITHDRAWAL_FEE_BPS_CONFIG =\n        5 * BasisPointConstants.ONE_PERCENT_BPS;\n\n    // --- Immutables ---\n\n    /// @notice Address of the LP token this vault accepts (same as asset())\n    address public immutable LP_TOKEN;\n\n    // --- State variables ---\n    // `withdrawalFeeBps_` (internal) is inherited from SupportsWithdrawalFee.sol\n\n    // --- Errors ---\n    // ZeroAddress and InsufficientLPTokens are inherited from IDPoolVaultLP interface\n    // FeeExceedsMaxFee and InitialFeeExceedsMaxFee are inherited from SupportsWithdrawalFee\n\n    // --- Constructor ---\n\n    /**\n     * @notice Initialize the vault\n     * @param _lpToken Address of the LP token this vault accepts (becomes the ERC4626 asset)\n     * @param name Vault token name\n     * @param symbol Vault token symbol\n     * @param admin Address to grant admin role\n     */\n    constructor(\n        address _lpToken,\n        string memory name,\n        string memory symbol,\n        address admin\n    ) ERC4626(IERC20(_lpToken)) ERC20(name, symbol) {\n        if (_lpToken == address(0)) revert ZeroAddress();\n        if (admin == address(0)) revert ZeroAddress();\n\n        LP_TOKEN = _lpToken;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(FEE_MANAGER_ROLE, admin);\n        _initializeWithdrawalFee(0); // Initialize fee to 0 via SupportsWithdrawalFee\n    }\n\n    // --- SupportsWithdrawalFee Implementation ---\n    function _maxWithdrawalFeeBps()\n        internal\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return MAX_WITHDRAWAL_FEE_BPS_CONFIG;\n    }\n\n    /**\n     * @notice Public getter for the current withdrawal fee in basis points.\n     * @dev Satisfies IDPoolVaultLP interface and provides public access to the fee.\n     */\n    function withdrawalFeeBps() external view override returns (uint256) {\n        return getWithdrawalFeeBps(); // Uses public getter from SupportsWithdrawalFee\n    }\n\n    // --- View functions ---\n\n    /// @inheritdoc IDPoolVaultLP\n    function lpToken() external view override returns (address) {\n        return LP_TOKEN;\n    }\n\n    /// @inheritdoc IDPoolVaultLP\n    // This function provides the configured max fee, mirroring the constant.\n    function maxWithdrawalFeeBps() external pure override returns (uint256) {\n        return MAX_WITHDRAWAL_FEE_BPS_CONFIG;\n    }\n\n    // --- Abstract functions ---\n\n    /**\n     * @notice Get the DEX pool address - must be implemented by each DEX-specific vault\n     * @return Address of the DEX pool\n     */\n    function pool() external view virtual override returns (address);\n\n    /**\n     * @notice Preview base asset value for LP tokens - must be implemented by each DEX-specific vault\n     * @dev This is an auxiliary function for external valuation, not used in core ERC4626 mechanics\n     * @param lpAmount Amount of LP tokens\n     * @return Base asset value\n     */\n    function previewLPValue(\n        uint256 lpAmount\n    ) external view virtual override returns (uint256);\n\n    /// @inheritdoc IDPoolVaultLP\n    function previewDepositLP(\n        uint256 lpAmount\n    ) external view override returns (uint256 shares) {\n        return previewDeposit(lpAmount);\n    }\n\n    // --- ERC4626 Overrides for Fee Integration ---\n\n    /**\n     * @inheritdoc ERC4626\n     * @dev Preview withdraw including withdrawal fee.\n     *      The `assets` parameter is the net amount of LP tokens the user wants to receive.\n     */\n    function previewWithdraw(\n        uint256 assets\n    ) public view virtual override(ERC4626, IERC4626) returns (uint256 shares) {\n        uint256 grossAssetsRequired = _getGrossAmountRequiredForNet(assets);\n        return super.previewWithdraw(grossAssetsRequired);\n    }\n\n    /**\n     * @inheritdoc ERC4626\n     * @dev Preview redeem including withdrawal fee.\n     *      Calculates gross assets from shares, then deducts fee to show net assets user receives.\n     */\n    function previewRedeem(\n        uint256 shares\n    ) public view virtual override(ERC4626, IERC4626) returns (uint256 assets) {\n        uint256 grossAssets = super.previewRedeem(shares);\n        return _getNetAmountAfterFee(grossAssets);\n    }\n\n    // --- Deposit/withdrawal logic ---\n\n    /**\n     * @dev Override to handle LP token deposits\n     * @param lpAmount Amount of LP tokens to deposit\n     * @param receiver Address to receive vault shares\n     * @return shares_ Amount of shares minted\n     */\n    function deposit(\n        uint256 lpAmount,\n        address receiver\n    )\n        public\n        virtual\n        override(ERC4626, IERC4626)\n        nonReentrant\n        returns (uint256 shares_)\n    {\n        require(\n            lpAmount <= maxDeposit(receiver),\n            \"ERC4626: deposit more than max\"\n        );\n\n        shares_ = previewDeposit(lpAmount);\n        _deposit(_msgSender(), receiver, lpAmount, shares_);\n\n        return shares_;\n    }\n\n    /**\n     * @dev Override to handle LP token withdrawals with fees\n     * @param lpAmount This is the net amount of LP tokens the user wants to receive.\n     * @param receiver Address to receive LP tokens\n     * @param owner Address that owns the shares\n     * @return shares_ Amount of shares burned\n     */\n    function withdraw(\n        uint256 lpAmount,\n        address receiver,\n        address owner\n    )\n        public\n        virtual\n        override(ERC4626, IERC4626)\n        nonReentrant\n        returns (uint256 shares_)\n    {\n        shares_ = previewWithdraw(lpAmount);\n        uint256 grossLpAmount = convertToAssets(shares_);\n\n        require(\n            grossLpAmount <= maxWithdraw(owner),\n            \"ERC4626: withdraw more than max\"\n        );\n\n        _withdraw(_msgSender(), receiver, owner, grossLpAmount, shares_);\n\n        return shares_;\n    }\n\n    /**\n     * @dev Internal deposit function\n     * @param caller Address calling the deposit\n     * @param receiver Address to receive shares\n     * @param lpAmount Amount of LP tokens being deposited\n     * @param shares Amount of shares to mint\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 lpAmount,\n        uint256 shares\n    ) internal virtual override {\n        IERC20(LP_TOKEN).safeTransferFrom(caller, address(this), lpAmount);\n        _mint(receiver, shares);\n        emit Deposit(caller, receiver, lpAmount, shares);\n    }\n\n    /**\n     * @dev Internal withdraw function with fee handling\n     * @param caller Address calling the withdrawal\n     * @param receiver Address to receive LP tokens\n     * @param owner Address that owns the shares\n     * @param grossLpAmount Amount of LP tokens to withdraw (gross amount, before fees)\n     * @param shares Amount of shares to burn\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 grossLpAmount,\n        uint256 shares\n    ) internal virtual override {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        uint256 feeInLP = _calculateWithdrawalFee(grossLpAmount);\n        uint256 lpTokensToSend = grossLpAmount - feeInLP;\n\n        uint256 lpBalance = IERC20(LP_TOKEN).balanceOf(address(this));\n        if (lpBalance < grossLpAmount) {\n            revert InsufficientLPTokens();\n        }\n\n        _burn(owner, shares);\n        IERC20(LP_TOKEN).safeTransfer(receiver, lpTokensToSend);\n\n        // Emit ERC4626 Withdraw event with the NET LP tokens that were actually sent to the receiver\n        emit Withdraw(caller, receiver, owner, lpTokensToSend, shares);\n    }\n\n    // --- Fee management ---\n\n    /// @inheritdoc IDPoolVaultLP\n    function setWithdrawalFee(\n        uint256 newFeeBps\n    ) external override onlyRole(FEE_MANAGER_ROLE) {\n        _setWithdrawalFee(newFeeBps);\n    }\n\n    // --- Access control ---\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControl) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/vaults/dpool/core/interfaces/ICurveStableSwapNG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface ICurveStableSwapNG {\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external returns (uint256);\n\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[] calldata amounts,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[] calldata amounts,\n        uint256 min_mint_amount,\n        address receiver\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 burn_amount,\n        int128 i,\n        uint256 min_received\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 burn_amount,\n        int128 i,\n        uint256 min_received,\n        address receiver\n    ) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[] calldata amounts,\n        uint256 max_burn_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[] calldata amounts,\n        uint256 max_burn_amount,\n        address receiver\n    ) external returns (uint256);\n\n    function remove_liquidity(\n        uint256 burn_amount,\n        uint256[] calldata min_amounts\n    ) external returns (uint256[] memory);\n\n    function remove_liquidity(\n        uint256 burn_amount,\n        uint256[] calldata min_amounts,\n        address receiver\n    ) external returns (uint256[] memory);\n\n    function remove_liquidity(\n        uint256 burn_amount,\n        uint256[] calldata min_amounts,\n        address receiver,\n        bool claim_admin_fees\n    ) external returns (uint256[] memory);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_dx(\n        int128 i,\n        int128 j,\n        uint256 dy\n    ) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 burn_amount,\n        int128 i\n    ) external view returns (uint256);\n\n    function calc_token_amount(\n        uint256[] calldata amounts,\n        bool is_deposit\n    ) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function get_balances() external view returns (uint256[] memory);\n\n    function stored_rates() external view returns (uint256[] memory);\n\n    function dynamic_fee(int128 i, int128 j) external view returns (uint256);\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function coins(uint256 i) external view returns (address);\n\n    function fee() external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function offpeg_fee_multiplier() external view returns (uint256);\n\n    function A() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function balanceOf(address arg0) external view returns (uint256);\n\n    function allowance(\n        address arg0,\n        address arg1\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/vaults/dpool/core/interfaces/IDPoolVaultLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @title IDPoolVaultLP\n * @author dTRINITY Protocol\n * @notice Interface for dPOOL vault that accepts LP tokens as the primary asset\n * @dev Each vault represents a specific LP position on a specific DEX. The vault's asset() is the LP token.\n */\ninterface IDPoolVaultLP is IERC4626, IAccessControl {\n    // --- Events ---\n    // Note: WithdrawalFeeSet and WithdrawalFeeApplied events are inherited from SupportsWithdrawalFee\n\n    // --- Errors ---\n\n    /**\n     * @notice Thrown when zero address is provided where valid address is required\n     */\n    error ZeroAddress();\n\n    /**\n     * @notice Thrown when insufficient LP tokens for withdrawal\n     */\n    error InsufficientLPTokens();\n\n    // Note: FeeExceedsMaxFee and InitialFeeExceedsMaxFee errors are inherited from SupportsWithdrawalFee\n\n    // --- Vault Configuration ---\n\n    /**\n     * @notice Address of the LP token this vault accepts (same as asset())\n     * @return The LP token address\n     */\n    function lpToken() external view returns (address);\n\n    /**\n     * @notice Address of the DEX pool for this vault\n     * @return The pool address\n     */\n    function pool() external view returns (address);\n\n    /**\n     * @notice Current withdrawal fee in basis points\n     * @return Withdrawal fee in basis points\n     */\n    function withdrawalFeeBps() external view returns (uint256);\n\n    /**\n     * @notice Maximum allowed withdrawal fee in basis points\n     * @return Maximum withdrawal fee in basis points\n     */\n    function maxWithdrawalFeeBps() external view returns (uint256);\n\n    // --- Fee Management ---\n\n    /**\n     * @notice Set withdrawal fee (only FEE_MANAGER_ROLE)\n     * @param newFeeBps New withdrawal fee in basis points\n     */\n    function setWithdrawalFee(uint256 newFeeBps) external;\n\n    // --- Preview Functions ---\n\n    /**\n     * @notice Preview shares received for LP token deposit\n     * @param lpAmount Amount of LP tokens to deposit\n     * @return shares Amount of shares that would be minted\n     */\n    function previewDepositLP(\n        uint256 lpAmount\n    ) external view returns (uint256 shares);\n\n    /**\n     * @notice Preview base asset value for a given amount of LP tokens\n     * @dev This is an auxiliary function for external valuation, not used in core ERC4626 mechanics\n     * @param lpAmount Amount of LP tokens\n     * @return Base asset value\n     */\n    function previewLPValue(uint256 lpAmount) external view returns (uint256);\n\n    // --- Roles ---\n\n    /**\n     * @notice Role identifier for fee management\n     */\n    function FEE_MANAGER_ROLE() external pure returns (bytes32);\n}\n"
    },
    "contracts/vaults/dstake/DStakeCollateralVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IDStakeCollateralVault} from \"./interfaces/IDStakeCollateralVault.sol\";\nimport {IDStableConversionAdapter} from \"./interfaces/IDStableConversionAdapter.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n// ---------------------------------------------------------------------------\n// Internal interface to query the router's public mapping without importing the\n// full router contract (avoids circular dependencies).\n// ---------------------------------------------------------------------------\ninterface IAdapterProvider {\n    function vaultAssetToAdapter(address) external view returns (address);\n}\n\n/**\n * @title DStakeCollateralVault\n * @notice Holds various yield-bearing/convertible ERC20 tokens (`vault assets`) managed by dSTAKE.\n * @dev Calculates the total value of these assets in terms of the underlying dStable asset\n *      using registered adapters. This contract is non-upgradeable but replaceable via\n *      DStakeToken governance.\n *      Uses AccessControl for role-based access control.\n */\ncontract DStakeCollateralVault is IDStakeCollateralVault, AccessControl {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // --- Roles ---\n    bytes32 public constant ROUTER_ROLE = keccak256(\"ROUTER_ROLE\");\n\n    // --- Errors ---\n    error ZeroAddress();\n    error AssetNotSupported(address asset);\n    error AssetAlreadySupported(address asset);\n    error NonZeroBalance(address asset);\n\n    // --- State ---\n    address public immutable dStakeToken; // The DStakeToken this vault serves\n    address public immutable dStable; // The underlying dStable asset address\n\n    address public router; // The DStakeRouter allowed to interact\n\n    EnumerableSet.AddressSet private _supportedAssets; // Set of supported vault assets\n\n    // --- Constructor ---\n    constructor(address _dStakeVaultShare, address _dStableAsset) {\n        if (_dStakeVaultShare == address(0) || _dStableAsset == address(0)) {\n            revert ZeroAddress();\n        }\n        dStakeToken = _dStakeVaultShare;\n        dStable = _dStableAsset;\n\n        // Set up the DEFAULT_ADMIN_ROLE initially to the contract deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // --- External Views (IDStakeCollateralVault Interface) ---\n\n    /**\n     * @inheritdoc IDStakeCollateralVault\n     */\n    function totalValueInDStable()\n        external\n        view\n        override\n        returns (uint256 dStableValue)\n    {\n        uint256 totalValue = 0;\n        uint256 len = _supportedAssets.length();\n        for (uint256 i = 0; i < len; i++) {\n            address vaultAsset = _supportedAssets.at(i);\n            address adapterAddress = IAdapterProvider(router)\n                .vaultAssetToAdapter(vaultAsset);\n            if (adapterAddress != address(0)) {\n                uint256 balance = IERC20(vaultAsset).balanceOf(address(this));\n                if (balance > 0) {\n                    totalValue += IDStableConversionAdapter(adapterAddress)\n                        .assetValueInDStable(vaultAsset, balance);\n                }\n            }\n        }\n        return totalValue;\n    }\n\n    // --- External Functions (Router Interactions) ---\n\n    /**\n     * @notice Transfers `amount` of `vaultAsset` from this vault to `recipient`.\n     * @dev Only callable by the registered router (ROUTER_ROLE).\n     */\n    function sendAsset(\n        address vaultAsset,\n        uint256 amount,\n        address recipient\n    ) external onlyRole(ROUTER_ROLE) {\n        if (!_isSupported(vaultAsset)) revert AssetNotSupported(vaultAsset);\n        IERC20(vaultAsset).safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @notice Adds a new supported vault asset. Can only be invoked by the router.\n     */\n    function addSupportedAsset(\n        address vaultAsset\n    ) external onlyRole(ROUTER_ROLE) {\n        if (vaultAsset == address(0)) revert ZeroAddress();\n        if (_isSupported(vaultAsset)) revert AssetAlreadySupported(vaultAsset);\n\n        _supportedAssets.add(vaultAsset);\n        emit SupportedAssetAdded(vaultAsset);\n    }\n\n    /**\n     * @notice Removes a supported vault asset. Can only be invoked by the router.\n     *         Requires the vault to hold zero balance of the asset.\n     */\n    function removeSupportedAsset(\n        address vaultAsset\n    ) external onlyRole(ROUTER_ROLE) {\n        if (!_isSupported(vaultAsset)) revert AssetNotSupported(vaultAsset);\n        if (IERC20(vaultAsset).balanceOf(address(this)) > 0) {\n            revert NonZeroBalance(vaultAsset);\n        }\n\n        _supportedAssets.remove(vaultAsset);\n        emit SupportedAssetRemoved(vaultAsset);\n    }\n\n    // --- Governance Functions ---\n\n    /**\n     * @notice Sets the router address. Grants ROUTER_ROLE to new router and\n     *         revokes it from the previous router.\n     */\n    function setRouter(\n        address _newRouter\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_newRouter == address(0)) revert ZeroAddress();\n\n        // Revoke role from old router\n        if (router != address(0)) {\n            _revokeRole(ROUTER_ROLE, router);\n        }\n\n        _grantRole(ROUTER_ROLE, _newRouter);\n        router = _newRouter;\n        emit RouterSet(_newRouter);\n    }\n\n    // --- Internal Utilities ---\n\n    function _isSupported(address asset) private view returns (bool) {\n        return _supportedAssets.contains(asset);\n    }\n\n    // --- External Views ---\n\n    /**\n     * @notice Returns the vault asset at `index` from the internal supported set.\n     *         Kept for backwards-compatibility with the previous public array getter.\n     */\n    function supportedAssets(\n        uint256 index\n    ) external view override returns (address) {\n        return _supportedAssets.at(index);\n    }\n\n    /**\n     * @notice Returns the entire list of supported vault assets. Useful for UIs & off-chain tooling.\n     */\n    function getSupportedAssets() external view returns (address[] memory) {\n        return _supportedAssets.values();\n    }\n}\n"
    },
    "contracts/vaults/dstake/DStakeRouterDLend.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IDStakeRouter} from \"./interfaces/IDStakeRouter.sol\";\nimport {IDStableConversionAdapter} from \"./interfaces/IDStableConversionAdapter.sol\";\nimport {IDStakeCollateralVault} from \"./DStakeCollateralVault.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\n/**\n * @title DStakeRouterDLend\n * @notice Orchestrates deposits, withdrawals, and asset exchanges for a DStakeToken vault.\n * @dev Interacts with the DStakeToken, DStakeCollateralVault, and various IDStableConversionAdapters.\n *      This contract is non-upgradeable but replaceable via DStakeToken governance.\n *      Relies on the associated DStakeToken for role management.\n */\ncontract DStakeRouterDLend is IDStakeRouter, AccessControl {\n    using SafeERC20 for IERC20;\n\n    // --- Errors ---\n    error ZeroAddress();\n    error AdapterNotFound(address vaultAsset);\n    error ZeroPreviewWithdrawAmount(address vaultAsset);\n    error InsufficientDStableFromAdapter(\n        address vaultAsset,\n        uint256 expected,\n        uint256 actual\n    );\n    error VaultAssetManagedByDifferentAdapter(\n        address vaultAsset,\n        address existingAdapter\n    );\n    error ZeroInputDStableValue(address fromAsset, uint256 fromAmount);\n    error AdapterAssetMismatch(\n        address adapter,\n        address expectedAsset,\n        address actualAsset\n    );\n    error SlippageCheckFailed(\n        address toAsset,\n        uint256 calculatedAmount,\n        uint256 minAmount\n    );\n    error InconsistentState(string message);\n\n    // --- Roles ---\n    bytes32 public constant DSTAKE_TOKEN_ROLE = keccak256(\"DSTAKE_TOKEN_ROLE\");\n    bytes32 public constant COLLATERAL_EXCHANGER_ROLE =\n        keccak256(\"COLLATERAL_EXCHANGER_ROLE\");\n\n    // --- State ---\n    address public immutable dStakeToken; // The DStakeToken this router serves\n    IDStakeCollateralVault public immutable collateralVault; // The DStakeCollateralVault this router serves\n    address public immutable dStable; // The underlying dSTABLE asset address\n\n    // Governance-configurable risk parameters\n    uint256 public dustTolerance = 1; // 1 wei default tolerance\n\n    mapping(address => address) public vaultAssetToAdapter; // vaultAsset => adapterAddress\n    address public defaultDepositVaultAsset; // Default strategy for deposits\n\n    // Struct used to pack local variables in functions prone to \"stack too deep\" compiler errors\n    struct ExchangeLocals {\n        address fromAdapterAddress;\n        address toAdapterAddress;\n        IDStableConversionAdapter fromAdapter;\n        IDStableConversionAdapter toAdapter;\n        uint256 dStableValueIn;\n        uint256 calculatedToVaultAssetAmount;\n    }\n\n    // --- Constructor ---\n    constructor(address _dStakeToken, address _collateralVault) {\n        if (_dStakeToken == address(0) || _collateralVault == address(0)) {\n            revert ZeroAddress();\n        }\n        dStakeToken = _dStakeToken;\n        collateralVault = IDStakeCollateralVault(_collateralVault);\n        dStable = collateralVault.dStable(); // Fetch dStable address from vault\n        if (dStable == address(0)) {\n            revert ZeroAddress();\n        }\n\n        // Setup roles\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(DSTAKE_TOKEN_ROLE, _dStakeToken);\n    }\n\n    // --- External Functions (IDStakeRouter Interface) ---\n\n    /**\n     * @inheritdoc IDStakeRouter\n     */\n    function deposit(\n        uint256 dStableAmount,\n        address receiver\n    ) external override onlyRole(DSTAKE_TOKEN_ROLE) {\n        address adapterAddress = vaultAssetToAdapter[defaultDepositVaultAsset];\n        if (adapterAddress == address(0)) {\n            revert AdapterNotFound(defaultDepositVaultAsset);\n        }\n\n        (\n            address vaultAssetExpected,\n            uint256 expectedShares\n        ) = IDStableConversionAdapter(adapterAddress)\n                .previewConvertToVaultAsset(dStableAmount);\n\n        uint256 mintedShares = _executeDeposit(\n            adapterAddress,\n            vaultAssetExpected,\n            dStableAmount\n        );\n\n        if (mintedShares < expectedShares) {\n            revert SlippageCheckFailed(\n                vaultAssetExpected,\n                mintedShares,\n                expectedShares\n            );\n        }\n\n        emit Deposited(\n            vaultAssetExpected,\n            mintedShares,\n            dStableAmount,\n            receiver\n        );\n    }\n\n    /**\n     * @dev Performs the actual pull-approve-convert sequence and returns the number of shares\n     *      minted to the collateral vault.\n     * @param adapterAddress The adapter to use for conversion.\n     * @param vaultAssetExpected The vault asset that the adapter should mint.\n     * @param dStableAmount The amount of dStable being deposited.\n     * @return mintedShares The number of vault asset shares minted.\n     */\n    function _executeDeposit(\n        address adapterAddress,\n        address vaultAssetExpected,\n        uint256 dStableAmount\n    ) private returns (uint256 mintedShares) {\n        uint256 beforeBal = IERC20(vaultAssetExpected).balanceOf(\n            address(collateralVault)\n        );\n\n        // Pull dStable from caller (DStakeToken)\n        IERC20(dStable).safeTransferFrom(\n            msg.sender,\n            address(this),\n            dStableAmount\n        );\n\n        // Approve adapter to spend dStable\n        IERC20(dStable).approve(adapterAddress, dStableAmount);\n\n        // Convert dStable to vault asset (minted directly to collateral vault)\n        (\n            address vaultAssetActual,\n            uint256 reportedShares\n        ) = IDStableConversionAdapter(adapterAddress).convertToVaultAsset(\n                dStableAmount\n            );\n\n        if (vaultAssetActual != vaultAssetExpected) {\n            revert AdapterAssetMismatch(\n                adapterAddress,\n                vaultAssetExpected,\n                vaultAssetActual\n            );\n        }\n\n        mintedShares =\n            IERC20(vaultAssetExpected).balanceOf(address(collateralVault)) -\n            beforeBal;\n\n        if (mintedShares != reportedShares) {\n            revert InconsistentState(\"Adapter mis-reported shares\");\n        }\n    }\n\n    /**\n     * @inheritdoc IDStakeRouter\n     */\n    function withdraw(\n        uint256 dStableAmount,\n        address receiver,\n        address owner\n    ) external override onlyRole(DSTAKE_TOKEN_ROLE) {\n        address adapterAddress = vaultAssetToAdapter[defaultDepositVaultAsset];\n        if (adapterAddress == address(0)) {\n            revert AdapterNotFound(defaultDepositVaultAsset);\n        }\n        IDStableConversionAdapter adapter = IDStableConversionAdapter(\n            adapterAddress\n        );\n\n        // 1. Determine vault asset and required amount\n        address vaultAsset = adapter.vaultAsset();\n        // Use previewConvertFromVaultAsset to get the required vaultAssetAmount for the target dStableAmount\n        uint256 vaultAssetAmount = IERC4626(vaultAsset).previewWithdraw(\n            dStableAmount\n        );\n        if (vaultAssetAmount == 0) revert ZeroPreviewWithdrawAmount(vaultAsset);\n\n        // 2. Pull vaultAsset from collateral vault\n        collateralVault.sendAsset(vaultAsset, vaultAssetAmount, address(this));\n\n        // 3. Approve adapter (set required allowance using standard approve)\n        IERC20(vaultAsset).approve(adapterAddress, vaultAssetAmount);\n\n        // 4. Call adapter to convert and send dStable to receiver\n        // Temporarily transfer to this contract, then forward to receiver if needed\n        uint256 receivedDStable = adapter.convertFromVaultAsset(\n            vaultAssetAmount\n        );\n\n        // Sanity check: Ensure adapter returned at least the requested amount\n        if (receivedDStable < dStableAmount) {\n            revert InsufficientDStableFromAdapter(\n                vaultAsset,\n                dStableAmount,\n                receivedDStable\n            );\n        }\n\n        // 5. Transfer ONLY the requested amount to the user\n        IERC20(dStable).safeTransfer(receiver, dStableAmount);\n\n        // 6. If adapter over-delivered, immediately convert the surplus dStable\n        //    back into vault-asset shares so the value is reflected in\n        //    totalAssets() for all shareholders.\n        uint256 surplus = receivedDStable - dStableAmount;\n        if (surplus > 0) {\n            // Give the adapter allowance to pull the surplus\n            IERC20(dStable).approve(adapterAddress, surplus);\n\n            // Convert surplus dStable  vault asset (minted directly to the vault)\n            (address mintedAsset, ) = adapter.convertToVaultAsset(surplus);\n\n            // Sanity: adapter must mint the same asset we just redeemed from\n            if (mintedAsset != vaultAsset) {\n                revert AdapterAssetMismatch(\n                    adapterAddress,\n                    vaultAsset,\n                    mintedAsset\n                );\n            }\n\n            // Shares minted directly to collateralVault; surplus value now captured in accounting\n        }\n\n        emit Withdrawn(\n            vaultAsset,\n            vaultAssetAmount,\n            dStableAmount,\n            owner,\n            receiver\n        );\n    }\n\n    // --- External Functions (Exchange/Rebalance) ---\n\n    /**\n     * @notice Exchanges `fromVaultAssetAmount` of one vault asset for another via their adapters.\n     * @dev Uses dSTABLE as the intermediary asset. Requires COLLATERAL_EXCHANGER_ROLE.\n     * @param fromVaultAsset The address of the asset to sell.\n     * @param toVaultAsset The address of the asset to buy.\n     * @param fromVaultAssetAmount The amount of the `fromVaultAsset` to exchange.\n     * @param minToVaultAssetAmount The minimum amount of `toVaultAsset` the solver is willing to accept.\n     */\n    function exchangeAssetsUsingAdapters(\n        address fromVaultAsset,\n        address toVaultAsset,\n        uint256 fromVaultAssetAmount,\n        uint256 minToVaultAssetAmount\n    ) external onlyRole(COLLATERAL_EXCHANGER_ROLE) {\n        address fromAdapterAddress = vaultAssetToAdapter[fromVaultAsset];\n        address toAdapterAddress = vaultAssetToAdapter[toVaultAsset];\n        if (fromAdapterAddress == address(0))\n            revert AdapterNotFound(fromVaultAsset);\n        if (toAdapterAddress == address(0))\n            revert AdapterNotFound(toVaultAsset);\n\n        IDStableConversionAdapter fromAdapter = IDStableConversionAdapter(\n            fromAdapterAddress\n        );\n        IDStableConversionAdapter toAdapter = IDStableConversionAdapter(\n            toAdapterAddress\n        );\n\n        // 1. Get assets and calculate equivalent dStable amount\n        uint256 dStableAmountEquivalent = fromAdapter\n            .previewConvertFromVaultAsset(fromVaultAssetAmount);\n\n        // 2. Pull fromVaultAsset from collateral vault\n        collateralVault.sendAsset(\n            fromVaultAsset,\n            fromVaultAssetAmount,\n            address(this)\n        );\n\n        // 3. Approve fromAdapter & Convert fromVaultAsset -> dStable (sent to this router)\n        IERC20(fromVaultAsset).approve(\n            fromAdapterAddress,\n            fromVaultAssetAmount\n        );\n        uint256 receivedDStable = fromAdapter.convertFromVaultAsset(\n            fromVaultAssetAmount\n        );\n\n        // 4. Approve toAdapter & Convert dStable -> toVaultAsset (sent to collateralVault)\n        IERC20(dStable).approve(toAdapterAddress, receivedDStable);\n        (\n            address actualToVaultAsset,\n            uint256 resultingToVaultAssetAmount\n        ) = toAdapter.convertToVaultAsset(receivedDStable);\n        require(actualToVaultAsset == toVaultAsset, \"Adapter asset mismatch\");\n        // Slippage control: ensure output meets minimum requirement\n        if (resultingToVaultAssetAmount < minToVaultAssetAmount) {\n            revert SlippageCheckFailed(\n                toVaultAsset,\n                resultingToVaultAssetAmount,\n                minToVaultAssetAmount\n            );\n        }\n\n        // --- Underlying value parity check ---\n        uint256 resultingDStableEquivalent = toAdapter\n            .previewConvertFromVaultAsset(resultingToVaultAssetAmount);\n\n        // Rely on Solidity 0.8 checked arithmetic: if `dustTolerance` is greater than\n        // `dStableAmountEquivalent`, the subtraction will underflow and the transaction\n        // will revert automatically. This saves gas compared to a ternary guard.\n        uint256 minRequiredDStable = dStableAmountEquivalent - dustTolerance;\n\n        if (resultingDStableEquivalent < minRequiredDStable) {\n            revert SlippageCheckFailed(\n                dStable,\n                resultingDStableEquivalent,\n                minRequiredDStable\n            );\n        }\n\n        emit Exchanged(\n            fromVaultAsset,\n            toVaultAsset,\n            fromVaultAssetAmount,\n            resultingToVaultAssetAmount,\n            dStableAmountEquivalent,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Exchanges assets between the collateral vault and an external solver.\n     * @dev Pulls `fromVaultAsset` from the solver (`msg.sender`) and sends `toVaultAsset` from the vault to the solver.\n     *      Requires COLLATERAL_EXCHANGER_ROLE.\n     * @param fromVaultAsset The address of the asset the solver is providing.\n     * @param toVaultAsset The address of the asset the solver will receive from the vault.\n     * @param fromVaultAssetAmount The amount of `fromVaultAsset` provided by the solver.\n     * @param minToVaultAssetAmount The minimum amount of `toVaultAsset` the solver is willing to accept.\n     */\n    function exchangeAssets(\n        address fromVaultAsset,\n        address toVaultAsset,\n        uint256 fromVaultAssetAmount,\n        uint256 minToVaultAssetAmount\n    ) external onlyRole(COLLATERAL_EXCHANGER_ROLE) {\n        if (fromVaultAssetAmount == 0) {\n            revert InconsistentState(\"Input amount cannot be zero\");\n        }\n        if (fromVaultAsset == address(0) || toVaultAsset == address(0)) {\n            revert ZeroAddress();\n        }\n\n        ExchangeLocals memory locals;\n\n        // Resolve adapters\n        locals.fromAdapterAddress = vaultAssetToAdapter[fromVaultAsset];\n        locals.toAdapterAddress = vaultAssetToAdapter[toVaultAsset];\n\n        if (locals.fromAdapterAddress == address(0))\n            revert AdapterNotFound(fromVaultAsset);\n        if (locals.toAdapterAddress == address(0))\n            revert AdapterNotFound(toVaultAsset);\n\n        locals.fromAdapter = IDStableConversionAdapter(\n            locals.fromAdapterAddress\n        );\n        locals.toAdapter = IDStableConversionAdapter(locals.toAdapterAddress);\n\n        // Calculate dStable received for the input asset\n        locals.dStableValueIn = locals.fromAdapter.previewConvertFromVaultAsset(\n            fromVaultAssetAmount\n        );\n        if (locals.dStableValueIn == 0) {\n            revert ZeroInputDStableValue(fromVaultAsset, fromVaultAssetAmount);\n        }\n\n        // Calculate expected output vault asset amount\n        (address expectedToAsset, uint256 tmpToAmount) = locals\n            .toAdapter\n            .previewConvertToVaultAsset(locals.dStableValueIn);\n\n        if (expectedToAsset != toVaultAsset) {\n            revert AdapterAssetMismatch(\n                locals.toAdapterAddress,\n                toVaultAsset,\n                expectedToAsset\n            );\n        }\n\n        locals.calculatedToVaultAssetAmount = tmpToAmount;\n\n        // Slippage check\n        if (locals.calculatedToVaultAssetAmount < minToVaultAssetAmount) {\n            revert SlippageCheckFailed(\n                toVaultAsset,\n                locals.calculatedToVaultAssetAmount,\n                minToVaultAssetAmount\n            );\n        }\n\n        // --- Asset movements ---\n\n        // 1. Pull `fromVaultAsset` from solver to this contract\n        IERC20(fromVaultAsset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            fromVaultAssetAmount\n        );\n\n        // 2. Transfer the asset into the collateral vault\n        IERC20(fromVaultAsset).safeTransfer(\n            address(collateralVault),\n            fromVaultAssetAmount\n        );\n\n        // 3. Send the calculated amount of `toVaultAsset` to the solver\n        collateralVault.sendAsset(\n            toVaultAsset,\n            locals.calculatedToVaultAssetAmount,\n            msg.sender\n        );\n\n        emit Exchanged(\n            fromVaultAsset,\n            toVaultAsset,\n            fromVaultAssetAmount,\n            locals.calculatedToVaultAssetAmount,\n            locals.dStableValueIn,\n            msg.sender\n        );\n    }\n\n    // --- External Functions (Governance - Managed by Admin) ---\n\n    /**\n     * @notice Adds or updates a conversion adapter for a given vault asset.\n     * @dev Only callable by an address with DEFAULT_ADMIN_ROLE.\n     * @param vaultAsset The address of the vault asset.\n     * @param adapterAddress The address of the new adapter contract.\n     */\n    function addAdapter(\n        address vaultAsset,\n        address adapterAddress\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (adapterAddress == address(0) || vaultAsset == address(0)) {\n            revert ZeroAddress();\n        }\n        address adapterVaultAsset = IDStableConversionAdapter(adapterAddress)\n            .vaultAsset();\n        if (adapterVaultAsset != vaultAsset)\n            revert AdapterAssetMismatch(\n                adapterAddress,\n                vaultAsset,\n                adapterVaultAsset\n            );\n        if (\n            vaultAssetToAdapter[vaultAsset] != address(0) &&\n            vaultAssetToAdapter[vaultAsset] != adapterAddress\n        ) {\n            revert VaultAssetManagedByDifferentAdapter(\n                vaultAsset,\n                vaultAssetToAdapter[vaultAsset]\n            );\n        }\n        vaultAssetToAdapter[vaultAsset] = adapterAddress;\n\n        // Inform the collateral vault of the new supported asset list (no-op if already added)\n        try collateralVault.addSupportedAsset(vaultAsset) {} catch {}\n\n        emit AdapterSet(vaultAsset, adapterAddress);\n    }\n\n    /**\n     * @notice Removes a conversion adapter for a given vault asset.\n     * @dev Only callable by an address with DEFAULT_ADMIN_ROLE.\n     * @dev Does not automatically migrate funds. Ensure assets managed by this adapter are zero\n     *      in the collateral vault or migrated via exchangeAssets before calling.\n     * @param vaultAsset The address of the vault asset to remove.\n     */\n    function removeAdapter(\n        address vaultAsset\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        address adapterAddress = vaultAssetToAdapter[vaultAsset];\n        if (adapterAddress == address(0)) {\n            revert AdapterNotFound(vaultAsset);\n        }\n        delete vaultAssetToAdapter[vaultAsset];\n\n        // Inform the collateral vault to remove supported asset (ignore if not present)\n        try collateralVault.removeSupportedAsset(vaultAsset) {} catch {}\n\n        emit AdapterRemoved(vaultAsset, adapterAddress);\n    }\n\n    /**\n     * @notice Sets the default vault asset to use for new deposits.\n     * @dev Only callable by an address with DEFAULT_ADMIN_ROLE.\n     * @param vaultAsset The address of the vault asset to set as default.\n     */\n    function setDefaultDepositVaultAsset(\n        address vaultAsset\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (vaultAssetToAdapter[vaultAsset] == address(0)) {\n            revert AdapterNotFound(vaultAsset);\n        }\n        defaultDepositVaultAsset = vaultAsset;\n        emit DefaultDepositVaultAssetSet(vaultAsset);\n    }\n\n    // --- Events ---\n    event Deposited(\n        address indexed vaultAsset,\n        uint256 vaultAssetAmount,\n        uint256 dStableAmount,\n        address receiver\n    );\n    event Withdrawn(\n        address indexed vaultAsset,\n        uint256 vaultAssetAmount,\n        uint256 dStableAmount,\n        address owner,\n        address receiver\n    );\n    event Exchanged(\n        address indexed fromAsset,\n        address indexed toAsset,\n        uint256 fromAssetAmount,\n        uint256 toAssetAmount,\n        uint256 dStableAmountEquivalent,\n        address indexed exchanger\n    );\n    event AdapterSet(address indexed vaultAsset, address adapterAddress);\n    event AdapterRemoved(address indexed vaultAsset, address adapterAddress);\n    event DefaultDepositVaultAssetSet(address indexed vaultAsset);\n    event DustToleranceSet(uint256 newDustTolerance);\n\n    // --- Governance setters ---\n\n    /**\n     * @notice Updates the `dustTolerance` used for value-parity checks.\n     * @dev Only callable by DEFAULT_ADMIN_ROLE.\n     * @param _dustTolerance The new tolerance value in wei of dStable.\n     */\n    function setDustTolerance(\n        uint256 _dustTolerance\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        dustTolerance = _dustTolerance;\n        emit DustToleranceSet(_dustTolerance);\n    }\n}\n"
    },
    "contracts/vaults/dstake/DStakeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ERC4626Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDStakeCollateralVault} from \"./interfaces/IDStakeCollateralVault.sol\";\nimport {IDStakeRouter} from \"./interfaces/IDStakeRouter.sol\";\nimport {BasisPointConstants} from \"../../common/BasisPointConstants.sol\";\nimport {SupportsWithdrawalFee} from \"../../common/SupportsWithdrawalFee.sol\";\n\n/**\n * @title DStakeToken\n * @dev ERC4626-compliant token representing shares in the DStakeCollateralVault.\n */\ncontract DStakeToken is\n    Initializable,\n    ERC4626Upgradeable,\n    AccessControlUpgradeable,\n    SupportsWithdrawalFee\n{\n    // --- Roles ---\n    bytes32 public constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\n\n    // --- Errors ---\n    error ZeroAddress();\n\n    // --- State ---\n    IDStakeCollateralVault public collateralVault;\n    IDStakeRouter public router;\n\n    uint256 public constant MAX_WITHDRAWAL_FEE_BPS =\n        BasisPointConstants.ONE_PERCENT_BPS;\n\n    // --- Initializer ---\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IERC20 _dStable,\n        string memory _name,\n        string memory _symbol,\n        address _initialAdmin,\n        address _initialFeeManager\n    ) public initializer {\n        __ERC20_init(_name, _symbol);\n        __ERC4626_init(_dStable);\n        __AccessControl_init();\n        _initializeWithdrawalFee(0);\n\n        if (\n            address(_dStable) == address(0) ||\n            _initialAdmin == address(0) ||\n            _initialFeeManager == address(0)\n        ) {\n            revert ZeroAddress();\n        }\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _initialAdmin);\n        _grantRole(FEE_MANAGER_ROLE, _initialFeeManager);\n    }\n\n    // --- SupportsWithdrawalFee Implementation ---\n    function _maxWithdrawalFeeBps()\n        internal\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return MAX_WITHDRAWAL_FEE_BPS;\n    }\n\n    /**\n     * @notice Public getter for the current withdrawal fee in basis points.\n     */\n    function withdrawalFeeBps() public view returns (uint256) {\n        return getWithdrawalFeeBps(); // Uses getter from SupportsWithdrawalFee\n    }\n\n    /**\n     * @notice Public getter for the maximum withdrawal fee in basis points.\n     */\n    function maxWithdrawalFeeBps() public view returns (uint256) {\n        return MAX_WITHDRAWAL_FEE_BPS;\n    }\n\n    // --- ERC4626 Overrides ---\n\n    /**\n     * @inheritdoc ERC4626Upgradeable\n     * @dev\n     * IMPORTANT: When all vault shares have been redeemed, the router intentionally\n     * leaves up to `dustTolerance` (1 wei by default) of wrapper tokens in the\n     * `DStakeCollateralVault`. These wrapper tokens continue to accrue\n     * yield via an ever-increasing price-per-share. As a result, it is\n     * theoretically possible for `totalSupply() == 0` while `totalAssets()`\n     * returns a non-zero value.\n     *\n     * The protocol explicitly accepts that the **first depositor after such a\n     * complete withdrawal will receive whatever residual value has\n     * accumulated**.  Given the minuscule starting balance ( 1 wei) and slow\n     * growth rate, the team judged that the gas cost of enforcing a strict\n     * invariant outweighed the negligible windfall.\n     *\n     * Please keep this in mind if `dustTolerance` is increased to a non-negligible value.\n     */\n    function totalAssets() public view virtual override returns (uint256) {\n        if (address(collateralVault) == address(0)) {\n            return 0;\n        }\n        return collateralVault.totalValueInDStable();\n    }\n\n    /**\n     * @dev Pulls dSTABLE asset from depositor, then delegates the core deposit logic\n     *      (converting dSTABLE to vault assets) to the router.\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        if (\n            address(router) == address(0) ||\n            address(collateralVault) == address(0)\n        ) {\n            revert ZeroAddress(); // Router or Vault not set\n        }\n\n        // Pull assets from caller\n        super._deposit(caller, receiver, assets, shares); // This handles the ERC20 transfer\n\n        // Approve router to spend the received assets (necessary because super._deposit transfers to this contract)\n        IERC20(asset()).approve(address(router), assets);\n\n        // Delegate conversion and vault update logic to router\n        router.deposit(assets, receiver);\n    }\n\n    /**\n     * @dev Override to handle withdrawals with fees correctly.\n     *      The `assets` parameter is the net amount of assets the user wants to receive.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256 shares) {\n        // Calculate how many shares correspond to the desired NET `assets` amount.\n        shares = previewWithdraw(assets);\n\n        // Ensure the owner has enough shares to cover the withdrawal (checks in share terms rather than assets).\n        require(shares <= maxRedeem(owner), \"ERC4626: withdraw more than max\");\n\n        // Translate the shares back into the GROSS asset amount that needs to be withdrawn\n        // so that the internal logic can compute the fee only once.\n        uint256 grossAssets = convertToAssets(shares);\n\n        _withdraw(_msgSender(), receiver, owner, grossAssets, shares);\n        return shares;\n    }\n\n    /**\n     * @notice Returns the maximum NET assets that `owner` can withdraw taking the current\n     *         withdrawal fee into account.\n     *\n     *         OpenZeppelin's reference implementation returns the owner's share balance\n     *         converted to assets (i.e. a gross value).  In a fee-charging vault that\n     *         exposes `withdraw(netAssets)`, the intuitive expectation is that\n     *         `maxWithdraw` already reflects what the user will actually receive after\n     *         fees.  We therefore convert the share balance to GROSS assets first and then\n     *         subtract the fee.\n     */\n    function maxWithdraw(\n        address owner\n    ) public view virtual override returns (uint256) {\n        uint256 grossAssets = convertToAssets(balanceOf(owner));\n        return _getNetAmountAfterFee(grossAssets);\n    }\n\n    /**\n     * @dev Override to ensure the withdrawal fee is deducted only once.\n     *      The `shares` parameter is converted to its equivalent gross asset value, then the\n     *      internal _withdraw handles fee calculation. The returned value is the net assets\n     *      actually received by the `receiver`, matching previewRedeem().\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256 assets) {\n        uint256 grossAssets = convertToAssets(shares); // shares  gross assets before fee\n\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n\n        // Perform withdrawal using gross assets so that _withdraw computes the correct fee once\n        _withdraw(_msgSender(), receiver, owner, grossAssets, shares);\n\n        // Net assets the user effectively receives\n        assets = _getNetAmountAfterFee(grossAssets);\n        return assets;\n    }\n\n    /**\n     * @dev Calculates withdrawal fee, then delegates the core withdrawal logic\n     *      (converting vault assets back to dSTABLE) to the router.\n     *      The `assets` parameter is now the gross amount that needs to be withdrawn from the vault.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets, // This is now the GROSS amount\n        uint256 shares\n    ) internal virtual override {\n        if (\n            address(router) == address(0) ||\n            address(collateralVault) == address(0)\n        ) {\n            revert ZeroAddress(); // Router or Vault not set\n        }\n\n        uint256 fee = _calculateWithdrawalFee(assets); // Calculate fee on GROSS amount\n        uint256 amountToSend = assets - fee; // Send NET amount to user\n\n        // Burn shares from owner\n        _burn(owner, shares);\n\n        // Delegate conversion and vault update logic to router\n        // Router is responsible for ensuring `amountToSend` of dSTABLE reaches the `receiver`.\n        router.withdraw(amountToSend, receiver, owner);\n\n        // Emit ERC4626 Withdraw event with the NET assets that were actually sent\n        emit Withdraw(caller, receiver, owner, amountToSend, shares);\n\n        // Optional: Emit fee event\n        if (fee > 0) {\n            emit WithdrawalFee(owner, receiver, fee);\n        }\n    }\n\n    /**\n     * @dev Preview withdraw including withdrawal fee.\n     */\n    function previewWithdraw(\n        uint256 assets\n    ) public view virtual override returns (uint256) {\n        uint256 grossAssetsRequired = _getGrossAmountRequiredForNet(assets);\n        return super.previewWithdraw(grossAssetsRequired);\n    }\n\n    /**\n     * @dev Preview redeem including withdrawal fee.\n     */\n    function previewRedeem(\n        uint256 shares\n    ) public view virtual override returns (uint256) {\n        uint256 grossAssets = super.previewRedeem(shares);\n        return _getNetAmountAfterFee(grossAssets);\n    }\n\n    // --- Governance Functions ---\n\n    /**\n     * @notice Sets the address of the DStakeRouter contract.\n     * @dev Only callable by DEFAULT_ADMIN_ROLE.\n     * @param _router The address of the new router contract.\n     */\n    function setRouter(address _router) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_router == address(0)) {\n            revert ZeroAddress();\n        }\n        router = IDStakeRouter(_router);\n        emit RouterSet(_router);\n    }\n\n    /**\n     * @notice Sets the address of the DStakeCollateralVault contract.\n     * @dev Only callable by DEFAULT_ADMIN_ROLE.\n     * @param _collateralVault The address of the new collateral vault contract.\n     */\n    function setCollateralVault(\n        address _collateralVault\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_collateralVault == address(0)) {\n            revert ZeroAddress();\n        }\n        collateralVault = IDStakeCollateralVault(_collateralVault);\n        emit CollateralVaultSet(_collateralVault);\n    }\n\n    /**\n     * @notice Sets the withdrawal fee in basis points.\n     * @dev Requires FEE_MANAGER_ROLE.\n     * @param _feeBps The new withdrawal fee (e.g., 1000 = 0.1%).\n     */\n    function setWithdrawalFee(\n        uint256 _feeBps\n    ) external onlyRole(FEE_MANAGER_ROLE) {\n        _setWithdrawalFee(_feeBps);\n    }\n\n    // --- Events ---\n    event RouterSet(address indexed router);\n    event CollateralVaultSet(address indexed collateralVault);\n}\n"
    },
    "contracts/vaults/dstake/interfaces/IDStableConversionAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDStableConversionAdapter Interface\n * @notice Interface for contracts that handle the conversion between the core dStable asset\n *         and a specific yield-bearing or convertible ERC20 token (`vault asset`), as well as\n *         valuing that `vault asset` in terms of the dStable asset.\n * @dev Implementations interact with specific protocols (lending pools, DEX LPs, wrappers, etc.).\n */\ninterface IDStableConversionAdapter {\n    /**\n     * @notice Converts a specified amount of the dStable asset into the specific `vaultAsset`\n     *         managed by this adapter.\n     * @dev The adapter MUST pull `dStableAmount` of the dStable asset from the caller (expected to be the Router).\n     * @dev The resulting `vaultAsset` MUST be sent/deposited/minted directly to the `collateralVault` address provided during adapter setup or retrieved.\n     * @param dStableAmount The amount of dStable asset to convert.\n     * @return vaultAsset The address of the specific `vault asset` token managed by this adapter.\n     * @return vaultAssetAmount The amount of `vaultAsset` generated from the conversion.\n     */\n    function convertToVaultAsset(\n        uint256 dStableAmount\n    ) external returns (address vaultAsset, uint256 vaultAssetAmount);\n\n    /**\n     * @notice Converts a specific amount of `vaultAsset` back into the dStable asset.\n     * @dev The adapter MUST pull the required amount of `vaultAsset` from the caller (expected to be the Router).\n     * @dev The resulting dStable asset MUST be sent to the caller.\n     * @param vaultAssetAmount The amount of `vaultAsset` to convert.\n     * @return dStableAmount The amount of dStable asset sent to the caller.\n     */\n    function convertFromVaultAsset(\n        uint256 vaultAssetAmount\n    ) external returns (uint256 dStableAmount);\n\n    /**\n     * @notice Preview the result of converting a given dStable amount to vaultAsset (without state change).\n     * @param dStableAmount The amount of dStable asset to preview conversion for.\n     * @return vaultAsset The address of the specific `vault asset` token managed by this adapter.\n     * @return vaultAssetAmount The amount of `vaultAsset` that would be received.\n     */\n    function previewConvertToVaultAsset(\n        uint256 dStableAmount\n    ) external view returns (address vaultAsset, uint256 vaultAssetAmount);\n\n    /**\n     * @notice Preview the result of converting a given vaultAsset amount to dStable (without state change).\n     * @param vaultAssetAmount The amount of `vaultAsset` to preview conversion for.\n     * @return dStableAmount The amount of dStable asset that would be received.\n     */\n    function previewConvertFromVaultAsset(\n        uint256 vaultAssetAmount\n    ) external view returns (uint256 dStableAmount);\n\n    /**\n     * @notice Calculates the value of a given amount of the specific `vaultAsset` managed by this adapter\n     *         in terms of the dStable asset.\n     * @param vaultAsset The address of the vault asset token (should match getVaultAsset()). Included for explicitness.\n     * @param vaultAssetAmount The amount of the `vaultAsset` to value.\n     * @return dStableValue The equivalent value in the dStable asset.\n     */\n    function assetValueInDStable(\n        address vaultAsset,\n        uint256 vaultAssetAmount\n    ) external view returns (uint256 dStableValue);\n\n    /**\n     * @notice Returns the address of the specific `vault asset` token managed by this adapter.\n     * @return The address of the `vault asset`.\n     */\n    function vaultAsset() external view returns (address);\n}\n"
    },
    "contracts/vaults/dstake/interfaces/IDStakeCollateralVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDStakeCollateralVault Interface\n * @notice Defines the external functions of the DStakeCollateralVault required by other\n *         contracts in the dSTAKE system, primarily the DStakeToken.\n */\ninterface IDStakeCollateralVault {\n    /**\n     * @notice Calculates the total value of all managed `vault assets` held by the vault,\n     *         denominated in the underlying dStable asset.\n     * @dev This is typically called by the DStakeToken's `totalAssets()` function.\n     * @return dStableValue The total value of managed assets in terms of the dStable asset.\n     */\n    function totalValueInDStable() external view returns (uint256 dStableValue);\n\n    /**\n     * @notice Returns the address of the underlying dStable asset the vault operates with.\n     * @return The address of the dStable asset.\n     */\n    function dStable() external view returns (address);\n\n    /**\n     * @notice The DStakeToken contract address this vault serves.\n     */\n    function dStakeToken() external view returns (address);\n\n    /**\n     * @notice The DStakeRouter contract address allowed to interact.\n     */\n    function router() external view returns (address);\n\n    /**\n     * @notice Returns the vault asset at `index` from the internal supported list.\n     */\n    function supportedAssets(uint256 index) external view returns (address);\n\n    /**\n     * @notice Returns the entire list of supported vault assets. Convenient for UIs & off-chain analytics.\n     */\n    function getSupportedAssets() external view returns (address[] memory);\n\n    /**\n     * @notice Transfers `amount` of `vaultAsset` from this vault to the `recipient`.\n     * @dev Only callable by the registered router.\n     * @param vaultAsset The address of the vault asset to send.\n     * @param amount The amount to send.\n     * @param recipient The address to receive the asset.\n     */\n    function sendAsset(\n        address vaultAsset,\n        uint256 amount,\n        address recipient\n    ) external;\n\n    /**\n     * @notice Sets the address of the DStakeRouter contract.\n     * @dev Only callable by an address with the DEFAULT_ADMIN_ROLE.\n     * @param _newRouter The address of the new router contract.\n     */\n    function setRouter(address _newRouter) external;\n\n    /**\n     * @notice Adds a vault asset to the supported list. Callable only by the router.\n     */\n    function addSupportedAsset(address vaultAsset) external;\n\n    /**\n     * @notice Removes a vault asset from the supported list. Callable only by the router.\n     */\n    function removeSupportedAsset(address vaultAsset) external;\n\n    /**\n     * @notice Emitted when the router address is set.\n     * @param router The address of the new router.\n     */\n    event RouterSet(address indexed router);\n\n    /**\n     * @notice Emitted when a new vault asset is added to the supported list.\n     */\n    event SupportedAssetAdded(address indexed vaultAsset);\n\n    /**\n     * @notice Emitted when a vault asset is removed from the supported list.\n     */\n    event SupportedAssetRemoved(address indexed vaultAsset);\n}\n"
    },
    "contracts/vaults/dstake/interfaces/IDStakeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDStakeRouter Interface\n * @notice Defines the external functions of the DStakeRouter required by the DStakeToken\n *         for handling deposits and withdrawals.\n */\ninterface IDStakeRouter {\n    /**\n     * @notice Handles the conversion of deposited dStable asset into a chosen `vaultAsset`\n     *         and informs the collateral vault.\n     * @dev Called by `DStakeToken._deposit()` after the token has received the dStable asset.\n     * @dev The router MUST pull `dStableAmount` from the caller (`DStakeToken`).\n     * @param dStableAmount The amount of dStable asset deposited by the user into the DStakeToken.\n     * @param receiver The ultimate receiver of the minted dSTAKE shares (passed through for potential future use/events).\n     */\n    function deposit(uint256 dStableAmount, address receiver) external;\n\n    /**\n     * @notice Handles the conversion of a `vaultAsset` back into the dStable asset for withdrawal.\n     * @dev Called by `DStakeToken._withdraw()`.\n     * @dev The router coordinates pulling the required `vaultAsset` from the collateral vault\n     *      and ensuring the converted dStable asset is sent to the `receiver`.\n     * @param dStableAmount The amount of dStable asset to be withdrawn to the `receiver` (after vault fees).\n     * @param receiver The address that will receive the withdrawn dStable asset.\n     * @param owner The original owner initiating the withdrawal (typically the user burning shares).\n     */\n    function withdraw(\n        uint256 dStableAmount,\n        address receiver,\n        address owner\n    ) external;\n}\n"
    },
    "contracts/vaults/dstake/rewards/DStakeRewardManagerDLend.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {RewardClaimable} from \"../../rewards_claimable/RewardClaimable.sol\";\nimport {DStakeRouterDLend} from \"../DStakeRouterDLend.sol\";\nimport {IDStakeCollateralVault} from \"../interfaces/IDStakeCollateralVault.sol\";\nimport {IDStableConversionAdapter} from \"../interfaces/IDStableConversionAdapter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Interface for the Aave/dLEND RewardsController\ninterface IDLendRewardsController {\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to,\n        address reward\n    ) external returns (uint256);\n\n    function setClaimer(address user, address claimer) external;\n}\n\n/**\n * @title DStakeRewardManagerDLend\n * @notice Manages claiming of dLEND rewards earned by a specific StaticATokenLM wrapper\n *         (associated with a DStakeCollateralVault) and compounds dStable (provided by a caller)\n *         into the DStakeCollateralVault.\n * @dev Implements the RewardClaimable interface.\n *      The caller of `compoundRewards` provides dStable (the exchangeAsset). This contract\n *      then claims specified reward tokens earned by the `targetStaticATokenWrapper`.\n *      The net rewards (after treasury fee) are sent to the receiver specified by the caller.\n *      The initially provided dStable is then converted to the DStakeCollateralVault's\n *      default deposit asset and deposited into the vault.\n */\ncontract DStakeRewardManagerDLend is RewardClaimable {\n    using SafeERC20 for IERC20;\n\n    // --- State ---\n    address public immutable dStakeCollateralVault; // The ultimate beneficiary vault\n    DStakeRouterDLend public immutable dStakeRouter;\n    IDLendRewardsController public dLendRewardsController; // Settable by admin\n    address public immutable targetStaticATokenWrapper; // The StaticATokenLM instance earning rewards\n    address public immutable dLendAssetToClaimFor; // The actual aToken in dLEND held by the wrapper\n\n    // --- Events ---\n    event DLendRewardsControllerUpdated(\n        address oldController,\n        address newController\n    );\n    event ExchangeAssetProcessed(\n        address indexed vaultAsset,\n        uint256 vaultAssetAmount,\n        uint256 dStableCompoundedAmount\n    );\n\n    // --- Errors ---\n    error InvalidRouter();\n    error InvalidAdapter(address adapter);\n    error AdapterReturnedUnexpectedAsset(address expected, address actual);\n    error DefaultDepositAssetNotSet();\n    error AdapterNotSetForDefaultAsset();\n    // Errors also used/defined in RewardClaimable but declared here for clarity if inherited versions are not picked up\n    error ZeroAddress();\n\n    // --- Constructor ---\n    constructor(\n        address _dStakeCollateralVault,\n        address _dStakeRouter,\n        address _dLendRewardsController,\n        address _targetStaticATokenWrapper,\n        address _dLendAssetToClaimFor,\n        address _treasury,\n        uint256 _maxTreasuryFeeBps,\n        uint256 _initialTreasuryFeeBps,\n        uint256 _initialExchangeThreshold\n    )\n        RewardClaimable(\n            IDStakeCollateralVault(_dStakeCollateralVault).dStable(), // exchangeAsset is dStable\n            _treasury,\n            _maxTreasuryFeeBps,\n            _initialTreasuryFeeBps,\n            _initialExchangeThreshold\n        )\n    {\n        if (\n            _dStakeCollateralVault == address(0) ||\n            _dStakeRouter == address(0) ||\n            _dLendRewardsController == address(0) ||\n            _targetStaticATokenWrapper == address(0) ||\n            _dLendAssetToClaimFor == address(0)\n        ) {\n            revert ZeroAddress();\n        }\n        if (exchangeAsset == address(0)) {\n            revert InvalidRouter(); // dStable from collateral vault was zero, or vault address was wrong\n        }\n\n        dStakeCollateralVault = _dStakeCollateralVault;\n        dStakeRouter = DStakeRouterDLend(_dStakeRouter);\n        dLendRewardsController = IDLendRewardsController(\n            _dLendRewardsController\n        );\n        targetStaticATokenWrapper = _targetStaticATokenWrapper;\n        dLendAssetToClaimFor = _dLendAssetToClaimFor;\n\n        // Grant roles to deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(REWARDS_MANAGER_ROLE, msg.sender);\n    }\n\n    // --- RewardClaimable Overrides ---\n\n    /**\n     * @inheritdoc RewardClaimable\n     * @dev Claims specified reward tokens from dLEND on behalf of the\n     *      `targetStaticATokenWrapper` and forwards them to\n     *      `_receiverForClaimedRawRewards` (usually `address(this)` when invoked\n     *      from `compoundRewards`).\n     *\n     * === Important note about how rewards are claimed ===\n     * A public call to `StaticATokenLM.collectAndUpdateRewards()` does **not**\n     * lock tokens inside the wrapper forever.  The wrapper merely holds those\n     * tokens in its own balance until a legitimate claimer shows up.\n     *\n     * When this reward-manager executes\n     * `IStaticATokenLM.claimRewardsOnBehalf(dStakeCollateralVault, )` the\n     * wrapper performs the following actions internally (see\n     * `StaticATokenLM._claimRewardsOnBehalf` in the Aave reference\n     * implementation):\n     *   1. If the wrapper's ERC20 balance is insufficient to pay the user's\n     *      owed rewards it first calls `collectAndUpdateRewards()` itself,\n     *      pulling fresh emissions from the RewardsController.\n     *   2. It then transfers *all* rewards owed to the user (`to` parameter).\n     *\n     * Critically, the payout uses the wrapper's **entire token balance**  this\n     * includes any tokens that were previously moved there by an external\n     * `collectAndUpdateRewards` call.  Therefore no permanent loss occurs: the\n     * next compounding round will withdraw those tokens and distribute them\n     * according to protocol rules.\n     */\n    function _claimRewards(\n        address[] calldata _tokensToClaim,\n        address _receiverForClaimedRawRewards\n    ) internal virtual override returns (uint256[] memory rewardAmounts) {\n        if (_tokensToClaim.length == 0) {\n            revert ZeroRewardTokens();\n        }\n        if (_receiverForClaimedRawRewards == address(0)) {\n            revert ZeroReceiverAddress();\n        }\n\n        rewardAmounts = new uint256[](_tokensToClaim.length);\n        address[] memory assetsToClaimForPayload = new address[](1);\n        assetsToClaimForPayload[0] = dLendAssetToClaimFor;\n\n        for (uint256 i = 0; i < _tokensToClaim.length; i++) {\n            address rewardToken = _tokensToClaim[i];\n            if (rewardToken == address(0)) {\n                revert ZeroAddress(); // Cannot claim zero address token\n            }\n\n            uint256 balanceBefore = IERC20(rewardToken).balanceOf(\n                _receiverForClaimedRawRewards\n            );\n\n            // Claim all available amount of the specific reward token\n            dLendRewardsController.claimRewardsOnBehalf(\n                assetsToClaimForPayload, // Asset held by the wrapper in dLEND\n                type(uint256).max, // Claim all\n                targetStaticATokenWrapper, // User earning rewards is the wrapper\n                _receiverForClaimedRawRewards,\n                rewardToken // The reward token to claim\n            );\n\n            uint256 balanceAfter = IERC20(rewardToken).balanceOf(\n                _receiverForClaimedRawRewards\n            );\n            rewardAmounts[i] = balanceAfter - balanceBefore;\n        }\n        return rewardAmounts;\n    }\n\n    /**\n     * @inheritdoc RewardClaimable\n     * @dev Processes the dStable (exchangeAsset) provided by the caller of `compoundRewards`.\n     *      This dStable is converted into the DStakeCollateralVault's default deposit asset\n     *      via the DStakeRouter and an appropriate adapter, and then deposited into the vault.\n     *      The adapter is expected to transfer the compounded asset directly to dStakeCollateralVault.\n     */\n    function _processExchangeAssetDeposit(\n        uint256 amountDStableToCompound\n    ) internal virtual override {\n        if (amountDStableToCompound == 0) {\n            // RewardClaimable base function checks amount >= exchangeThreshold, implying amount > 0.\n            return;\n        }\n\n        address defaultVaultAsset = dStakeRouter.defaultDepositVaultAsset();\n        if (defaultVaultAsset == address(0)) {\n            revert DefaultDepositAssetNotSet();\n        }\n\n        address adapterAddress = dStakeRouter.vaultAssetToAdapter(\n            defaultVaultAsset\n        );\n        if (adapterAddress == address(0)) {\n            revert AdapterNotSetForDefaultAsset();\n        }\n\n        IDStableConversionAdapter adapter = IDStableConversionAdapter(\n            adapterAddress\n        );\n\n        // Approve the adapter to spend the dStable held by this contract\n        IERC20(exchangeAsset).approve(adapterAddress, amountDStableToCompound);\n\n        // The adapter's convertToVaultAsset function is expected to:\n        // 1. Pull `amountDStableToCompound` from this contract (msg.sender).\n        // 2. Convert it to `defaultVaultAsset`.\n        // 3. Deposit/transfer the `defaultVaultAsset` directly to the `dStakeCollateralVault`.\n        (\n            address convertedVaultAsset,\n            uint256 convertedVaultAssetAmount\n        ) = adapter.convertToVaultAsset(amountDStableToCompound);\n\n        if (convertedVaultAsset != defaultVaultAsset) {\n            revert AdapterReturnedUnexpectedAsset(\n                defaultVaultAsset,\n                convertedVaultAsset\n            );\n        }\n\n        emit ExchangeAssetProcessed(\n            convertedVaultAsset,\n            convertedVaultAssetAmount,\n            amountDStableToCompound\n        );\n    }\n\n    /**\n     * @notice Override to deposit exchangeAsset for wrapper positions before claiming rewards and distribute rewards\n     */\n    function compoundRewards(\n        uint256 amount,\n        address[] calldata rewardTokens,\n        address receiver\n    ) public override nonReentrant {\n        // Validate input\n        if (amount < exchangeThreshold) {\n            revert ExchangeAmountTooLow(amount, exchangeThreshold);\n        }\n        if (receiver == address(0)) {\n            revert ZeroReceiverAddress();\n        }\n        if (rewardTokens.length == 0) {\n            revert ZeroRewardTokens();\n        }\n\n        // Transfer the exchange asset from the caller to this contract\n        IERC20(exchangeAsset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Deposit exchange asset to collateral vault to establish wrapper positions\n        _processExchangeAssetDeposit(amount);\n\n        // Emit compound event\n        emit RewardCompounded(exchangeAsset, amount, rewardTokens);\n\n        // Claim rewards from dLEND\n        uint256[] memory rewardAmounts = _claimRewards(\n            rewardTokens,\n            address(this)\n        );\n\n        if (rewardAmounts.length != rewardTokens.length) {\n            revert RewardAmountsLengthMismatch(\n                rewardAmounts.length,\n                rewardTokens.length\n            );\n        }\n\n        // Distribute rewards: fee to treasury, net to receiver\n        for (uint256 i = 0; i < rewardTokens.length; ++i) {\n            uint256 rewardAmount = rewardAmounts[i];\n            uint256 treasuryFee = getTreasuryFee(rewardAmount);\n            if (treasuryFee > rewardAmount) {\n                revert TreasuryFeeExceedsRewardAmount(\n                    treasuryFee,\n                    rewardAmount\n                );\n            }\n            IERC20(rewardTokens[i]).safeTransfer(treasury, treasuryFee);\n            IERC20(rewardTokens[i]).safeTransfer(\n                receiver,\n                rewardAmount - treasuryFee\n            );\n        }\n    }\n\n    // --- Admin Functions ---\n\n    /**\n     * @notice Sets the address of the dLEND RewardsController contract.\n     * @dev Only callable by DEFAULT_ADMIN_ROLE.\n     * @param _newDLendRewardsController The address of the new rewards controller.\n     */\n    function setDLendRewardsController(\n        address _newDLendRewardsController\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_newDLendRewardsController == address(0)) {\n            revert ZeroAddress();\n        }\n        address oldController = address(dLendRewardsController);\n        dLendRewardsController = IDLendRewardsController(\n            _newDLendRewardsController\n        );\n        emit DLendRewardsControllerUpdated(\n            oldController,\n            _newDLendRewardsController\n        );\n    }\n}\n"
    },
    "contracts/vaults/rewards_claimable/RewardClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {BasisPointConstants} from \"contracts/common/BasisPointConstants.sol\";\n\n/**\n * @title RewardClaimable\n * @dev Abstract contract for vaults with claimable rewards\n * Implements functionality for claiming and compounding rewards\n */\nabstract contract RewardClaimable is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Roles\n    bytes32 public constant REWARDS_MANAGER_ROLE =\n        keccak256(\"REWARDS_MANAGER_ROLE\");\n\n    // State variables\n    address public treasury;\n    uint256 public treasuryFeeBps;\n    uint256 public exchangeThreshold;\n    address public immutable exchangeAsset;\n    uint256 public immutable maxTreasuryFeeBps;\n\n    // Events\n    event TreasuryUpdated(address oldTreasury, address newTreasury);\n    event TreasuryFeeBpsUpdated(\n        uint256 oldTreasuryFeeBps,\n        uint256 newTreasuryFeeBps\n    );\n    event ExchangeThresholdUpdated(\n        uint256 oldExchangeThreshold,\n        uint256 newExchangeThreshold\n    );\n    event RewardCompounded(\n        address exchangeAsset,\n        uint256 amount,\n        address[] rewardTokens\n    );\n\n    // Custom errors\n    error ExchangeAmountTooLow(uint256 amount, uint256 threshold);\n    error RewardAmountsLengthMismatch(\n        uint256 claimedAmountsLength,\n        uint256 rewardTokensLength\n    );\n    error TreasuryFeeExceedsRewardAmount(\n        uint256 treasuryFee,\n        uint256 rewardAmount\n    );\n    error ZeroExchangeAssetAddress();\n    error ZeroTreasuryAddress();\n    error MaxTreasuryFeeTooHigh(uint256 maxTreasuryFeeBps);\n    error TreasuryFeeTooHigh(uint256 treasuryFeeBps, uint256 maxTreasuryFeeBps);\n    error ZeroExchangeThreshold();\n    error ZeroReceiverAddress();\n    error ZeroRewardTokens();\n\n    /**\n     * @dev Constructor for the RewardClaimable contract\n     * @param _exchangeAsset The address of the exchange asset\n     * @param _treasury The address of the treasury\n     * @param _maxTreasuryFeeBps The maximum treasury fee in basis points (30000 = 3%), where 100 = 1bps (1e2 for decimals)\n     * @param _initialTreasuryFeeBps The initial treasury fee in basis points (100 = 1bps, 10000 = 100bps = 1%)\n     * @param _initialExchangeThreshold The initial minimum threshold amount (in the same unit as the exchange asset)\n     */\n    constructor(\n        address _exchangeAsset,\n        address _treasury,\n        uint256 _maxTreasuryFeeBps,\n        uint256 _initialTreasuryFeeBps,\n        uint256 _initialExchangeThreshold\n    ) {\n        if (_exchangeAsset == address(0)) {\n            revert ZeroExchangeAssetAddress();\n        }\n        if (_treasury == address(0)) {\n            revert ZeroTreasuryAddress();\n        }\n        // The fee cannot exceed the reward amount (100%)\n        if (_maxTreasuryFeeBps > BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert MaxTreasuryFeeTooHigh(_maxTreasuryFeeBps);\n        }\n        // The initial fee cannot exceed the max fee, which means cannot be greater than 100% as well\n        if (_initialTreasuryFeeBps > _maxTreasuryFeeBps) {\n            revert TreasuryFeeTooHigh(\n                _initialTreasuryFeeBps,\n                _maxTreasuryFeeBps\n            );\n        }\n        if (_initialExchangeThreshold == 0) {\n            revert ZeroExchangeThreshold();\n        }\n\n        exchangeAsset = _exchangeAsset;\n        treasury = _treasury;\n        maxTreasuryFeeBps = _maxTreasuryFeeBps;\n        treasuryFeeBps = _initialTreasuryFeeBps;\n        exchangeThreshold = _initialExchangeThreshold;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(REWARDS_MANAGER_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Sets the treasury address\n     * @param newTreasury The new treasury address\n     */\n    function setTreasury(\n        address newTreasury\n    ) external onlyRole(REWARDS_MANAGER_ROLE) {\n        if (newTreasury == address(0)) {\n            revert ZeroTreasuryAddress();\n        }\n        address oldTreasury = treasury;\n        treasury = newTreasury;\n\n        emit TreasuryUpdated(oldTreasury, newTreasury);\n    }\n\n    /**\n     * @dev Sets the treasury fee in basis points\n     * @param newTreasuryFeeBps New treasury fee in basis points (100 = 1bps = 0.01%)\n     */\n    function setTreasuryFeeBps(\n        uint256 newTreasuryFeeBps\n    ) external onlyRole(REWARDS_MANAGER_ROLE) {\n        if (newTreasuryFeeBps > maxTreasuryFeeBps) {\n            revert TreasuryFeeTooHigh(newTreasuryFeeBps, maxTreasuryFeeBps);\n        }\n\n        uint256 oldTreasuryFeeBps = treasuryFeeBps;\n        treasuryFeeBps = newTreasuryFeeBps;\n\n        emit TreasuryFeeBpsUpdated(oldTreasuryFeeBps, newTreasuryFeeBps);\n    }\n\n    /**\n     * @dev Sets the minimum threshold for exchange operations\n     * @param newExchangeThreshold New minimum threshold amount\n     */\n    function setExchangeThreshold(\n        uint256 newExchangeThreshold\n    ) external onlyRole(REWARDS_MANAGER_ROLE) {\n        if (newExchangeThreshold == 0) {\n            revert ZeroExchangeThreshold();\n        }\n        uint256 oldExchangeThreshold = exchangeThreshold;\n        exchangeThreshold = newExchangeThreshold;\n\n        emit ExchangeThresholdUpdated(\n            oldExchangeThreshold,\n            newExchangeThreshold\n        );\n    }\n\n    /**\n     * @dev Calculates the treasury fee for a given amount\n     * @param amount The amount to calculate the treasury fee for\n     * @return The treasury fee in the same unit as the amount\n     */\n    function getTreasuryFee(uint256 amount) public view returns (uint256) {\n        return\n            (amount * treasuryFeeBps) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n    }\n\n    /**\n     * @dev Compounds multiple rewards\n     * @param amount The amount to compound\n     * @param rewardTokens The reward tokens to claim\n     * @param receiver The address to receive the compounded rewards\n     */\n    function compoundRewards(\n        uint256 amount,\n        address[] calldata rewardTokens,\n        address receiver\n    ) public virtual nonReentrant {\n        if (amount < exchangeThreshold) {\n            revert ExchangeAmountTooLow(amount, exchangeThreshold);\n        }\n        if (receiver == address(0)) {\n            revert ZeroReceiverAddress();\n        }\n        if (rewardTokens.length == 0) {\n            revert ZeroRewardTokens();\n        }\n\n        // Transfer the exchange asset from the caller to the vault\n        IERC20(exchangeAsset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Emit the event before the internal call to avoid reentrancy\n        emit RewardCompounded(exchangeAsset, amount, rewardTokens);\n\n        // Claim the rewards\n        uint256[] memory rewardAmounts = _claimRewards(\n            rewardTokens,\n            address(this)\n        );\n\n        if (rewardAmounts.length != rewardTokens.length) {\n            revert RewardAmountsLengthMismatch(\n                rewardAmounts.length,\n                rewardTokens.length\n            );\n        }\n\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewardAmount = rewardAmounts[i];\n            uint256 treasuryFee = getTreasuryFee(rewardAmount);\n\n            // Overflow protection\n            if (treasuryFee > rewardAmount) {\n                revert TreasuryFeeExceedsRewardAmount(\n                    treasuryFee,\n                    rewardAmount\n                );\n            }\n\n            // Transfer the treasury fee to the treasury\n            IERC20(rewardTokens[i]).safeTransfer(treasury, treasuryFee);\n\n            // Transfer the remaining amount to the caller\n            IERC20(rewardTokens[i]).safeTransfer(\n                receiver,\n                rewardAmount - treasuryFee\n            );\n        }\n\n        // Process the exchange asset deposit\n        _processExchangeAssetDeposit(amount);\n    }\n\n    /**\n     * @dev Claims multiple rewards\n     * @param rewardTokens The reward tokens to claim\n     * @param receiver The address to receive the claimed rewards\n     * @return rewardAmounts The amount of rewards claimed for each token (have the same length as the tokens array)\n     */\n    function _claimRewards(\n        address[] calldata rewardTokens,\n        address receiver\n    ) internal virtual returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @dev Processes the exchange asset deposit from the caller\n     * @param amount The amount of exchange asset to deposit\n     */\n    function _processExchangeAssetDeposit(uint256 amount) internal virtual;\n}\n"
    },
    "contracts/vaults/rewards_claimable/test/MockRewardClaimableVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*  *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n *  dtrinity.org  *\n *                                                                                  *\n *                                                                                 *\n *                                                                                *\n *                                                                                  *\n *  *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n *  */\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../RewardClaimable.sol\";\n\n/**\n * @title MockRewardClaimableVault\n * @dev Mock implementation of RewardClaimable contract for testing purposes\n */\ncontract MockRewardClaimableVault is RewardClaimable {\n    using SafeERC20 for IERC20;\n\n    // Track deposited amounts for testing\n    mapping(address => uint256) public deposits;\n\n    // Mock reward tokens for testing\n    mapping(address => bool) public rewardTokens;\n    mapping(address => uint256) public rewardTokenEmissionAmount;\n\n    // Mock target pool address\n    address public targetPool;\n    // Mock fake reward pool address\n    address public fakeRewardPool;\n\n    error InsufficientAllowanceFromFakeRewardPool(\n        address token,\n        uint256 allowance,\n        uint256 amount\n    );\n\n    /**\n     * @dev Constructor for the MockRewardClaimableVault contract\n     * @param _exchangeAsset The address of the exchange asset\n     * @param _treasury The address of the treasury\n     * @param _maxTreasuryFeeBps The maximum treasury fee in basis points\n     * @param _initialTreasuryFeeBps The initial treasury fee in basis points\n     * @param _initialExchangeThreshold The initial minimum threshold amount\n     * @param _targetPool The address of the target pool\n     * @param _fakeRewardPool The address of the fake reward pool\n     */\n    constructor(\n        address _exchangeAsset,\n        address _treasury,\n        uint256 _maxTreasuryFeeBps,\n        uint256 _initialTreasuryFeeBps,\n        uint256 _initialExchangeThreshold,\n        address _targetPool,\n        address _fakeRewardPool\n    )\n        RewardClaimable(\n            _exchangeAsset,\n            _treasury,\n            _maxTreasuryFeeBps,\n            _initialTreasuryFeeBps,\n            _initialExchangeThreshold\n        )\n    {\n        targetPool = _targetPool;\n        fakeRewardPool = _fakeRewardPool;\n    }\n\n    /**\n     * @dev Adds a reward token to the list of mock reward tokens (for testing purposes)\n     * @param _rewardToken The address of the reward token to add\n     * @param _emissionAmount The emission amount of the reward token each time the vault claims rewards\n     */\n    function addRewardToken(\n        address _rewardToken,\n        uint256 _emissionAmount\n    ) external {\n        rewardTokens[_rewardToken] = true;\n\n        require(_emissionAmount > 0, \"Emission amount must be greater than 0\");\n        rewardTokenEmissionAmount[_rewardToken] = _emissionAmount;\n    }\n\n    /**\n     * @dev Public function to expose the internal _claimRewards function for testing\n     */\n    function claimRewards(\n        address[] calldata tokens,\n        address receiver\n    ) external {\n        _claimRewards(tokens, receiver);\n    }\n\n    /**\n     * @dev Mocks claiming rewards\n     * @param tokens The reward tokens to claim\n     * @param receiver The address to receive the claimed rewards\n     * @return rewardAmounts The amount of rewards claimed for each token (have the same length as the tokens array)\n     */\n    function _claimRewards(\n        address[] calldata tokens,\n        address receiver\n    ) internal override returns (uint256[] memory rewardAmounts) {\n        rewardAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (!rewardTokens[tokens[i]]) {\n                revert(\"Invalid reward token\");\n            }\n\n            // Now, we will drain reward tokens from the fake reward pool to mimic the behavior of the real vault\n            // claiming the rewards\n            uint256 amount = rewardTokenEmissionAmount[tokens[i]];\n\n            // Make sure having enough allowance to transfer from the fake reward pool\n            uint256 allowance = IERC20(tokens[i]).allowance(\n                fakeRewardPool,\n                address(this)\n            );\n            if (allowance < amount) {\n                revert InsufficientAllowanceFromFakeRewardPool(\n                    tokens[i],\n                    allowance,\n                    amount\n                );\n            }\n\n            // Transfer the tokens to the receiver\n            IERC20(tokens[i]).safeTransferFrom(\n                fakeRewardPool,\n                receiver,\n                amount\n            );\n\n            rewardAmounts[i] = amount;\n        }\n\n        return rewardAmounts;\n    }\n\n    /**\n     * @dev Mocks processing the exchange asset deposit from the caller\n     * @param amount The amount of exchange asset to deposit\n     */\n    function _processExchangeAssetDeposit(\n        uint256 amount\n    ) internal virtual override {\n        deposits[exchangeAsset] += amount;\n        // Transfer tokens from contract to the target pool (tokens are already in the contract)\n        IERC20(exchangeAsset).safeTransfer(targetPool, amount);\n    }\n}\n"
    },
    "contracts/vaults/vesting/ERC20VestingNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @title ERC20VestingNFT\n * @notice A soft locker contract for dSTAKE tokens with 6-month vesting period\n * @dev Users deposit dSTAKE tokens and receive NFTs representing their vesting positions.\n *      NFTs can be burned for early exit or become soul-bound after matured withdrawal.\n */\ncontract ERC20VestingNFT is ERC721, ERC721Enumerable, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ============ State Variables ============\n\n    /// @notice The dSTAKE token contract\n    IERC20 public immutable dstakeToken;\n\n    /// @notice The vesting period duration (6 months, set at deployment)\n    uint256 public immutable vestingPeriod;\n\n    /// @notice Whether new deposits are enabled\n    bool public depositsEnabled;\n\n    /// @notice Maximum total dSTAKE supply that can be deposited\n    uint256 public maxTotalSupply;\n\n    /// @notice Minimum deposit amount threshold\n    uint256 public minDepositAmount;\n\n    /// @notice Current total dSTAKE deposited\n    uint256 public totalDeposited;\n\n    /// @notice Token ID counter\n    uint256 private _tokenIdCounter;\n\n    /// @notice Vesting position data for each NFT\n    struct VestingPosition {\n        uint256 amount; // Amount of dSTAKE deposited\n        uint256 depositTime; // Timestamp when deposit was made\n        bool matured; // Whether the NFT has been matured (soul-bound)\n    }\n\n    /// @notice Mapping from token ID to vesting position\n    mapping(uint256 => VestingPosition) public vestingPositions;\n\n    // ============ Events ============\n\n    event Deposited(\n        address indexed user,\n        uint256 indexed tokenId,\n        uint256 amount\n    );\n    event RedeemedEarly(\n        address indexed user,\n        uint256 indexed tokenId,\n        uint256 amount\n    );\n    event WithdrawnMatured(\n        address indexed user,\n        uint256 indexed tokenId,\n        uint256 amount\n    );\n    event DepositsToggled(bool enabled);\n    event MaxTotalSupplyUpdated(uint256 newMaxSupply);\n    event MinDepositAmountUpdated(uint256 newMinDepositAmount);\n    event MetadataUpdate(uint256 indexed tokenId);\n\n    // ============ Errors ============\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error DepositsDisabled();\n    error MaxSupplyExceeded();\n    error TokenNotExists();\n    error NotTokenOwner();\n    error VestingNotComplete();\n    error VestingAlreadyComplete();\n    error TokenAlreadyMatured();\n    error TransferOfMaturedToken();\n    error DepositBelowMinimum();\n\n    // ============ Constructor ============\n\n    /**\n     * @notice Initialize the vesting NFT contract\n     * @param _name Name of the NFT collection\n     * @param _symbol Symbol of the NFT collection\n     * @param _dstakeToken Address of the dSTAKE token\n     * @param _vestingPeriod Vesting period in seconds (6 months)\n     * @param _maxTotalSupply Maximum total dSTAKE that can be deposited\n     * @param _minDepositAmount Minimum deposit amount threshold\n     * @param _initialOwner Initial owner of the contract\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _dstakeToken,\n        uint256 _vestingPeriod,\n        uint256 _maxTotalSupply,\n        uint256 _minDepositAmount,\n        address _initialOwner\n    ) ERC721(_name, _symbol) Ownable(_initialOwner) {\n        if (_dstakeToken == address(0)) {\n            revert ZeroAddress();\n        }\n        if (_vestingPeriod == 0 || _maxTotalSupply == 0) {\n            revert ZeroAmount();\n        }\n\n        dstakeToken = IERC20(_dstakeToken);\n        vestingPeriod = _vestingPeriod;\n        maxTotalSupply = _maxTotalSupply;\n        minDepositAmount = _minDepositAmount;\n        depositsEnabled = true;\n\n        // Start token IDs from 1\n        _tokenIdCounter = 1;\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Deposit dSTAKE tokens and receive a vesting NFT\n     * @param amount Amount of dSTAKE tokens to deposit\n     * @return tokenId The ID of the minted NFT\n     */\n    function deposit(\n        uint256 amount\n    ) external nonReentrant returns (uint256 tokenId) {\n        if (amount == 0) revert ZeroAmount();\n        if (!depositsEnabled) revert DepositsDisabled();\n        if (amount < minDepositAmount) revert DepositBelowMinimum();\n        if (totalDeposited + amount > maxTotalSupply)\n            revert MaxSupplyExceeded();\n\n        // Transfer dSTAKE tokens from user\n        dstakeToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Mint NFT\n        tokenId = _tokenIdCounter;\n        _tokenIdCounter++;\n        _safeMint(msg.sender, tokenId);\n\n        // Store vesting position\n        vestingPositions[tokenId] = VestingPosition({\n            amount: amount,\n            depositTime: block.timestamp,\n            matured: false\n        });\n\n        // Update total deposited\n        totalDeposited += amount;\n\n        emit Deposited(msg.sender, tokenId, amount);\n    }\n\n    /**\n     * @notice Redeem dSTAKE tokens early by burning the NFT (before vesting period)\n     * @param tokenId The ID of the NFT to redeem\n     */\n    function redeemEarly(uint256 tokenId) external nonReentrant {\n        if (!_tokenExists(tokenId)) revert TokenNotExists();\n        if (ownerOf(tokenId) != msg.sender) revert NotTokenOwner();\n\n        VestingPosition memory position = vestingPositions[tokenId];\n        if (position.matured) revert TokenAlreadyMatured();\n        if (block.timestamp >= position.depositTime + vestingPeriod) {\n            revert VestingAlreadyComplete();\n        }\n\n        uint256 amount = position.amount;\n\n        // Delete vesting position and burn NFT\n        delete vestingPositions[tokenId];\n        _burn(tokenId);\n\n        // Update total deposited\n        totalDeposited -= amount;\n\n        // Transfer dSTAKE tokens back to user\n        dstakeToken.safeTransfer(msg.sender, amount);\n\n        emit RedeemedEarly(msg.sender, tokenId, amount);\n    }\n\n    /**\n     * @notice Withdraw dSTAKE tokens after vesting period and make NFT soul-bound\n     * @param tokenId The ID of the NFT to withdraw from\n     */\n    function withdrawMatured(uint256 tokenId) external nonReentrant {\n        if (!_tokenExists(tokenId)) revert TokenNotExists();\n        if (ownerOf(tokenId) != msg.sender) revert NotTokenOwner();\n\n        VestingPosition storage position = vestingPositions[tokenId];\n        if (position.matured) revert TokenAlreadyMatured();\n        if (block.timestamp < position.depositTime + vestingPeriod) {\n            revert VestingNotComplete();\n        }\n\n        uint256 amount = position.amount;\n\n        // Mark as matured (soul-bound)\n        position.matured = true;\n\n        // Update total deposited\n        totalDeposited -= amount;\n\n        // Transfer dSTAKE tokens back to user\n        dstakeToken.safeTransfer(msg.sender, amount);\n\n        emit WithdrawnMatured(msg.sender, tokenId, amount);\n        emit MetadataUpdate(tokenId);\n    }\n\n    // ============ Owner Functions ============\n\n    /**\n     * @notice Toggle whether new deposits are enabled\n     * @param enabled Whether deposits should be enabled\n     */\n    function setDepositsEnabled(bool enabled) external onlyOwner {\n        depositsEnabled = enabled;\n        emit DepositsToggled(enabled);\n    }\n\n    /**\n     * @notice Update the maximum total supply of dSTAKE that can be deposited\n     * @param newMaxSupply New maximum total supply\n     * @dev Can be set below current totalDeposited to allow withdrawals until cap is reached\n     */\n    function setMaxTotalSupply(uint256 newMaxSupply) external onlyOwner {\n        maxTotalSupply = newMaxSupply;\n        emit MaxTotalSupplyUpdated(newMaxSupply);\n    }\n\n    /**\n     * @notice Set minimum deposit amount threshold\n     * @param newMinDepositAmount New minimum deposit amount\n     */\n    function setMinDepositAmount(\n        uint256 newMinDepositAmount\n    ) external onlyOwner {\n        minDepositAmount = newMinDepositAmount;\n        emit MinDepositAmountUpdated(newMinDepositAmount);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Check if a vesting position is ready for matured withdrawal\n     * @param tokenId The NFT token ID\n     * @return Whether the vesting period has completed\n     */\n    function isVestingComplete(uint256 tokenId) external view returns (bool) {\n        if (!_tokenExists(tokenId)) return false;\n        VestingPosition memory position = vestingPositions[tokenId];\n        return block.timestamp >= position.depositTime + vestingPeriod;\n    }\n\n    /**\n     * @notice Get the remaining vesting time for a position\n     * @param tokenId The NFT token ID\n     * @return Remaining time in seconds (0 if vesting complete)\n     */\n    function getRemainingVestingTime(\n        uint256 tokenId\n    ) external view returns (uint256) {\n        if (!_tokenExists(tokenId)) revert TokenNotExists();\n        VestingPosition memory position = vestingPositions[tokenId];\n        uint256 vestingEndTime = position.depositTime + vestingPeriod;\n        if (block.timestamp >= vestingEndTime) return 0;\n        return vestingEndTime - block.timestamp;\n    }\n\n    /**\n     * @notice Get vesting position details\n     * @param tokenId The NFT token ID\n     * @return amount Amount of dSTAKE deposited\n     * @return depositTime Timestamp of deposit\n     * @return matured Whether the NFT is soul-bound\n     * @return vestingComplete Whether vesting period has ended\n     */\n    function getVestingPosition(\n        uint256 tokenId\n    )\n        external\n        view\n        returns (\n            uint256 amount,\n            uint256 depositTime,\n            bool matured,\n            bool vestingComplete\n        )\n    {\n        if (!_tokenExists(tokenId)) {\n            return (0, 0, false, false);\n        }\n\n        VestingPosition memory position = vestingPositions[tokenId];\n        return (\n            position.amount,\n            position.depositTime,\n            position.matured,\n            block.timestamp >= position.depositTime + vestingPeriod\n        );\n    }\n\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        if (!_tokenExists(tokenId)) revert TokenNotExists();\n\n        VestingPosition memory position = vestingPositions[tokenId];\n\n        // remaining seconds until vesting complete or 0\n        uint256 remainingSeconds = 0;\n        uint256 vestingEndTime = position.depositTime + vestingPeriod;\n        if (block.timestamp < vestingEndTime) {\n            remainingSeconds = vestingEndTime - block.timestamp;\n        }\n\n        string memory symbol = IERC20Metadata(address(dstakeToken)).symbol();\n        uint8 decimalsToken = IERC20Metadata(address(dstakeToken)).decimals();\n\n        uint256 displayAmount = position.amount /\n            (10 ** uint256(decimalsToken));\n        string memory amountStr = Strings.toString(displayAmount);\n\n        string memory image = _buildSVG(\n            position,\n            remainingSeconds,\n            tokenId,\n            symbol,\n            amountStr\n        );\n\n        string memory json = Base64.encode(\n            bytes(\n                string.concat(\n                    '{\"name\":\"',\n                    name(),\n                    \" #\",\n                    Strings.toString(tokenId),\n                    '\",\"description\":\"Contains ',\n                    symbol,\n                    \" with a \",\n                    Strings.toString(vestingPeriod),\n                    ' second vesting period.\",',\n                    '\"attributes\":[',\n                    '{\"trait_type\":\"Amount\",\"value\":\"',\n                    amountStr,\n                    \" \",\n                    symbol,\n                    '\"}',\n                    ',{\"trait_type\":\"Matured\",\"value\":\"',\n                    position.matured ? \"true\" : \"false\",\n                    '\"}',\n                    ',{\"trait_type\":\"Remaining Seconds\",\"value\":\"',\n                    Strings.toString(remainingSeconds),\n                    '\"}',\n                    \"],\",\n                    '\"image\":\"',\n                    image,\n                    '\"}'\n                )\n            )\n        );\n\n        return string.concat(\"data:application/json;base64,\", json);\n    }\n\n    /// @dev Builds a very small SVG showing vesting progress and encodes it as base64 data URI.\n    function _buildSVG(\n        VestingPosition memory position,\n        uint256 remainingSeconds,\n        uint256 tokenId,\n        string memory symbol,\n        string memory displayAmount\n    ) internal view returns (string memory) {\n        // Simple progress bar width percentage\n        uint256 progressPercent = 0;\n        if (position.amount > 0) {\n            uint256 elapsed = vestingPeriod - remainingSeconds;\n            progressPercent = (elapsed * 100) / vestingPeriod;\n        }\n\n        string memory svg = string.concat(\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"350\" height=\"200\" viewBox=\"0 0 350 200\">',\n            \"<style>.base { fill: white; font-family: monospace; font-size: 14px; }</style>\",\n            '<rect width=\"100%\" height=\"100%\" fill=\"#1a237e\"/>',\n            '<text x=\"10\" y=\"30\" class=\"base\">',\n            name(),\n            \" #\",\n            Strings.toString(tokenId),\n            \"</text>\",\n            '<text x=\"10\" y=\"55\" class=\"base\">Amount: ',\n            displayAmount,\n            \" \",\n            symbol,\n            \"</text>\",\n            '<text x=\"10\" y=\"80\" class=\"base\">Progress: ',\n            Strings.toString(progressPercent),\n            \"%</text>\",\n            '<rect x=\"10\" y=\"100\" width=\"330\" height=\"20\" fill=\"#3949ab\"/>',\n            '<rect x=\"10\" y=\"100\" width=\"',\n            Strings.toString((progressPercent * 330) / 100),\n            '\" height=\"20\" fill=\"#7e57c2\"/>',\n            \"</svg>\"\n        );\n\n        return\n            string.concat(\n                \"data:image/svg+xml;base64,\",\n                Base64.encode(bytes(svg))\n            );\n    }\n\n    // ============ Internal Functions ============\n\n    /**\n     * @notice Check if a token exists\n     * @param tokenId The token ID to check\n     * @return Whether the token exists\n     */\n    function _tokenExists(uint256 tokenId) internal view returns (bool) {\n        return vestingPositions[tokenId].amount > 0;\n    }\n\n    /**\n     * @notice Override to prevent transfers of matured (soul-bound) NFTs\n     */\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal override(ERC721, ERC721Enumerable) returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Allow minting and burning\n        if (from != address(0) && to != address(0)) {\n            // Prevent transfer of matured NFTs\n            if (vestingPositions[tokenId].matured) {\n                revert TransferOfMaturedToken();\n            }\n        }\n\n        return super._update(to, tokenId, auth);\n    }\n\n    /**\n     * @notice Override to handle balance updates\n     */\n    function _increaseBalance(\n        address account,\n        uint128 value\n    ) internal override(ERC721, ERC721Enumerable) {\n        super._increaseBalance(account, value);\n    }\n\n    /**\n     * @notice Override required by Solidity for multiple inheritance\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}