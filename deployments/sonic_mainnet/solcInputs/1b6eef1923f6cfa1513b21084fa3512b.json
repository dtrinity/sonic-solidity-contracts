{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";\nimport {SafeERC20} from \"../utils/SafeERC20.sol\";\nimport {IERC4626} from \"../../../interfaces/IERC4626.sol\";\nimport {Math} from \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC-4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC-20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC-20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation introduces configurable virtual assets and shares to help developers mitigate that risk.\n * The `_decimalsOffset()` corresponds to an offset in the decimal representation between the underlying asset's decimals\n * and the vault decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which\n * itself determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default\n * offset (0) makes it non-profitable even if an attacker is able to capture value from multiple user deposits, as a result\n * of the value being captured by the virtual shares (out of the attacker's donation) matching the attacker's expected gains.\n * With a larger offset, the attack becomes orders of magnitude more expensive than it is profitable. More details about the\n * underlying math can be found xref:ROOT:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _underlyingDecimals;\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC-20 or ERC-777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _underlyingDecimals + _decimalsOffset();\n    }\n\n    /** @dev See {IERC4626-asset}. */\n    function asset() public view virtual returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4626-totalAssets}. */\n    function totalAssets() public view virtual returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4626-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-maxDeposit}. */\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint}. */\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-previewMint}. */\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /** @dev See {IERC4626-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint}. */\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw}. */\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem}. */\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If asset() is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(IERC20(asset()), caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(IERC20(asset()), receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "contracts/common/BasisPointConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nlibrary BasisPointConstants {\n    // Shared definitions of how we represent percentages and basis points\n    uint16 public constant ONE_BPS = 100; // 1 basis point with 2 decimals\n    uint32 public constant ONE_PERCENT_BPS = ONE_BPS * 100;\n    uint32 public constant ONE_HUNDRED_PERCENT_BPS = ONE_PERCENT_BPS * 100;\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/math/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary PercentageMath {\n    // Maximum percentage factor (100.00%)\n    uint256 internal constant PERCENTAGE_FACTOR = 1e4;\n\n    // Half percentage factor (50.00%)\n    uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\n\n    /**\n     * @notice Executes a percentage multiplication\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return result value percentmul percentage\n     */\n    function percentMul(\n        uint256 value,\n        uint256 percentage\n    ) internal pure returns (uint256 result) {\n        // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\n        assembly {\n            if iszero(\n                or(\n                    iszero(percentage),\n                    iszero(\n                        gt(\n                            value,\n                            div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage)\n                        )\n                    )\n                )\n            ) {\n                revert(0, 0)\n            }\n\n            result := div(\n                add(mul(value, percentage), HALF_PERCENTAGE_FACTOR),\n                PERCENTAGE_FACTOR\n            )\n        }\n    }\n\n    /**\n     * @notice Executes a percentage division\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return result value percentdiv percentage\n     */\n    function percentDiv(\n        uint256 value,\n        uint256 percentage\n    ) internal pure returns (uint256 result) {\n        // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\n        assembly {\n            if or(\n                iszero(percentage),\n                iszero(\n                    iszero(\n                        gt(\n                            value,\n                            div(\n                                sub(not(0), div(percentage, 2)),\n                                PERCENTAGE_FACTOR\n                            )\n                        )\n                    )\n                )\n            ) {\n                revert(0, 0)\n            }\n\n            result := div(\n                add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)),\n                percentage\n            )\n        }\n    }\n}\n"
    },
    "contracts/dloop/core/DLoopCoreBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {BasisPointConstants} from \"contracts/common/BasisPointConstants.sol\";\nimport {ERC4626, ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {Erc20Helper} from \"../libraries/Erc20Helper.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {RescuableVault} from \"../libraries/RescuableVault.sol\";\n\n/**\n * @title DLoopCoreBase\n * @dev A contract that executes leveraged operations on a lending pool using a collateral token and a debt token\n *      - A leveraged position is created by supplying a collateral token to the lending pool and borrowing a debt token\n *      - The leverage ratio will be changed if the collateral and debt values are changed (due to price changes)\n *      - The leverage can be increased by supplying more collateral token or decreasing the debt token\n *      - The leverage can be decreased by withdrawing collateral token or increasing the debt token\n *      - In order to keep the vault balanced, user can call increaseLeverage or decreaseLeverage to increase or decrease the leverage\n *        when it is away from the target leverage\n *      - There is a subsidy for the caller when increasing the leverage.\n */\nabstract contract DLoopCoreBase is\n    ERC4626,\n    Ownable,\n    ReentrancyGuard,\n    RescuableVault\n{\n    using SafeERC20 for ERC20;\n\n    /* Core state */\n\n    uint32 public lowerBoundTargetLeverageBps;\n    uint32 public upperBoundTargetLeverageBps;\n    uint256 public maxSubsidyBps;\n\n    /* Constants */\n\n    uint32 public immutable targetLeverageBps; // ie. 30000 = 300% over 100% in basis points, means 3x leverage\n    ERC20 public immutable collateralToken;\n    ERC20 public immutable debtToken;\n\n    /* Errors */\n\n    error TooImbalanced(\n        uint256 currentLeverageBps,\n        uint256 lowerBoundTargetLeverageBps,\n        uint256 upperBoundTargetLeverageBps\n    );\n    error InsufficientAllowanceOfDebtAssetToRepay(\n        address owner,\n        address spender,\n        address debtAsset,\n        uint256 requiredAllowance\n    );\n    error DepositInsufficientToSupply(\n        uint256 currentBalance,\n        uint256 newTotalAssets\n    );\n    error CollateralLessThanDebt(\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase\n    );\n    error InsufficientShareBalanceToRedeem(\n        address owner,\n        uint256 sharesToRedeem,\n        uint256 shareBalance\n    );\n    error WithdrawableIsLessThanRequired(\n        address token,\n        uint256 assetToRemoveFromLending,\n        uint256 withdrawableAmount\n    );\n    error DecreaseLeverageOutOfRange(\n        uint256 newLeverageBps,\n        uint256 targetLeverageBps, // lower bound\n        uint256 currentLeverageBps // upper bound\n    );\n    error IncreaseLeverageOutOfRange(\n        uint256 newLeverageBps,\n        uint256 targetLeverageBps, // upper bound\n        uint256 currentLeverageBps // lower bound\n    );\n    error TokenBalanceNotDecreasedAfterRepay(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedRepayAmountToPool(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error TokenBalanceNotDecreasedAfterSupply(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedSupplyAmountToPool(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error TokenBalanceNotIncreasedAfterBorrow(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedBorrowAmountFromPool(\n        address token,\n        uint256 borrowedAmountBefore,\n        uint256 borrowedAmountAfter,\n        uint256 expectedBorrowedAmount\n    );\n    error TokenBalanceNotIncreasedAfterWithdraw(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedWithdrawAmountFromPool(\n        address token,\n        uint256 withdrawableAmountBefore,\n        uint256 withdrawableAmountAfter,\n        uint256 expectedWithdrawableAmount\n    );\n    error InvalidLeverageBounds(\n        uint256 lowerBound,\n        uint256 targetLeverage,\n        uint256 upperBound\n    );\n    error AssetPriceIsZero(address asset);\n    error LeverageExceedsTarget(\n        uint256 currentLeverageBps,\n        uint256 targetLeverageBps\n    );\n    error LeverageBelowTarget(\n        uint256 currentLeverageBps,\n        uint256 targetLeverageBps\n    );\n    error RebalanceReceiveLessThanMinAmount(\n        string operation,\n        uint256 receivedAmount,\n        uint256 minReceivedAmount\n    );\n    error InvalidLeverage(uint256 leverageBps);\n\n    /**\n     * @dev Constructor for the DLoopCore contract\n     * @param _name Name of the vault token\n     * @param _symbol Symbol of the vault token\n     * @param _collateralToken Address of the collateral token\n     * @param _debtToken Address of the debt token\n     * @param _targetLeverageBps Target leverage in basis points\n     * @param _lowerBoundTargetLeverageBps Lower bound of target leverage in basis points\n     * @param _upperBoundTargetLeverageBps Upper bound of target leverage in basis points\n     * @param _maxSubsidyBps Maximum subsidy in basis points\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        ERC20 _collateralToken,\n        ERC20 _debtToken,\n        uint32 _targetLeverageBps,\n        uint32 _lowerBoundTargetLeverageBps,\n        uint32 _upperBoundTargetLeverageBps,\n        uint256 _maxSubsidyBps\n    ) ERC20(_name, _symbol) ERC4626(_collateralToken) Ownable(msg.sender) {\n        debtToken = _debtToken;\n        collateralToken = _collateralToken;\n\n        if (_targetLeverageBps < BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert(\"Target leverage must be at least 100% in basis points\");\n        }\n\n        if (\n            _lowerBoundTargetLeverageBps >= _targetLeverageBps ||\n            _targetLeverageBps >= _upperBoundTargetLeverageBps\n        ) {\n            revert InvalidLeverageBounds(\n                _lowerBoundTargetLeverageBps,\n                _targetLeverageBps,\n                _upperBoundTargetLeverageBps\n            );\n        }\n\n        // Make sure collateral token is ERC-20\n        if (!Erc20Helper.isERC20(address(_collateralToken))) {\n            revert(\"Collateral token must be an ERC-20\");\n        }\n\n        // Make sure debt token is ERC-20\n        if (!Erc20Helper.isERC20(address(_debtToken))) {\n            revert(\"Debt token must be an ERC-20\");\n        }\n\n        targetLeverageBps = _targetLeverageBps;\n        lowerBoundTargetLeverageBps = _lowerBoundTargetLeverageBps;\n        upperBoundTargetLeverageBps = _upperBoundTargetLeverageBps;\n        maxSubsidyBps = _maxSubsidyBps;\n    }\n\n    /* Virtual Methods - Required to be implemented by derived contracts */\n\n    /**\n     * @dev Gets the total collateral and debt of a user in base currency\n     * @param user Address of the user\n     * @return totalCollateralBase Total collateral in base currency\n     * @return totalDebtBase Total debt in base currency\n     */\n    function getTotalCollateralAndDebtOfUserInBase(\n        address user\n    )\n        public\n        view\n        virtual\n        returns (uint256 totalCollateralBase, uint256 totalDebtBase);\n\n    /**\n     * @dev Gets the asset price from the oracle\n     * @param asset Address of the asset\n     * @return uint256 Price of the asset\n     */\n    function _getAssetPriceFromOracleImplementation(\n        address asset\n    ) internal view virtual returns (uint256);\n\n    /**\n     * @dev Supply tokens to the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to supply\n     * @param onBehalfOf Address to supply on behalf of\n     */\n    function _supplyToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal virtual;\n\n    /**\n     * @dev Borrow tokens from the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to borrow\n     * @param onBehalfOf Address to borrow on behalf of\n     */\n    function _borrowFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal virtual;\n\n    /**\n     * @dev Repay debt to the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to repay\n     * @param onBehalfOf Address to repay on behalf of\n     */\n    function _repayDebtToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal virtual;\n\n    /**\n     * @dev Withdraw tokens from the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to withdraw\n     * @param onBehalfOf Address to withdraw on behalf of\n     */\n    function _withdrawFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal virtual;\n\n    /* Wrapper Functions */\n\n    /**\n     * @dev Supply tokens to the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to supply\n     * @param onBehalfOf Address to supply on behalf of\n     */\n    function _supplyToPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal {\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeSupply = ERC20(token).balanceOf(\n            address(this)\n        );\n\n        _supplyToPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterSupply = ERC20(token).balanceOf(address(this));\n        if (tokenBalanceAfterSupply >= tokenBalanceBeforeSupply) {\n            revert TokenBalanceNotDecreasedAfterSupply(\n                token,\n                tokenBalanceBeforeSupply,\n                tokenBalanceAfterSupply,\n                amount\n            );\n        }\n\n        // Now, as balance before must be greater than balance after, we can just check if the difference is the expected amount\n        if (tokenBalanceBeforeSupply - tokenBalanceAfterSupply != amount) {\n            revert UnexpectedSupplyAmountToPool(\n                token,\n                tokenBalanceBeforeSupply,\n                tokenBalanceAfterSupply,\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Borrow tokens from the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to borrow\n     * @param onBehalfOf Address to borrow on behalf of\n     */\n    function _borrowFromPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal {\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeBorrow = ERC20(token).balanceOf(\n            address(this)\n        );\n\n        _borrowFromPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterBorrow = ERC20(token).balanceOf(address(this));\n        if (tokenBalanceAfterBorrow <= tokenBalanceBeforeBorrow) {\n            revert TokenBalanceNotIncreasedAfterBorrow(\n                token,\n                tokenBalanceBeforeBorrow,\n                tokenBalanceAfterBorrow,\n                amount\n            );\n        }\n\n        // Now, as balance before must be less than balance after, we can just check if the difference is the expected amount\n        if (tokenBalanceAfterBorrow - tokenBalanceBeforeBorrow != amount) {\n            revert UnexpectedBorrowAmountFromPool(\n                token,\n                tokenBalanceBeforeBorrow,\n                tokenBalanceAfterBorrow,\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Repay debt to the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to repay\n     * @param onBehalfOf Address to repay on behalf of\n     */\n    function _repayDebtToPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal {\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeRepay = ERC20(token).balanceOf(address(this));\n\n        _repayDebtToPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterRepay = ERC20(token).balanceOf(address(this));\n\n        if (tokenBalanceAfterRepay >= tokenBalanceBeforeRepay) {\n            revert TokenBalanceNotDecreasedAfterRepay(\n                token,\n                tokenBalanceBeforeRepay,\n                tokenBalanceAfterRepay,\n                amount\n            );\n        }\n\n        // Now, as balance before must be greater than balance after, we can just check if the difference is the expected amount\n        if (tokenBalanceBeforeRepay - tokenBalanceAfterRepay != amount) {\n            revert UnexpectedRepayAmountToPool(\n                token,\n                tokenBalanceBeforeRepay,\n                tokenBalanceAfterRepay,\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens from the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to withdraw\n     * @param onBehalfOf Address to withdraw on behalf of\n     */\n    function _withdrawFromPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal {\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeWithdraw = ERC20(token).balanceOf(\n            address(this)\n        );\n\n        _withdrawFromPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterWithdraw = ERC20(token).balanceOf(\n            address(this)\n        );\n\n        if (tokenBalanceAfterWithdraw <= tokenBalanceBeforeWithdraw) {\n            revert TokenBalanceNotIncreasedAfterWithdraw(\n                token,\n                tokenBalanceBeforeWithdraw,\n                tokenBalanceAfterWithdraw,\n                amount\n            );\n        }\n\n        // Now, as balance before must be less than balance after, we can just check if the difference is the expected amount\n        if (tokenBalanceAfterWithdraw - tokenBalanceBeforeWithdraw != amount) {\n            revert UnexpectedWithdrawAmountFromPool(\n                token,\n                tokenBalanceBeforeWithdraw,\n                tokenBalanceAfterWithdraw,\n                amount\n            );\n        }\n    }\n\n    /* Helper Functions */\n\n    /**\n     * @dev Calculates the leveraged amount of the assets\n     * @param assets Amount of assets\n     * @return leveragedAssets Amount of leveraged assets\n     */\n    function getLeveragedAssets(uint256 assets) public view returns (uint256) {\n        return\n            (assets * targetLeverageBps) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n    }\n\n    /**\n     * @dev Gets the asset price from the oracle\n     * @param asset Address of the asset\n     * @return uint256 Price of the asset\n     */\n    function getAssetPriceFromOracle(\n        address asset\n    ) public view returns (uint256) {\n        uint256 assetPrice = _getAssetPriceFromOracleImplementation(asset);\n\n        // Sanity check\n        if (assetPrice == 0) {\n            revert AssetPriceIsZero(asset);\n        }\n\n        return assetPrice;\n    }\n\n    /**\n     * @dev Converts an amount in base currency to the actual amount in the token\n     * @param amountInBase Amount in base currency\n     * @param token Address of the token\n     * @return amountInToken Amount in the token\n     */\n    function convertFromBaseCurrencyToToken(\n        uint256 amountInBase,\n        address token\n    ) public view returns (uint256) {\n        // The price decimals is cancelled out in the division (as the amount and price are in the same unit)\n        uint256 tokenPriceInBase = getAssetPriceFromOracle(token);\n        return\n            (amountInBase * 10 ** ERC20(token).decimals()) / tokenPriceInBase;\n    }\n\n    /**\n     * @dev Converts an amount in the token to the actual amount in base currency\n     * @param amountInToken Amount in the token\n     * @param token Address of the token\n     * @return amountInBase Amount in base currency\n     */\n    function convertFromTokenAmountToBaseCurrency(\n        uint256 amountInToken,\n        address token\n    ) public view returns (uint256) {\n        // The token decimals is cancelled out in the division (as the amount and price are in the same unit)\n        uint256 tokenPriceInBase = getAssetPriceFromOracle(token);\n        return\n            (amountInToken * tokenPriceInBase) / 10 ** ERC20(token).decimals();\n    }\n\n    /**\n     * @dev Override of totalAssets from ERC4626\n     * @return uint256 Total assets in the vault\n     */\n    function totalAssets() public view virtual override returns (uint256) {\n        // We override this function to return the total assets in the vault\n        // with respect to the position in the lending pool\n        // The dLend interest will be distributed to the dToken\n        (uint256 totalCollateralBase, ) = getTotalCollateralAndDebtOfUserInBase(\n            address(this)\n        );\n        // The price decimals is cancelled out in the division (as the amount and price are in the same unit)\n        return\n            convertFromBaseCurrencyToToken(\n                totalCollateralBase,\n                address(collateralToken)\n            );\n    }\n\n    /* Safety */\n\n    /**\n     * @dev Returns whether the current leverage is too imbalanced\n     * @return bool True if leverage is too imbalanced, false otherwise\n     */\n    function isTooImbalanced() public view returns (bool) {\n        uint256 currentLeverageBps = getCurrentLeverageBps();\n        // If there is no deposit yet, we don't need to rebalance, thus it is not too imbalanced\n        return\n            currentLeverageBps != 0 &&\n            (currentLeverageBps < lowerBoundTargetLeverageBps ||\n                currentLeverageBps > upperBoundTargetLeverageBps);\n    }\n\n    /* Deposit and Mint */\n\n    /**\n     * @dev Deposits assets into the vault\n     *      - It will send the borrowed debt token and the minted shares to the receiver\n     *      - The minted shares represent the position of the supplied collateral assets in the lending pool\n     * @param caller Address of the caller\n     * @param receiver Address to receive the minted shares\n     * @param assets Amount of assets to deposit\n     * @param shares Amount of shares to mint\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal override nonReentrant {\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - The current collateral token balance is 0 WETH\n         * - The current debt token balance is 0 dUSD\n         * - The current shares supply is 0\n         * - Assume that the price of WETH is 2000 dUSD\n         *\n         * 1. User deposits 300 WETH\n         * 2. The vault supplies 300 WETH to the lending pool\n         * 3. The vault borrows 400,000 dUSD (300 * 2000 * 66.6666666%) from the lending pool\n         *    - 66.666% is to keep the target leverage 3x\n         * 4. The vault sends 400,000 dUSD to the receiver\n         * 5. The vault mints 300 shares to the user (representing 300 WETH position in the lending pool)\n         *\n         * The current leverage is: (300 * 2000) / (300 * 2000 - 400,000) = 3x\n         */\n\n        // Make sure the current leverage is within the target range\n        if (isTooImbalanced()) {\n            revert TooImbalanced(\n                getCurrentLeverageBps(),\n                lowerBoundTargetLeverageBps,\n                upperBoundTargetLeverageBps\n            );\n        }\n\n        uint256 debtAssetBorrowed = _depositToPoolImplementation(\n            caller,\n            assets\n        );\n\n        // Transfer the debt asset to the receiver\n        debtToken.safeTransfer(receiver, debtAssetBorrowed);\n\n        // Mint the vault's shares to the depositor\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Handles the logic of supplying collateral token and borrowing debt token\n     * @param caller Address of the caller\n     * @param supplyAssetAmount Amount of assets to supply\n     * @return debtAssetAmountToBorrow Amount of debt asset to borrow\n     */\n    function _depositToPoolImplementation(\n        address caller,\n        uint256 supplyAssetAmount // supply amount\n    ) private returns (uint256) {\n        // Transfer the assets to the vault (need the allowance before calling this function)\n        collateralToken.safeTransferFrom(\n            caller,\n            address(this),\n            supplyAssetAmount\n        );\n\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        // Get current leverage before supplying (IMPORTANT: this is the leverage before supplying)\n        uint256 currentLeverageBpsBeforeSupply = getCurrentLeverageBps();\n\n        // Make sure we have enough balance to supply before supplying\n        uint256 currentCollateralTokenBalance = collateralToken.balanceOf(\n            address(this)\n        );\n        if (currentCollateralTokenBalance < supplyAssetAmount) {\n            revert DepositInsufficientToSupply(\n                currentCollateralTokenBalance,\n                supplyAssetAmount\n            );\n        }\n\n        // Supply the collateral token to the lending pool\n        _supplyToPool(\n            address(collateralToken),\n            supplyAssetAmount,\n            address(this)\n        );\n\n        // Get the amount of debt token to borrow that keeps the current leverage\n        // If there is no deposit yet (leverage=0), we use the target leverage\n        uint256 debtTokenAmountToBorrow = getBorrowAmountThatKeepCurrentLeverage(\n                address(collateralToken),\n                address(debtToken),\n                supplyAssetAmount,\n                currentLeverageBpsBeforeSupply > 0\n                    ? currentLeverageBpsBeforeSupply\n                    : targetLeverageBps\n            );\n\n        // Borrow the max amount of debt token\n        _borrowFromPool(\n            address(debtToken),\n            debtTokenAmountToBorrow,\n            address(this)\n        );\n\n        return debtTokenAmountToBorrow;\n    }\n\n    /* Withdraw and Redeem */\n\n    /**\n     * @dev Withdraws collateral assets from the vault\n     *      - It requires to spend the debt token to repay the debt\n     *      - It will send the withdrawn collateral assets to the receiver and burn the shares\n     *      - The burned shares represent the position of the withdrawn assets in the lending pool\n     * @param caller Address of the caller\n     * @param receiver Address to receive the withdrawn assets\n     * @param owner Address of the owner\n     * @param assets Amount of assets to remove from the lending pool\n     * @param shares Amount of shares to burn\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal override nonReentrant {\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - The current shares supply is 300\n         * - The current leverage is 3x\n         * - The current collateral token balance is 300 WETH\n         * - The current debt token balance is 400,000 dUSD (300 * 2000 * 66.6666666%)\n         * - Assume that the price of WETH is 2000 dUSD\n         *\n         * 1. User has 100 shares\n         * 2. User wants to withdraw 100 WETH\n         * 3. The vault burns 100 shares\n         * 4. The vault transfers 133,333 dUSD (100 * 2000 * 66.6666666%) from the user to the vault\n         *    - 66.6666% is to keep the target leverage 3x\n         * 5. The vault repays 133,333 dUSD to the lending pool\n         *    - The debt is now 266,667 dUSD (400,000 - 133,333)\n         * 6. The vault withdraws 100 WETH from the lending pool\n         *    - The collateral is now 200 WETH (300 - 100)\n         * 7. The vault sends 100 WETH to the receiver\n         *\n         * The current leverage is: (200 * 2000) / (200 * 2000 - 266,667) = 3x\n         */\n\n        // Note that we need the allowance before calling this function\n        // - Allowance for the message sender to spend the shares on behalf of the owner\n        // - Allowance for the vault to burn the shares\n\n        // If the owner is not the caller, then we need to spend the allowance\n        // so that the caller can spend the shares on behalf of the owner\n        if (owner != caller) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // Check user's balance before burning shares\n        uint256 userShares = balanceOf(owner);\n        if (userShares < shares) {\n            revert InsufficientShareBalanceToRedeem(owner, shares, userShares);\n        }\n\n        // Burn the shares\n        _burn(owner, shares);\n\n        // Make sure the current leverage is within the target range\n        if (isTooImbalanced()) {\n            revert TooImbalanced(\n                getCurrentLeverageBps(),\n                lowerBoundTargetLeverageBps,\n                upperBoundTargetLeverageBps\n            );\n        }\n\n        // Withdraw the collateral from the lending pool\n        // After this step, the _withdrawFromPool wrapper function will also assert that\n        // the withdrawn amount is exactly the amount requested.\n        _withdrawFromPoolImplementation(caller, assets);\n\n        // Transfer the asset to the receiver\n        collateralToken.safeTransfer(receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @dev Handles the logic for repaying debt and withdrawing collateral from the pool\n     *      - It calculates the required debt token to repay to keep the current leverage\n     *        given the expected withdraw amount\n     *      - Then performs the actual repay and withdraw\n     * @param caller Address of the caller\n     * @param collateralTokenToWithdraw The amount of collateral token to withdraw\n     * @return repaidDebtTokenAmount The amount of debt token repaid\n     */\n    function _withdrawFromPoolImplementation(\n        address caller,\n        uint256 collateralTokenToWithdraw\n    ) private returns (uint256 repaidDebtTokenAmount) {\n        // Get the current leverage before repaying the debt (IMPORTANT: this is the leverage before repaying the debt)\n        // It is used to calculate the expected withdrawable amount that keeps the current leverage\n        uint256 leverageBpsBeforeRepayDebt = getCurrentLeverageBps();\n\n        repaidDebtTokenAmount = getRepayAmountThatKeepCurrentLeverage(\n            address(collateralToken),\n            address(debtToken),\n            collateralTokenToWithdraw,\n            leverageBpsBeforeRepayDebt\n        );\n\n        // If don't have enough allowance, revert with the error message\n        // This is to early-revert with instruction in the error message\n        if (\n            debtToken.allowance(caller, address(this)) < repaidDebtTokenAmount\n        ) {\n            revert InsufficientAllowanceOfDebtAssetToRepay(\n                caller,\n                address(this),\n                address(debtToken),\n                repaidDebtTokenAmount\n            );\n        }\n\n        // Transfer the debt token to the vault to repay the debt\n        debtToken.safeTransferFrom(\n            caller,\n            address(this),\n            repaidDebtTokenAmount\n        );\n\n        // Repay the debt to withdraw the collateral\n        _repayDebtToPool(\n            address(debtToken),\n            repaidDebtTokenAmount,\n            address(this)\n        );\n\n        // Withdraw the collateral\n        // At this step, the _withdrawFromPool wrapper function will also assert that\n        // the withdrawn amount is exactly the amount requested.\n        _withdrawFromPool(\n            address(collateralToken),\n            collateralTokenToWithdraw,\n            address(this)\n        );\n\n        return repaidDebtTokenAmount;\n    }\n\n    /* Calculate */\n\n    function getRepayAmountThatKeepCurrentLeverage(\n        address collateralAsset,\n        address debtAsset,\n        uint256 targetWithdrawAmount,\n        uint256 leverageBpsBeforeRepayDebt\n    ) public view returns (uint256 repayAmount) {\n        /* Formula definition:\n         * - C1: totalCollateralBase before repay\n         * - D1: totalDebtBase before repay\n         * - C2: totalCollateralBase after repay\n         * - D2: totalDebtBase after repay\n         * - T: target leverage\n         * - x: withdraw amount\n         * - y: repay amount\n         *\n         * We have:\n         *        C1 / (C1-D1) = C2 / (C2-D2)\n         *        C2 = C1-x\n         *        D2 = D1-y\n         *        C1 / (C1-D1) = T <=> C1 = (C1-D1) * T <=> C1 = C1*T - D1*T <=> C1*T - C1 = D1*T <=> C1 = D1*T/(T-1)\n         *\n         * Formula expression:\n         *        C1 / (C1-D1) = (C1-x) / (C1-x-D1+y)\n         *    <=> C1 * (C1-x-D1+y) = (C1-x) * (C1-D1)\n         *    <=> C1^2 - C1*x - C1*D1 + C1*y = C1^2 - C1*D1 - C1*x + D1*x\n         *    <=> C1^2 - C1*x - C1*D1 + C1*y = C1^2 - C1*x - C1*D1 + D1*x\n         *    <=> C1*y = x*D1\n         *    <=> y = x*D1 / C1\n         *    <=> y = x*D1 / [D1*T / (T-1)]\n         *    <=> y = x * (T-1)/T\n         */\n\n        // Convert the target withdraw amount to base\n        uint256 targetWithdrawAmountInBase = convertFromTokenAmountToBaseCurrency(\n                targetWithdrawAmount,\n                collateralAsset\n            );\n\n        // Calculate the repay amount in base\n        uint256 repayAmountInBase = (targetWithdrawAmountInBase *\n            leverageBpsBeforeRepayDebt) /\n            (leverageBpsBeforeRepayDebt -\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS);\n\n        return convertFromBaseCurrencyToToken(repayAmountInBase, debtAsset);\n    }\n\n    /**\n     * @dev Gets the borrow amount that keeps the current leverage\n     * @param collateralAsset The collateral asset\n     * @param debtAsset The debt asset\n     * @param suppliedCollateralAmount The actual supplied amount of collateral asset\n     * @param leverageBpsBeforeSupply Leverage in basis points before supplying\n     * @return expectedBorrowAmount The expected borrow amount that keeps the current leverage\n     */\n    function getBorrowAmountThatKeepCurrentLeverage(\n        address collateralAsset,\n        address debtAsset,\n        uint256 suppliedCollateralAmount,\n        uint256 leverageBpsBeforeSupply\n    ) public view returns (uint256 expectedBorrowAmount) {\n        /* Formula definition:\n         * - C1: totalCollateralBase before supply\n         * - D1: totalDebtBase before supply\n         * - C2: totalCollateralBase after supply\n         * - D2: totalDebtBase after supply\n         * - T: target leverage\n         * - x: supply amount\n         * - y: borrow amount\n         *\n         * We have:\n         *      C1 / (C1-D1) = C2 / (C2-D2)\n         *      C2 = C1+x\n         *      D2 = D1+y\n         *      C1 / (C1-D1) = T <=> C1 = (C1-D1) * T <=> C1 = C1*T - D1*T <=> C1*T - C1 = D1*T <=> C1 = D1*T/(T-1)\n         *\n         * Formula expression:\n         *      C1 / (C1-D1) = (C1+x) / (C1+x-D1-y)\n         *  <=> C1 * (C1+x-D1-y) = (C1+x) * (C1-D1)\n         *  <=> C1^2 + C1*x - C1*D1 - C1*y = C1^2 - C1*D1 + C1*x - D1*x\n         *  <=> C1*y = x*D1\n         *  <=> y = x*D1 / C1\n         *  <=> y = x * (T-1)/T\n         *  <=> x = y * T/(T-1)\n         */\n\n        // Convert the actual supplied amount to base\n        uint256 suppliedCollateralAmountInBase = convertFromTokenAmountToBaseCurrency(\n                suppliedCollateralAmount,\n                collateralAsset\n            );\n\n        // Calculate the borrow amount in base currency that keeps the current leverage\n        uint256 borrowAmountInBase = (suppliedCollateralAmountInBase *\n            leverageBpsBeforeSupply) /\n            (leverageBpsBeforeSupply -\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS);\n\n        return convertFromBaseCurrencyToToken(borrowAmountInBase, debtAsset);\n    }\n\n    /* Rebalance */\n\n    /**\n     * @dev Gets the rebalance amount to reach the target leverage in base currency\n     * @return tokenAmountInBase The amount of token to call increaseLeverage or decreaseLeverage (in base currency)\n     * @return direction The direction of the rebalance (1 for increase, -1 for decrease, 0 means no rebalance)\n     */\n    function getAmountToReachTargetLeverageInBase()\n        public\n        view\n        returns (uint256 tokenAmountInBase, int8 direction)\n    {\n        /**\n         * Formula definition:\n         * - C: totalCollateralBase\n         * - D: totalDebtBase\n         * - T: target leverage\n         * - k: subsidy (0.01 means 1%)\n         * - x: change amount of collateral in base currency\n         * - y: change amount of debt in base currency\n         *\n         * We have:\n         *      y = x*(1+k)\n         *      (C + x) / (C + x - D - y) = T\n         *  <=> (C + x) / (C + x - D - x*(1+k)) = T\n         *  <=> (C + x) = T * (C + x - D - x*(1+k))\n         *  <=> C + x = T*C + T*x - T*D - T*x - T*x*k\n         *  <=> C + x = T*C - T*D - T*x*k\n         *  <=> x + T*x*k = T*C - T*D - C\n         *  <=> x*(1 + T*k) = T*C - T*D - C\n         *  <=> x = (T*(C - D) - C) / (1 + T*k)\n         *\n         * If x > 0, it means the user should increase the leverage, so the direction is 1\n         *    => x = (T*(C - D) - C) / (1 + T*k)\n         * If x < 0, it means the user should decrease the leverage, so the direction is -1\n         *    => x = (C - T*(C - D)) / (1 + T*k)\n         * If x = 0, it means the user should not rebalance, so the direction is 0\n         */\n\n        (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase\n        ) = getTotalCollateralAndDebtOfUserInBase(address(this));\n\n        uint256 subsidyBps = getCurrentSubsidyBps();\n\n        uint256 currentLeverageBps = getCurrentLeverageBps();\n\n        // If the current leverage is below the target leverage, the user should increase the leverage\n        if (currentLeverageBps < targetLeverageBps) {\n            tokenAmountInBase =\n                (targetLeverageBps *\n                    (totalCollateralBase - totalDebtBase) -\n                    totalCollateralBase) /\n                (1 +\n                    (targetLeverageBps * subsidyBps) /\n                    BasisPointConstants.ONE_HUNDRED_PERCENT_BPS);\n            return (tokenAmountInBase, 1);\n        }\n        // If the current leverage is above the target leverage, the user should decrease the leverage\n        else if (currentLeverageBps > targetLeverageBps) {\n            tokenAmountInBase =\n                (totalCollateralBase -\n                    targetLeverageBps *\n                    (totalCollateralBase - totalDebtBase)) /\n                (1 +\n                    (targetLeverageBps * subsidyBps) /\n                    BasisPointConstants.ONE_HUNDRED_PERCENT_BPS);\n            return (tokenAmountInBase, -1);\n        }\n\n        // If the current leverage is equal to the target leverage, the user should not rebalance\n        return (0, 0);\n    }\n\n    /**\n     * @dev Increases the leverage of the user by supplying assets and borrowing more debt token\n     *      - It requires to spend the collateral token from the user's wallet to supply to the pool\n     *      - It will send the borrowed debt token to the user's wallet\n     * @param assetAmount The amount of asset to supply\n     * @param minReceivedAmount The minimum amount of debt token to receive\n     */\n    function increaseLeverage(\n        uint256 assetAmount,\n        uint256 minReceivedAmount\n    ) public nonReentrant {\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - Assume that the price of WETH is 2000 dUSD\n         * - The current leverage is 1.25x\n         *   - Total collateral: 100 WETH (100 * 2000 = 200,000 dUSD)\n         *   - Total debt: 40,000 dUSD\n         *   - Leverage: 200,000 / (200,000 - 40,000) = 1.25x\n         *\n         * 1. User call increaseLeverage with 50 WETH\n         * 2. The vault transfers 50 WETH from the user's wallet to the vault\n         * 3. The vault supplies 50 WETH to the lending pool\n         * 4. The vault borrows 100,000 dUSD (50 * 2000) from the lending pool\n         * 5. The vault sends 100,000 dUSD to the user\n         *\n         * The current leverage is now increased:\n         *    - Total collateral: 150 WETH (150 * 2000 = 300,000 dUSD)\n         *    - Total debt: 140,000 dUSD\n         *    - Leverage: 300,000 / (300,000 - 140,000) = 1.875x\n         */\n\n        // Make sure only increase the leverage if it is below the target leverage\n        uint256 currentLeverageBps = getCurrentLeverageBps();\n        if (currentLeverageBps >= targetLeverageBps) {\n            revert LeverageExceedsTarget(currentLeverageBps, targetLeverageBps);\n        }\n\n        uint256 assetAmountInBase = convertFromTokenAmountToBaseCurrency(\n            assetAmount,\n            address(collateralToken)\n        );\n\n        // The amount of debt token to borrow (in base currency) is equal to the amount of collateral token supplied\n        // plus the subsidy (bonus for the caller)\n        uint256 borrowedDebtTokenInBase = (assetAmountInBase *\n            (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS +\n                getCurrentSubsidyBps())) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase\n        ) = getTotalCollateralAndDebtOfUserInBase(address(this));\n\n        // Calculate the new leverage after increasing the leverage\n        uint256 newLeverageBps = ((totalCollateralBase + assetAmountInBase) *\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n            (totalCollateralBase +\n                assetAmountInBase -\n                totalDebtBase -\n                borrowedDebtTokenInBase);\n\n        // Make sure the new leverage is increasing and does not exceed the target leverage\n        if (\n            newLeverageBps > targetLeverageBps ||\n            newLeverageBps <= currentLeverageBps\n        ) {\n            revert IncreaseLeverageOutOfRange(\n                newLeverageBps,\n                targetLeverageBps,\n                currentLeverageBps\n            );\n        }\n\n        // Transfer the asset to the vault to supply\n        collateralToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            assetAmount\n        );\n\n        // Supply the asset to the lending pool\n        _supplyToPool(address(collateralToken), assetAmount, address(this));\n\n        // Borrow more debt token\n        uint256 borrowedDebtToken = convertFromBaseCurrencyToToken(\n            borrowedDebtTokenInBase,\n            address(debtToken)\n        );\n\n        // Slippage protection, to make sure the user receives at least minReceivedAmount\n        if (borrowedDebtToken < minReceivedAmount) {\n            revert RebalanceReceiveLessThanMinAmount(\n                \"increaseLeverage\",\n                borrowedDebtToken,\n                minReceivedAmount\n            );\n        }\n\n        // At this step, the _borrowFromPool wrapper function will also assert that\n        // the borrowed amount is exactly the amount requested, thus we can safely\n        // have the slippage check before calling this function\n        _borrowFromPool(address(debtToken), borrowedDebtToken, address(this));\n\n        // Transfer the debt token to the user\n        debtToken.safeTransfer(msg.sender, borrowedDebtToken);\n    }\n\n    /**\n     * @dev Decreases the leverage of the user by repaying debt and withdrawing collateral\n     *      - It requires to spend the debt token from the user's wallet to repay the debt to the pool\n     *      - It will send the withdrawn collateral asset to the user's wallet\n     * @param debtTokenAmount The amount of debt token to repay\n     * @param minReceivedAmount The minimum amount of collateral asset to receive\n     */\n    function decreaseLeverage(\n        uint256 debtTokenAmount,\n        uint256 minReceivedAmount\n    ) public nonReentrant {\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - Assume that the price of WETH is 2000 dUSD\n         * - The current leverage is 4x\n         *   - Total collateral: 100 WETH (100 * 2000 = 200,000 dUSD)\n         *   - Total debt: 150,000 dUSD\n         *   - Leverage: 200,000 / (200,000 - 150,000) = 4x\n         *\n         * 1. User call decreaseLeverage with 20,000 dUSD\n         * 2. The vault transfers 20,000 dUSD from the user's wallet to the vault\n         * 3. The vault repays 20,000 dUSD to the lending pool\n         * 4. The vault withdraws 10 WETH (20,000 / 2000) from the lending pool\n         * 5. The vault sends 10 WETH to the user\n         *\n         * The current leverage is now decreased:\n         *    - Total collateral: 90 WETH (90 * 2000 = 180,000 dUSD)\n         *    - Total debt: 130,000 dUSD\n         *    - Leverage: 180,000 / (180,000 - 130,000) = 3.6x\n         */\n        // Make sure only decrease the leverage if it is above the target leverage\n        uint256 currentLeverageBps = getCurrentLeverageBps();\n        if (currentLeverageBps <= targetLeverageBps) {\n            revert LeverageBelowTarget(currentLeverageBps, targetLeverageBps);\n        }\n\n        uint256 debtTokenAmountInBase = convertFromTokenAmountToBaseCurrency(\n            debtTokenAmount,\n            address(debtToken)\n        );\n\n        // The amount of collateral asset to withdraw is equal to the amount of debt token repaid\n        // plus the subsidy (bonus for the caller)\n        uint256 withdrawnAssetsBase = (debtTokenAmountInBase *\n            (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS +\n                getCurrentSubsidyBps())) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n\n        (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase\n        ) = getTotalCollateralAndDebtOfUserInBase(address(this));\n\n        // Calculate the new leverage after decreasing the leverage\n        uint256 newLeverageBps = ((totalCollateralBase - withdrawnAssetsBase) *\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n            (totalCollateralBase -\n                withdrawnAssetsBase -\n                totalDebtBase +\n                debtTokenAmountInBase);\n\n        // Make sure the new leverage is decreasing and is not below the target leverage\n        if (\n            newLeverageBps < targetLeverageBps ||\n            newLeverageBps >= currentLeverageBps\n        ) {\n            revert DecreaseLeverageOutOfRange(\n                newLeverageBps,\n                targetLeverageBps,\n                currentLeverageBps\n            );\n        }\n\n        // Transfer the debt token to the vault to repay the debt\n        debtToken.safeTransferFrom(msg.sender, address(this), debtTokenAmount);\n\n        _repayDebtToPool(address(debtToken), debtTokenAmount, address(this));\n\n        // Withdraw collateral\n        uint256 withdrawnAssets = convertFromBaseCurrencyToToken(\n            withdrawnAssetsBase,\n            address(collateralToken)\n        );\n\n        // Slippage protection, to make sure the user receives at least minReceivedAmount\n        if (withdrawnAssets < minReceivedAmount) {\n            revert RebalanceReceiveLessThanMinAmount(\n                \"decreaseLeverage\",\n                withdrawnAssets,\n                minReceivedAmount\n            );\n        }\n\n        // At this step, the _withdrawFromPool wrapper function will also assert that\n        // the withdrawn amount is exactly the amount requested, thus we can safely\n        // have the slippage check before calling this function\n        _withdrawFromPool(\n            address(collateralToken),\n            withdrawnAssets,\n            address(this)\n        );\n\n        // Transfer the collateral asset to the user\n        collateralToken.safeTransfer(msg.sender, withdrawnAssets);\n    }\n\n    /* Informational */\n\n    /**\n     * @dev Gets the current leverage in basis points\n     * @return uint256 The current leverage in basis points\n     */\n    function getCurrentLeverageBps() public view returns (uint256) {\n        (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase\n        ) = getTotalCollateralAndDebtOfUserInBase(address(this));\n\n        if (totalCollateralBase < totalDebtBase) {\n            revert CollateralLessThanDebt(totalCollateralBase, totalDebtBase);\n        }\n        if (totalCollateralBase == 0) {\n            return 0;\n        }\n        if (totalCollateralBase == totalDebtBase) {\n            return type(uint256).max; // infinite leverage\n        }\n        // The leverage will be 1 if totalDebtBase is 0 (no more debt)\n        uint256 leverageBps = ((totalCollateralBase *\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n            (totalCollateralBase - totalDebtBase));\n        if (leverageBps <= BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert InvalidLeverage(leverageBps);\n        }\n        return leverageBps;\n    }\n\n    /**\n     * @dev Gets the current subsidy in basis points\n     * @return uint256 The current subsidy in basis points\n     */\n    function getCurrentSubsidyBps() public view returns (uint256) {\n        uint256 currentLeverageBps = getCurrentLeverageBps();\n\n        uint256 subsidyBps;\n        if (currentLeverageBps > targetLeverageBps) {\n            subsidyBps =\n                ((currentLeverageBps - targetLeverageBps) *\n                    BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n                targetLeverageBps;\n        } else {\n            subsidyBps =\n                ((targetLeverageBps - currentLeverageBps) *\n                    BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n                targetLeverageBps;\n        }\n        if (subsidyBps > maxSubsidyBps) {\n            return maxSubsidyBps;\n        }\n        return subsidyBps;\n    }\n\n    /**\n     * @dev Gets the address of the collateral token\n     * @return address The address of the collateral token\n     */\n    function getCollateralTokenAddress() public view returns (address) {\n        return address(collateralToken);\n    }\n\n    /**\n     * @dev Gets the address of the debt token\n     * @return address The address of the debt token\n     */\n    function getDebtTokenAddress() public view returns (address) {\n        return address(debtToken);\n    }\n\n    /**\n     * @dev Gets the default maximum subsidy in basis points\n     * @return uint256 The default maximum subsidy in basis points\n     */\n    function getDefaultMaxSubsidyBps() public view returns (uint256) {\n        return maxSubsidyBps;\n    }\n\n    /* Admin */\n\n    /**\n     * @dev Sets the maximum subsidy in basis points\n     * @param _maxSubsidyBps New maximum subsidy in basis points\n     */\n    function setMaxSubsidyBps(\n        uint256 _maxSubsidyBps\n    ) public onlyOwner nonReentrant {\n        maxSubsidyBps = _maxSubsidyBps;\n    }\n\n    /**\n     * @dev Sets the lower and upper bounds of target leverage\n     * @param _lowerBoundTargetLeverageBps New lower bound of target leverage in basis points\n     * @param _upperBoundTargetLeverageBps New upper bound of target leverage in basis points\n     */\n    function setLeverageBounds(\n        uint32 _lowerBoundTargetLeverageBps,\n        uint32 _upperBoundTargetLeverageBps\n    ) public onlyOwner nonReentrant {\n        if (\n            _lowerBoundTargetLeverageBps >= targetLeverageBps ||\n            targetLeverageBps >= _upperBoundTargetLeverageBps\n        ) {\n            revert InvalidLeverageBounds(\n                _lowerBoundTargetLeverageBps,\n                targetLeverageBps,\n                _upperBoundTargetLeverageBps\n            );\n        }\n\n        lowerBoundTargetLeverageBps = _lowerBoundTargetLeverageBps;\n        upperBoundTargetLeverageBps = _upperBoundTargetLeverageBps;\n    }\n\n    /* Overrides to add leverage check */\n\n    function maxDeposit(address _user) public view override returns (uint256) {\n        // Don't allow deposit if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        return super.maxDeposit(_user);\n    }\n\n    function maxMint(address _user) public view override returns (uint256) {\n        // Don't allow mint if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        return super.maxMint(_user);\n    }\n\n    function maxWithdraw(address _user) public view override returns (uint256) {\n        // Don't allow withdraw if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        return super.maxWithdraw(_user);\n    }\n\n    function maxRedeem(address _user) public view override returns (uint256) {\n        // Don't allow redeem if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        return super.maxRedeem(_user);\n    }\n}\n"
    },
    "contracts/dloop/core/venue/dlend/DLoopCoreDLend.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\n\nimport {IPriceOracleGetter} from \"./interface/IPriceOracleGetter.sol\";\nimport {IPool as ILendingPool, DataTypes} from \"./interface/IPool.sol\";\nimport {IPoolAddressesProvider} from \"./interface/IPoolAddressesProvider.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {DLoopCoreBase} from \"../../DLoopCoreBase.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title DLoopCoreDLend\n * @dev Read the documentation of DLoopCoreBase for more details\n *      - This contract implement dLEND-specific lending operations for DLoopCoreBase\n */\ncontract DLoopCoreDLend is DLoopCoreBase {\n    /* Constants */\n\n    uint8 public constant AAVE_PRICE_ORACLE_DECIMALS = 8;\n\n    // Note that there is a vulnerability in stable interest rate mode, so we will never use it\n    // See contracts/lending/core/protocol/libraries/types/DataTypes.sol\n    uint256 public constant VARIABLE_LENDING_INTERST_RATE_MODE = 2; // 0 = NONE, 1 = STABLE, 2 = VARIABLE\n\n    // Maximum percentage factor (100.00%)\n    uint256 public constant PERCENTAGE_FACTOR = 1e4;\n\n    /* State */\n\n    IPoolAddressesProvider public immutable lendingPoolAddressesProvider;\n\n    /**\n     * @dev Constructor for the DLoopCoreDLend contract\n     * @param _name Name of the vault token\n     * @param _symbol Symbol of the vault token\n     * @param _collateralToken Address of the collateral token\n     * @param _debtToken Address of the debt token\n     * @param _lendingPoolAddressesProvider Address of the lending pool addresses provider\n     * @param _targetLeverageBps Target leverage in basis points\n     * @param _lowerBoundTargetLeverageBps Lower bound of target leverage in basis points\n     * @param _upperBoundTargetLeverageBps Upper bound of target leverage in basis points\n     * @param _maxSubsidyBps Maximum subsidy in basis points\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        ERC20 _collateralToken,\n        ERC20 _debtToken,\n        IPoolAddressesProvider _lendingPoolAddressesProvider,\n        uint32 _targetLeverageBps,\n        uint32 _lowerBoundTargetLeverageBps,\n        uint32 _upperBoundTargetLeverageBps,\n        uint256 _maxSubsidyBps\n    )\n        DLoopCoreBase(\n            _name,\n            _symbol,\n            _collateralToken,\n            _debtToken,\n            _targetLeverageBps,\n            _lowerBoundTargetLeverageBps,\n            _upperBoundTargetLeverageBps,\n            _maxSubsidyBps\n        )\n    {\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n\n        if (getLendingOracle().BASE_CURRENCY() != address(0)) {\n            revert(\"Invalid price oracle base currency\");\n        }\n\n        uint256 oracleUnit = getLendingOracle().BASE_CURRENCY_UNIT();\n\n        if (oracleUnit != 10 ** AAVE_PRICE_ORACLE_DECIMALS) {\n            revert(\"Invalid price oracle unit\");\n        }\n    }\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return address[] Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens()\n        public\n        view\n        override\n        returns (address[] memory)\n    {\n        DataTypes.ReserveData memory reserveData = _getReserveData(\n            address(collateralToken)\n        );\n        address[] memory restrictedRescueTokens = new address[](3);\n        restrictedRescueTokens[0] = reserveData.aTokenAddress;\n        restrictedRescueTokens[1] = reserveData.variableDebtTokenAddress;\n        restrictedRescueTokens[2] = reserveData.stableDebtTokenAddress;\n        return restrictedRescueTokens;\n    }\n\n    /**\n     * @dev Gets the asset price from the oracle\n     * @param asset Address of the asset\n     * @return uint256 Price of the asset\n     */\n    function _getAssetPriceFromOracleImplementation(\n        address asset\n    ) internal view override returns (uint256) {\n        return getLendingOracle().getAssetPrice(asset);\n    }\n\n    /**\n     * @dev Supply tokens to the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to supply\n     * @param onBehalfOf Address to supply on behalf of\n     */\n    function _supplyToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        ILendingPool lendingPool = getLendingPool();\n\n        // Approve the lending pool to spend the token\n        require(\n            ERC20(token).approve(address(lendingPool), amount),\n            \"approve failed for lending pool in supply\"\n        );\n\n        // Supply the token to the lending pool\n        lendingPool.supply(token, amount, onBehalfOf, 0);\n    }\n\n    /**\n     * @dev Borrow tokens from the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to borrow\n     * @param onBehalfOf Address to borrow on behalf of\n     */\n    function _borrowFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        getLendingPool().borrow(\n            token,\n            amount,\n            VARIABLE_LENDING_INTERST_RATE_MODE,\n            0,\n            onBehalfOf\n        );\n    }\n\n    /**\n     * @dev Repay debt to the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to repay\n     * @param onBehalfOf Address to repay on behalf of\n     */\n    function _repayDebtToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        ILendingPool lendingPool = getLendingPool();\n\n        // Approve the lending pool to spend the token\n        require(\n            ERC20(token).approve(address(lendingPool), amount),\n            \"approve failed for lending pool in repay\"\n        );\n\n        // Repay the debt\n        lendingPool.repay(\n            token,\n            amount,\n            VARIABLE_LENDING_INTERST_RATE_MODE,\n            onBehalfOf\n        );\n    }\n\n    /**\n     * @dev Withdraw tokens from the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to withdraw\n     * @param onBehalfOf Address to withdraw on behalf of\n     */\n    function _withdrawFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        getLendingPool().withdraw(token, amount, onBehalfOf);\n    }\n\n    /**\n     * @dev Gets the total collateral and debt of a user in base currency\n     * @param user Address of the user\n     * @return totalCollateralBase Total collateral in base currency\n     * @return totalDebtBase Total debt in base currency\n     */\n    function getTotalCollateralAndDebtOfUserInBase(\n        address user\n    )\n        public\n        view\n        override\n        returns (uint256 totalCollateralBase, uint256 totalDebtBase)\n    {\n        (totalCollateralBase, totalDebtBase, , , , ) = getLendingPool()\n            .getUserAccountData(user);\n        return (totalCollateralBase, totalDebtBase);\n    }\n\n    /* Helper functions */\n\n    /**\n     * @dev Gets the lending oracle\n     * @return IPriceOracleGetter The lending oracle interface\n     */\n    function getLendingOracle() public view returns (IPriceOracleGetter) {\n        return\n            IPriceOracleGetter(lendingPoolAddressesProvider.getPriceOracle());\n    }\n\n    /**\n     * @dev Gets the lending pool\n     * @return ILendingPool The lending pool interface\n     */\n    function getLendingPool() public view returns (ILendingPool) {\n        return ILendingPool(lendingPoolAddressesProvider.getPool());\n    }\n\n    /**\n     * @dev Gets the lending pool address\n     * @return address The lending pool address\n     */\n    function getLendingPoolAddress() public view returns (address) {\n        return address(getLendingPool());\n    }\n\n    /**\n     * @dev Gets the oracle address\n     * @return address The oracle address\n     */\n    function getOracleAddress() public view returns (address) {\n        return address(getLendingOracle());\n    }\n\n    /**\n     * @dev Gets the reserve data for a token\n     * @param tokenAddress The address of the token\n     * @return DataTypes.ReserveData The reserve data\n     */\n    function _getReserveData(\n        address tokenAddress\n    ) internal view returns (DataTypes.ReserveData memory) {\n        return getLendingPool().getReserveData(tokenAddress);\n    }\n\n    /**\n     * @dev Gets the DToken address for a token\n     * @param tokenAddress The address of the token\n     * @return address The DToken address\n     */\n    function _getDTokenAddress(\n        address tokenAddress\n    ) internal view returns (address) {\n        return _getReserveData(tokenAddress).aTokenAddress;\n    }\n\n    /**\n     * @dev Gets the DToken balance of the vault\n     * @param tokenAddress The address of the token\n     * @return uint256 The DToken balance of the vault\n     */\n    function getDTokenBalance(\n        address tokenAddress\n    ) public view returns (uint256) {\n        return ERC20(_getDTokenAddress(tokenAddress)).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/dloop/core/venue/dlend/interface/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\nimport {DataTypes} from \"./types/DataTypes.sol\";\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n    /**\n     * @dev Emitted on mintUnbacked()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the supply\n     * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n     * @param amount The amount of supplied assets\n     * @param referralCode The referral code used\n     */\n    event MintUnbacked(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on backUnbacked()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param backer The address paying for the backing\n     * @param amount The amount added as backing\n     * @param fee The amount paid in fees\n     */\n    event BackUnbacked(\n        address indexed reserve,\n        address indexed backer,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /**\n     * @dev Emitted on supply()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the supply\n     * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n     * @param amount The amount supplied\n     * @param referralCode The referral code used\n     */\n    event Supply(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlying asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to The address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     */\n    event Withdraw(\n        address indexed reserve,\n        address indexed user,\n        address indexed to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n     * @param referralCode The referral code used\n     */\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 borrowRate,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the funds\n     * @param amount The amount repaid\n     * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n     */\n    event Repay(\n        address indexed reserve,\n        address indexed user,\n        address indexed repayer,\n        uint256 amount,\n        bool useATokens\n    );\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n     */\n    event SwapBorrowRateMode(\n        address indexed reserve,\n        address indexed user,\n        DataTypes.InterestRateMode interestRateMode\n    );\n\n    /**\n     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n     * @param asset The address of the underlying asset of the reserve\n     * @param totalDebt The total isolation mode debt for the reserve\n     */\n    event IsolationModeTotalDebtUpdated(\n        address indexed asset,\n        uint256 totalDebt\n    );\n\n    /**\n     * @dev Emitted when the user selects a certain asset category for eMode\n     * @param user The address of the user\n     * @param categoryId The category id\n     */\n    event UserEModeSet(address indexed user, uint8 categoryId);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     */\n    event ReserveUsedAsCollateralEnabled(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     */\n    event ReserveUsedAsCollateralDisabled(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     */\n    event RebalanceStableBorrowRate(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     */\n    event FlashLoan(\n        address indexed target,\n        address initiator,\n        address indexed asset,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 premium,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted when a borrower is liquidated.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     */\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated.\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The next liquidity rate\n     * @param stableBorrowRate The next stable borrow rate\n     * @param variableBorrowRate The next variable borrow rate\n     * @param liquidityIndex The next liquidity index\n     * @param variableBorrowIndex The next variable borrow index\n     */\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n     * @param reserve The address of the reserve\n     * @param amountMinted The amount minted to the treasury\n     */\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n    /**\n     * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n     * @param asset The address of the underlying asset to mint\n     * @param amount The amount to mint\n     * @param onBehalfOf The address that will receive the aTokens\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function mintUnbacked(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n     * @param asset The address of the underlying asset to back\n     * @param amount The amount to back\n     * @param fee The amount paid in fees\n     * @return The backed amount\n     */\n    function backUnbacked(\n        address asset,\n        uint256 amount,\n        uint256 fee\n    ) external returns (uint256);\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function supply(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Supply with transfer approval of asset to be supplied done via permit function\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     */\n    function supplyWithPermit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external;\n\n    /**\n     * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to The address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     */\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     */\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     */\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @notice Repay with transfer approval of asset to be repaid done via permit function\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     * @return The final amount repaid\n     */\n    function repayWithPermit(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external returns (uint256);\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n     * equivalent debt tokens\n     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n     * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n     * balance is not enough to cover the whole debt\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @return The final amount repaid\n     */\n    function repayWithATokens(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n     * @param asset The address of the underlying asset borrowed\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n     */\n    function swapBorrowRateMode(\n        address asset,\n        uint256 interestRateMode\n    ) external;\n\n    /**\n     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n     *        much has been borrowed at a stable rate and suppliers are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     */\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n     * @param asset The address of the underlying asset supplied\n     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n     */\n    function setUserUseReserveAsCollateral(\n        address asset,\n        bool useAsCollateral\n    ) external;\n\n    /**\n     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     */\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n     * into consideration. For further details please visit https://docs.aave.com/developers/\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts of the assets being flash-borrowed\n     * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata interestRateModes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n     * into consideration. For further details please visit https://docs.aave.com/developers/\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n     * @param asset The address of the asset being flash-borrowed\n     * @param amount The amount of the asset being flash-borrowed\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function flashLoanSimple(\n        address receiverAddress,\n        address asset,\n        uint256 amount,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n     * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n     * @return currentLiquidationThreshold The liquidation threshold of the user\n     * @return ltv The loan to value of The user\n     * @return healthFactor The current health factor of the user\n     */\n    function getUserAccountData(\n        address user\n    )\n        external\n        view\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    /**\n     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n     * interest rate strategy\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n     * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\n     */\n    function initReserve(\n        address asset,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    /**\n     * @notice Drop a reserve\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     */\n    function dropReserve(address asset) external;\n\n    /**\n     * @notice Updates the address of the interest rate strategy contract\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param rateStrategyAddress The address of the interest rate strategy contract\n     */\n    function setReserveInterestRateStrategyAddress(\n        address asset,\n        address rateStrategyAddress\n    ) external;\n\n    /**\n     * @notice Sets the configuration bitmap of the reserve as a whole\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param configuration The new configuration bitmap\n     */\n    function setConfiguration(\n        address asset,\n        DataTypes.ReserveConfigurationMap calldata configuration\n    ) external;\n\n    /**\n     * @notice Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     */\n    function getConfiguration(\n        address asset\n    ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @notice Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     */\n    function getUserConfiguration(\n        address user\n    ) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @notice Returns the normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(\n        address asset\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the normalized variable debt per unit of asset\n     * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n     * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n     * moment (approx. a borrower would get if opening a position). This means that is always used in\n     * combination with variable debt supply/balances.\n     * If using this function externally, consider that is possible to have an increasing normalized\n     * variable debt that is not equivalent to how the variable debt index would be updated in storage\n     * (e.g. only updates with non-zero variable debt supply)\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(\n        address asset\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state and configuration data of the reserve\n     */\n    function getReserveData(\n        address asset\n    ) external view returns (DataTypes.ReserveData memory);\n\n    /**\n     * @notice Validates and finalizes an aToken transfer\n     * @dev Only callable by the overlying aToken of the `asset`\n     * @param asset The address of the underlying asset of the aToken\n     * @param from The user from which the aTokens are transferred\n     * @param to The user receiving the aTokens\n     * @param amount The amount being transferred/withdrawn\n     * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n     * @param balanceToBefore The aToken balance of the `to` user before the transfer\n     */\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromBefore,\n        uint256 balanceToBefore\n    ) external;\n\n    /**\n     * @notice Returns the list of the underlying assets of all the initialized reserves\n     * @dev It does not include dropped reserves\n     * @return The addresses of the underlying assets of the initialized reserves\n     */\n    function getReservesList() external view returns (address[] memory);\n\n    /**\n     * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n     * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n     * @return The address of the reserve associated with id\n     */\n    function getReserveAddressById(uint16 id) external view returns (address);\n\n    /**\n     * @notice Returns the PoolAddressesProvider connected to this contract\n     * @return The address of the PoolAddressesProvider\n     */\n    function ADDRESSES_PROVIDER()\n        external\n        view\n        returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Updates the protocol fee on the bridging\n     * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n     */\n    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n    /**\n     * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n     * - A part is sent to aToken holders as extra, one time accumulated interest\n     * - A part is collected by the protocol treasury\n     * @dev The total premium is calculated on the total borrowed amount\n     * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n     * @dev Only callable by the PoolConfigurator contract\n     * @param flashLoanPremiumTotal The total premium, expressed in bps\n     * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n     */\n    function updateFlashloanPremiums(\n        uint128 flashLoanPremiumTotal,\n        uint128 flashLoanPremiumToProtocol\n    ) external;\n\n    /**\n     * @notice Configures a new category for the eMode.\n     * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n     * The category 0 is reserved as it's the default for volatile assets\n     * @param id The id of the category\n     * @param config The configuration of the category\n     */\n    function configureEModeCategory(\n        uint8 id,\n        DataTypes.EModeCategory memory config\n    ) external;\n\n    /**\n     * @notice Returns the data of an eMode category\n     * @param id The id of the category\n     * @return The configuration data of the category\n     */\n    function getEModeCategoryData(\n        uint8 id\n    ) external view returns (DataTypes.EModeCategory memory);\n\n    /**\n     * @notice Allows a user to use the protocol in eMode\n     * @param categoryId The id of the category\n     */\n    function setUserEMode(uint8 categoryId) external;\n\n    /**\n     * @notice Returns the eMode the user is using\n     * @param user The address of the user\n     * @return The eMode id\n     */\n    function getUserEMode(address user) external view returns (uint256);\n\n    /**\n     * @notice Resets the isolation mode total debt of the given asset to zero\n     * @dev It requires the given asset has zero debt ceiling\n     * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n     */\n    function resetIsolationModeTotalDebt(address asset) external;\n\n    /**\n     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n     * @return The percentage of available liquidity to borrow, expressed in bps\n     */\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT()\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the total fee on flash loans\n     * @return The total fee on flashloans\n     */\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n    /**\n     * @notice Returns the part of the bridge fees sent to protocol\n     * @return The bridge fee sent to the protocol treasury\n     */\n    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n    /**\n     * @notice Returns the part of the flashloan fees sent to protocol\n     * @return The flashloan fee sent to the protocol treasury\n     */\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n    /**\n     * @notice Returns the maximum number of reserves supported to be listed in this Pool\n     * @return The maximum number of reserves supported\n     */\n    function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n    /**\n     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n     * @param assets The list of reserves for which the minting needs to be executed\n     */\n    function mintToTreasury(address[] calldata assets) external;\n\n    /**\n     * @notice Rescue and transfer tokens locked in this contract\n     * @param token The address of the token\n     * @param to The address of the recipient\n     * @param amount The amount of token to transfer\n     */\n    function rescueTokens(address token, address to, uint256 amount) external;\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n     * @dev Deprecated: Use the `supply` function instead\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n}\n"
    },
    "contracts/dloop/core/venue/dlend/interface/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n    /**\n     * @dev Emitted when the market identifier is updated.\n     * @param oldMarketId The old id of the market\n     * @param newMarketId The new id of the market\n     */\n    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n    /**\n     * @dev Emitted when the pool is updated.\n     * @param oldAddress The old address of the Pool\n     * @param newAddress The new address of the Pool\n     */\n    event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the pool configurator is updated.\n     * @param oldAddress The old address of the PoolConfigurator\n     * @param newAddress The new address of the PoolConfigurator\n     */\n    event PoolConfiguratorUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the price oracle is updated.\n     * @param oldAddress The old address of the PriceOracle\n     * @param newAddress The new address of the PriceOracle\n     */\n    event PriceOracleUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the ACL manager is updated.\n     * @param oldAddress The old address of the ACLManager\n     * @param newAddress The new address of the ACLManager\n     */\n    event ACLManagerUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the ACL admin is updated.\n     * @param oldAddress The old address of the ACLAdmin\n     * @param newAddress The new address of the ACLAdmin\n     */\n    event ACLAdminUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the price oracle sentinel is updated.\n     * @param oldAddress The old address of the PriceOracleSentinel\n     * @param newAddress The new address of the PriceOracleSentinel\n     */\n    event PriceOracleSentinelUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the pool data provider is updated.\n     * @param oldAddress The old address of the PoolDataProvider\n     * @param newAddress The new address of the PoolDataProvider\n     */\n    event PoolDataProviderUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when a new proxy is created.\n     * @param id The identifier of the proxy\n     * @param proxyAddress The address of the created proxy contract\n     * @param implementationAddress The address of the implementation contract\n     */\n    event ProxyCreated(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address indexed implementationAddress\n    );\n\n    /**\n     * @dev Emitted when a new non-proxied contract address is registered.\n     * @param id The identifier of the contract\n     * @param oldAddress The address of the old contract\n     * @param newAddress The address of the new contract\n     */\n    event AddressSet(\n        bytes32 indexed id,\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the implementation of the proxy registered with id is updated\n     * @param id The identifier of the contract\n     * @param proxyAddress The address of the proxy contract\n     * @param oldImplementationAddress The address of the old implementation contract\n     * @param newImplementationAddress The address of the new implementation contract\n     */\n    event AddressSetAsProxy(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address oldImplementationAddress,\n        address indexed newImplementationAddress\n    );\n\n    /**\n     * @notice Returns the id of the Aave market to which this contract points to.\n     * @return The market id\n     */\n    function getMarketId() external view returns (string memory);\n\n    /**\n     * @notice Associates an id with a specific PoolAddressesProvider.\n     * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n     * identify and validate multiple Aave markets.\n     * @param newMarketId The market id\n     */\n    function setMarketId(string calldata newMarketId) external;\n\n    /**\n     * @notice Returns an address by its identifier.\n     * @dev The returned address might be an EOA or a contract, potentially proxied\n     * @dev It returns ZERO if there is no registered address with the given id\n     * @param id The id\n     * @return The address of the registered for the specified id\n     */\n    function getAddressFromID(bytes32 id) external view returns (address);\n\n    /**\n     * @notice General function to update the implementation of a proxy registered with\n     * certain `id`. If there is no proxy registered, it will instantiate one and\n     * set as implementation the `newImplementationAddress`.\n     * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n     * setter function, in order to avoid unexpected consequences\n     * @param id The id\n     * @param newImplementationAddress The address of the new implementation\n     */\n    function setAddressAsProxy(\n        bytes32 id,\n        address newImplementationAddress\n    ) external;\n\n    /**\n     * @notice Sets an address for an id replacing the address saved in the addresses map.\n     * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n     * @param id The id\n     * @param newAddress The address to set\n     */\n    function setAddress(bytes32 id, address newAddress) external;\n\n    /**\n     * @notice Returns the address of the Pool proxy.\n     * @return The Pool proxy address\n     */\n    function getPool() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the Pool, or creates a proxy\n     * setting the new `pool` implementation when the function is called for the first time.\n     * @param newPoolImpl The new Pool implementation\n     */\n    function setPoolImpl(address newPoolImpl) external;\n\n    /**\n     * @notice Returns the address of the PoolConfigurator proxy.\n     * @return The PoolConfigurator proxy address\n     */\n    function getPoolConfigurator() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n     * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n     * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n     */\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n    /**\n     * @notice Returns the address of the price oracle.\n     * @return The address of the PriceOracle\n     */\n    function getPriceOracle() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle.\n     * @param newPriceOracle The address of the new PriceOracle\n     */\n    function setPriceOracle(address newPriceOracle) external;\n\n    /**\n     * @notice Returns the address of the ACL manager.\n     * @return The address of the ACLManager\n     */\n    function getACLManager() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL manager.\n     * @param newAclManager The address of the new ACLManager\n     */\n    function setACLManager(address newAclManager) external;\n\n    /**\n     * @notice Returns the address of the ACL admin.\n     * @return The address of the ACL admin\n     */\n    function getACLAdmin() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL admin.\n     * @param newAclAdmin The address of the new ACL admin\n     */\n    function setACLAdmin(address newAclAdmin) external;\n\n    /**\n     * @notice Returns the address of the price oracle sentinel.\n     * @return The address of the PriceOracleSentinel\n     */\n    function getPriceOracleSentinel() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle sentinel.\n     * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n     */\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n    /**\n     * @notice Returns the address of the data provider.\n     * @return The address of the DataProvider\n     */\n    function getPoolDataProvider() external view returns (address);\n\n    /**\n     * @notice Updates the address of the data provider.\n     * @param newDataProvider The address of the new DataProvider\n     */\n    function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "contracts/dloop/core/venue/dlend/interface/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n    /**\n     * @notice Returns the base currency address\n     * @dev Address 0x0 is reserved for USD as base currency.\n     * @return Returns the base currency address.\n     */\n    function BASE_CURRENCY() external view returns (address);\n\n    /**\n     * @notice Returns the base currency unit\n     * @dev 1 ether for ETH, 1e8 for USD.\n     * @return Returns the base currency unit.\n     */\n    function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n    /**\n     * @notice Returns the asset price in the base currency\n     * @param asset The address of the asset\n     * @return The price of the asset\n     */\n    function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/dloop/core/venue/dlend/interface/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        //timestamp of last update\n        uint40 lastUpdateTimestamp;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint16 id;\n        //aToken address\n        address aTokenAddress;\n        //stableDebtToken address\n        address stableDebtTokenAddress;\n        //variableDebtToken address\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the current treasury balance, scaled\n        uint128 accruedToTreasury;\n        //the outstanding unbacked aTokens minted through the bridging feature\n        uint128 unbacked;\n        //the outstanding debt borrowed against this asset in isolation mode\n        uint128 isolationModeTotalDebt;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60: asset is paused\n        //bit 61: borrowing in isolation mode is enabled\n        //bit 62: siloed borrowing enabled\n        //bit 63: flashloaning enabled\n        //bit 64-79: reserve factor\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n        //bit 152-167 liquidation protocol fee\n        //bit 168-175 eMode category\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n        //bit 252-255 unused\n\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        /**\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\n         * asset is borrowed by the user.\n         */\n        uint256 data;\n    }\n\n    struct EModeCategory {\n        // each eMode category has a custom ltv and liquidation threshold\n        uint16 ltv;\n        uint16 liquidationThreshold;\n        uint16 liquidationBonus;\n        // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n        address priceSource;\n        string label;\n    }\n\n    enum InterestRateMode {\n        NONE,\n        STABLE,\n        VARIABLE\n    }\n\n    struct ReserveCache {\n        uint256 currScaledVariableDebt;\n        uint256 nextScaledVariableDebt;\n        uint256 currPrincipalStableDebt;\n        uint256 currAvgStableBorrowRate;\n        uint256 currTotalStableDebt;\n        uint256 nextAvgStableBorrowRate;\n        uint256 nextTotalStableDebt;\n        uint256 currLiquidityIndex;\n        uint256 nextLiquidityIndex;\n        uint256 currVariableBorrowIndex;\n        uint256 nextVariableBorrowIndex;\n        uint256 currLiquidityRate;\n        uint256 currVariableBorrowRate;\n        uint256 reserveFactor;\n        ReserveConfigurationMap reserveConfiguration;\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        uint40 reserveLastUpdateTimestamp;\n        uint40 stableDebtLastUpdateTimestamp;\n    }\n\n    struct ExecuteLiquidationCallParams {\n        uint256 reservesCount;\n        uint256 debtToCover;\n        address collateralAsset;\n        address debtAsset;\n        address user;\n        bool receiveAToken;\n        address priceOracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteSupplyParams {\n        address asset;\n        uint256 amount;\n        address onBehalfOf;\n        uint16 referralCode;\n    }\n\n    struct ExecuteBorrowParams {\n        address asset;\n        address user;\n        address onBehalfOf;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        uint16 referralCode;\n        bool releaseUnderlying;\n        uint256 maxStableRateBorrowSizePercent;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteRepayParams {\n        address asset;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        address onBehalfOf;\n        bool useATokens;\n    }\n\n    struct ExecuteWithdrawParams {\n        address asset;\n        uint256 amount;\n        address to;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n    }\n\n    struct ExecuteSetUserEModeParams {\n        uint256 reservesCount;\n        address oracle;\n        uint8 categoryId;\n    }\n\n    struct FinalizeTransferParams {\n        address asset;\n        address from;\n        address to;\n        uint256 amount;\n        uint256 balanceFromBefore;\n        uint256 balanceToBefore;\n        uint256 reservesCount;\n        address oracle;\n        uint8 fromEModeCategory;\n    }\n\n    struct FlashloanParams {\n        address receiverAddress;\n        address[] assets;\n        uint256[] amounts;\n        uint256[] interestRateModes;\n        address onBehalfOf;\n        bytes params;\n        uint16 referralCode;\n        uint256 flashLoanPremiumToProtocol;\n        uint256 flashLoanPremiumTotal;\n        uint256 maxStableRateBorrowSizePercent;\n        uint256 reservesCount;\n        address addressesProvider;\n        uint8 userEModeCategory;\n        bool isAuthorizedFlashBorrower;\n    }\n\n    struct FlashloanSimpleParams {\n        address receiverAddress;\n        address asset;\n        uint256 amount;\n        bytes params;\n        uint16 referralCode;\n        uint256 flashLoanPremiumToProtocol;\n        uint256 flashLoanPremiumTotal;\n    }\n\n    struct FlashLoanRepaymentParams {\n        uint256 amount;\n        uint256 totalPremium;\n        uint256 flashLoanPremiumToProtocol;\n        address asset;\n        address receiverAddress;\n        uint16 referralCode;\n    }\n\n    struct CalculateUserAccountDataParams {\n        UserConfigurationMap userConfig;\n        uint256 reservesCount;\n        address user;\n        address oracle;\n        uint8 userEModeCategory;\n    }\n\n    struct ValidateBorrowParams {\n        ReserveCache reserveCache;\n        UserConfigurationMap userConfig;\n        address asset;\n        address userAddress;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        uint256 maxStableLoanPercent;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n        bool isolationModeActive;\n        address isolationModeCollateralAddress;\n        uint256 isolationModeDebtCeiling;\n    }\n\n    struct ValidateLiquidationCallParams {\n        ReserveCache debtReserveCache;\n        uint256 totalDebt;\n        uint256 healthFactor;\n        address priceOracleSentinel;\n    }\n\n    struct CalculateInterestRatesParams {\n        uint256 unbacked;\n        uint256 liquidityAdded;\n        uint256 liquidityTaken;\n        uint256 totalStableDebt;\n        uint256 totalVariableDebt;\n        uint256 averageStableBorrowRate;\n        uint256 reserveFactor;\n        address reserve;\n        address aToken;\n    }\n\n    struct InitReserveParams {\n        address asset;\n        address aTokenAddress;\n        address stableDebtAddress;\n        address variableDebtAddress;\n        address interestRateStrategyAddress;\n        uint16 reservesCount;\n        uint16 maxNumberReserves;\n    }\n}\n"
    },
    "contracts/dloop/core/venue/mock/DLoopCoreMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {DLoopCoreBase} from \"../../DLoopCoreBase.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {BasisPointConstants} from \"contracts/common/BasisPointConstants.sol\";\nimport {PercentageMath} from \"contracts/dlend/core/protocol/libraries/math/PercentageMath.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n/**\n * @title DLoopCoreMock\n * @dev Simple mock implementation of DLoopCoreBase for testing\n */\ncontract DLoopCoreMock is DLoopCoreBase {\n    // Mock state for prices and balances\n    mapping(address => uint256) public mockPrices;\n    mapping(address => mapping(address => uint256)) private mockCollateral; // user => token => amount\n    mapping(address => address[]) private mockCollateralTokens; // user => tokens\n    mapping(address => mapping(address => uint256)) private mockDebt; // user => token => amount\n    mapping(address => address[]) private mockDebtTokens; // user => tokens\n    address public mockPool;\n\n    uint8 public constant PRICE_DECIMALS = 8;\n    uint256 public constant PERCENTAGE_FACTOR = 1e4;\n    uint256 public constant LIQUIDATION_THRESHOLD = 8500; // 85% in basis points\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        ERC20 _collateralToken,\n        ERC20 _debtToken,\n        uint32 _targetLeverageBps,\n        uint32 _lowerBoundTargetLeverageBps,\n        uint32 _upperBoundTargetLeverageBps,\n        uint256 _maxSubsidyBps,\n        address _mockPool\n    )\n        DLoopCoreBase(\n            _name,\n            _symbol,\n            _collateralToken,\n            _debtToken,\n            _targetLeverageBps,\n            _lowerBoundTargetLeverageBps,\n            _upperBoundTargetLeverageBps,\n            _maxSubsidyBps\n        )\n    {\n        mockPool = _mockPool;\n    }\n\n    // Allow setting mock prices for assets\n    function setMockPrice(address asset, uint256 price) external {\n        mockPrices[asset] = price;\n    }\n\n    // Allow setting mock collateral and debt for a user\n    function setMockCollateral(\n        address user,\n        address token,\n        uint256 amount\n    ) external {\n        _setMockCollateral(user, token, amount);\n    }\n    function _setMockCollateral(\n        address user,\n        address token,\n        uint256 amount\n    ) internal {\n        if (mockCollateral[user][token] == 0) {\n            mockCollateralTokens[user].push(token);\n        }\n        mockCollateral[user][token] = amount;\n\n        // If new collateral is less than debt, revert\n        (\n            uint256 totalCollateralInBase,\n            uint256 totalDebtInBase\n        ) = getTotalCollateralAndDebtOfUserInBase(user);\n        if (totalCollateralInBase < totalDebtInBase) {\n            revert(\"Mock: collateral is less than debt\");\n        }\n    }\n\n    function setMockDebt(address user, address token, uint256 amount) external {\n        _setMockDebt(user, token, amount);\n    }\n    function _setMockDebt(\n        address user,\n        address token,\n        uint256 amount\n    ) internal {\n        if (mockDebt[user][token] == 0) {\n            mockDebtTokens[user].push(token);\n        }\n        mockDebt[user][token] = amount;\n\n        // If new debt is greater than collateral, revert\n        (\n            uint256 totalCollateralInBase,\n            uint256 totalDebtInBase\n        ) = getTotalCollateralAndDebtOfUserInBase(user);\n        if (totalCollateralInBase < totalDebtInBase) {\n            revert(\"Mock: collateral is less than debt\");\n        }\n    }\n\n    // --- Overrides ---\n\n    function getRestrictedRescueTokens()\n        public\n        pure\n        override\n        returns (address[] memory)\n    {\n        return new address[](0);\n    }\n\n    function _getAssetPriceFromOracleImplementation(\n        address asset\n    ) internal view override returns (uint256) {\n        uint256 price = mockPrices[asset];\n        require(price > 0, \"Mock price not set\");\n        return price;\n    }\n\n    function _supplyToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        // Mimic: increase collateral for onBehalfOf, transfer token to pool\n\n        if (token == address(debtToken)) {\n            revert(\"Mock: debtToken is not supported as collateral\");\n        }\n\n        _setMockCollateral(\n            onBehalfOf,\n            token,\n            mockCollateral[onBehalfOf][token] + amount\n        );\n        require(\n            ERC20(token).transfer(mockPool, amount),\n            \"Mock: transfer to pool failed\"\n        );\n    }\n\n    function _borrowFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        // Mimic: increase debt for onBehalfOf, transfer token from pool to onBehalfOf\n        _setMockDebt(onBehalfOf, token, mockDebt[onBehalfOf][token] + amount);\n        require(\n            ERC20(token).balanceOf(mockPool) >= amount,\n            \"Mock: not enough tokens in pool to borrow\"\n        );\n        require(\n            ERC20(token).transferFrom(mockPool, onBehalfOf, amount),\n            \"Mock: borrow transfer failed\"\n        );\n    }\n\n    function _repayDebtToPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        // Mimic: decrease debt for onBehalfOf, transfer token from onBehalfOf to pool\n        if (mockDebt[onBehalfOf][token] < amount) {\n            revert(\"Mock: repay exceeds debt\");\n        }\n\n        _setMockDebt(onBehalfOf, token, mockDebt[onBehalfOf][token] - amount);\n        require(\n            ERC20(token).transferFrom(onBehalfOf, mockPool, amount),\n            \"Mock: repay transfer failed\"\n        );\n    }\n\n    function _withdrawFromPoolImplementation(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) internal override {\n        // Mimic: decrease collateral for onBehalfOf, transfer token from pool to onBehalfOf\n\n        if (token == address(debtToken)) {\n            revert(\"Mock: debtToken is not supported as collateral\");\n        }\n        if (mockCollateral[onBehalfOf][token] < amount) {\n            revert(\"Mock: not enough collateral to withdraw\");\n        }\n\n        _setMockCollateral(\n            onBehalfOf,\n            token,\n            mockCollateral[onBehalfOf][token] - amount\n        );\n        require(\n            ERC20(token).balanceOf(mockPool) >= amount,\n            \"Mock: not enough tokens in pool to withdraw\"\n        );\n        require(\n            ERC20(token).transferFrom(mockPool, onBehalfOf, amount),\n            \"Mock: withdraw transfer failed\"\n        );\n    }\n\n    function getTotalCollateralAndDebtOfUserInBase(\n        address user\n    )\n        public\n        view\n        override\n        returns (uint256 totalCollateralBase, uint256 totalDebtBase)\n    {\n        totalCollateralBase = 0;\n        totalDebtBase = 0;\n\n        // Calculate total collateral in base unit (from mockCollateral)\n        // Get all users' tokens from mockCollateral[user]\n        for (uint256 i = 0; i < mockCollateralTokens[user].length; i++) {\n            address token = mockCollateralTokens[user][i];\n\n            // Convert collateral to base unit\n            uint256 price = mockPrices[token];\n            uint256 amount = mockCollateral[user][token];\n            uint256 assetTokenUnit = 10 ** ERC20(token).decimals();\n            uint256 amountInBase = (amount * price) / assetTokenUnit;\n\n            totalCollateralBase += amountInBase;\n        }\n        for (uint256 i = 0; i < mockDebtTokens[user].length; i++) {\n            address token = mockDebtTokens[user][i];\n\n            // Convert debt to base unit\n            uint256 price = mockPrices[token];\n            uint256 amount = mockDebt[user][token];\n            uint256 assetTokenUnit = 10 ** ERC20(token).decimals();\n            uint256 amountInBase = (amount * price) / assetTokenUnit;\n\n            totalDebtBase += amountInBase;\n        }\n        return (totalCollateralBase, totalDebtBase);\n    }\n\n    // --- Test-only public wrappers for internal pool logic ---\n    function testSupplyToPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        require(\n            ERC20(token).transferFrom(onBehalfOf, address(this), amount),\n            \"Mock: transferFrom failed\"\n        );\n        _supplyToPool(token, amount, onBehalfOf);\n    }\n    function testBorrowFromPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        _borrowFromPool(token, amount, onBehalfOf);\n    }\n    function testRepayDebtToPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        _repayDebtToPool(token, amount, onBehalfOf);\n    }\n    function testWithdrawFromPool(\n        address token,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        _withdrawFromPool(token, amount, onBehalfOf);\n    }\n}\n"
    },
    "contracts/dloop/libraries/Erc20Helper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nlibrary Erc20Helper {\n    /**\n     * @dev Checks if a token is an ERC-20\n     * @param token Address of the token\n     * @return bool True if the token is an ERC-20, false otherwise\n     */\n    function isERC20(address token) internal view returns (bool) {\n        try ERC20(token).totalSupply() returns (uint256) {\n            try ERC20(token).balanceOf(address(this)) returns (uint256) {\n                return true;\n            } catch {\n                return false;\n            }\n        } catch {\n            return false;\n        }\n    }\n}\n"
    },
    "contracts/dloop/libraries/RescuableVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\n/**\n * @title RescuableVault\n * @dev A helper contract for rescuing tokens accidentally sent to the contract\n *      - The derived contract must implement the getRestrictedRescueTokens() function\n */\nabstract contract RescuableVault is Ownable, ReentrancyGuard {\n    using SafeERC20 for ERC20;\n\n    /* Virtual Methods - Required to be implemented by derived contracts */\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return address[] Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens()\n        public\n        view\n        virtual\n        returns (address[] memory);\n\n    /* Rescue Functions */\n\n    /**\n     * @dev Rescues tokens accidentally sent to the contract (except for the collateral token and debt token)\n     * @param token Address of the token to rescue\n     * @param receiver Address to receive the rescued tokens\n     * @param amount Amount of tokens to rescue\n     */\n    function rescueToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) public onlyOwner nonReentrant {\n        // The vault does not hold any debt token and collateral token, so it is not necessary to restrict the rescue of debt token and collateral token\n        // We can just rescue any ERC-20 token\n\n        address[] memory restrictedRescueTokens = getRestrictedRescueTokens();\n\n        // Check if the token is restricted\n        for (uint256 i = 0; i < restrictedRescueTokens.length; i++) {\n            if (token == restrictedRescueTokens[i]) {\n                revert(\"Cannot rescue restricted token\");\n            }\n        }\n\n        // Rescue the token\n        ERC20(token).safeTransfer(receiver, amount);\n    }\n}\n"
    },
    "contracts/dloop/libraries/SwappableVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\n/**\n * @title SwappableVault\n * @dev Base contract for swap functions\n *      - Need to implement the _swapExactOutputImplementation function\n *      - The wrapper function _swapExactOutput has some sanity checks\n */\nabstract contract SwappableVault {\n    error SpentInputTokenAmountGreaterThanAmountInMaximum(\n        uint256 spentInputTokenAmount,\n        uint256 amountInMaximum\n    );\n    error ReceivedOutputTokenAmountNotEqualAmountOut(\n        uint256 receivedOutputTokenAmount,\n        uint256 amountOut\n    );\n    error OutputTokenBalanceNotIncreasedAfterSwap(\n        uint256 outputTokenBalanceBefore,\n        uint256 outputTokenBalanceAfter\n    );\n    error SpentInputTokenAmountNotEqualReturnedAmountIn(\n        uint256 spentInputTokenAmount,\n        uint256 returnedAmountIn\n    );\n\n    /* Virtual functions */\n\n    /**\n     * @dev Swaps an exact amount of input assets for as much output assets as possible\n     * @param inputToken Input asset\n     * @param outputToken Output asset\n     * @param amountOut Amount of input assets\n     * @param amountInMaximum Minimum amount of output assets (slippage protection)\n     * @param receiver Address to receive the output assets\n     * @param deadline Deadline for the swap\n     * @param extraData Additional data for the swap\n     * @return amountIn Amount of input assets used for the swap\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory extraData\n    ) internal virtual returns (uint256);\n\n    /* Swap functions */\n\n    /**\n     * @dev A wrapper function for the _swapExactOutputImplementation function\n     *      - Add some sanity checks\n     * @param inputToken Input asset\n     * @param outputToken Output asset\n     * @param amountOut Amount of input assets\n     * @param amountInMaximum Minimum amount of output assets (slippage protection)\n     * @param receiver Address to receive the output assets\n     * @param deadline Deadline for the swap\n     * @param extraData Additional data for the swap\n     * @return amountIn Amount of input assets used for the swap\n     */\n    function _swapExactOutput(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory extraData\n    ) internal returns (uint256) {\n        uint256 inputTokenBalanceBefore = inputToken.balanceOf(address(this));\n        uint256 outputTokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        // Perform the swap\n        uint256 amountIn = _swapExactOutputImplementation(\n            inputToken,\n            outputToken,\n            amountOut,\n            amountInMaximum,\n            receiver,\n            deadline,\n            extraData\n        );\n        uint256 inputTokenBalanceAfter = inputToken.balanceOf(address(this));\n        uint256 outputTokenBalanceAfter = outputToken.balanceOf(address(this));\n\n        // Make sure the spent input token amount is not greater than the amount in maximum\n        if (inputTokenBalanceAfter < inputTokenBalanceBefore) {\n            uint256 spentInputTokenAmount = inputTokenBalanceBefore -\n                inputTokenBalanceAfter;\n            if (spentInputTokenAmount > amountInMaximum) {\n                revert SpentInputTokenAmountGreaterThanAmountInMaximum(\n                    spentInputTokenAmount,\n                    amountInMaximum\n                );\n            }\n            if (spentInputTokenAmount != amountIn) {\n                revert SpentInputTokenAmountNotEqualReturnedAmountIn(\n                    spentInputTokenAmount,\n                    amountIn\n                );\n            }\n        }\n        // Do not need to check the input token balance decreased after the swap\n        // as it is not a risk for the caller\n\n        // Make sure the received output token amount is exactly the amount out\n        if (outputTokenBalanceAfter < outputTokenBalanceBefore) {\n            uint256 receivedOutputTokenAmount = outputTokenBalanceBefore -\n                outputTokenBalanceAfter;\n            if (receivedOutputTokenAmount != amountOut) {\n                revert ReceivedOutputTokenAmountNotEqualAmountOut(\n                    receivedOutputTokenAmount,\n                    amountOut\n                );\n            }\n        } else {\n            revert OutputTokenBalanceNotIncreasedAfterSwap(\n                outputTokenBalanceBefore,\n                outputTokenBalanceAfter\n            );\n        }\n\n        return amountIn;\n    }\n}\n"
    },
    "contracts/dloop/periphery/DLoopDepositorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interface/flashloan/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interface/flashloan/IERC3156FlashLender.sol\";\nimport {DLoopCoreBase} from \"../core/DLoopCoreBase.sol\";\nimport {SwappableVault} from \"../libraries/SwappableVault.sol\";\nimport {RescuableVault} from \"../libraries/RescuableVault.sol\";\n\n/**\n * @title DLoopDepositorBase\n * @dev A helper contract for depositing leveraged assets into the core vault with flash loans\n *      - Suppose that the core contract has leverage of 3x, and the collateral token is WETH, debt token is dUSD, price of WETH is 1000, price of dUSD is 2000\n *      - ie, given user has 100 WETH, and wants to deposit 300 WETH, this contract will do a flash loan to get 200 * 2000 dUSD, then swap to get 200 WETH\n *        and then deposit totally 200+100=300 WETH into the core vault, then user receive 300 shares. The contract uses the received 200 * 2000 dUSD\n *        to repay the flash loan.\n *      - In the final state, the user has 300 shares representing 300 WETH, and the core contract has 300 WETH as collateral, 200 dUSD as debt\n *      - NOTE: This contract only support deposit() to DLoopCore contracts, not mint()\n */\nabstract contract DLoopDepositorBase is\n    IERC3156FlashBorrower,\n    Ownable,\n    SwappableVault,\n    RescuableVault\n{\n    using SafeERC20 for ERC20;\n\n    /* Constants */\n\n    bytes32 public constant FLASHLOAN_CALLBACK =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /* Core state */\n\n    IERC3156FlashLender public immutable flashLender;\n\n    /* Errors */\n\n    error UnknownLender(address msgSender, address flashLender);\n    error UnknownInitiator(address initiator, address thisContract);\n    error IncompatibleDLoopCoreDebtToken(\n        address currentDebtToken,\n        address dLoopCoreDebtToken\n    );\n    error SharesNotIncreasedAfterFlashLoan(\n        uint256 sharesBeforeDeposit,\n        uint256 sharesAfterDeposit\n    );\n    error DebtTokenBalanceNotIncreasedAfterDeposit(\n        uint256 debtTokenBalanceBeforeDeposit,\n        uint256 debtTokenBalanceAfterDeposit\n    );\n    error ReceivedSharesNotMetMinReceiveAmount(\n        uint256 receivedShares,\n        uint256 minOutputShares\n    );\n    error DebtTokenReceivedNotMetUsedAmount(\n        uint256 debtTokenReceived,\n        uint256 debtTokenUsed\n    );\n\n    /* Structs */\n\n    struct FlashLoanParams {\n        address receiver;\n        uint256 depositCollateralAmount;\n        uint256 leveragedCollateralAmount;\n        bytes debtTokenToCollateralSwapData;\n        DLoopCoreBase dLoopCore;\n    }\n\n    /**\n     * @dev Constructor for the DLoopDepositorBase contract\n     * @param _flashLender Address of the flash loan provider\n     */\n    constructor(IERC3156FlashLender _flashLender) Ownable(msg.sender) {\n        flashLender = _flashLender;\n    }\n\n    /* Deposit */\n\n    /**\n     * @dev Deposits assets into the core vault with flash loans\n     *      - The required collateral token to reeach the leveraged amount will be flash loaned from the flash lender\n     * @param assets Amount of assets to deposit\n     * @param receiver Address to receive the minted shares\n     * @param minOutputShares Minimum amount of shares to receive (slippage protection)\n     * @param debtTokenToCollateralSwapData Swap data from debt token to collateral token\n     * @param dLoopCore Address of the DLoopCore contract to use\n     * @return shares Amount of shares minted\n     */\n    function deposit(\n        uint256 assets, // deposit amount\n        address receiver,\n        uint256 minOutputShares,\n        bytes calldata debtTokenToCollateralSwapData,\n        DLoopCoreBase dLoopCore\n    ) public returns (uint256 shares) {\n        // Transfer the collateral token to the vault (need the allowance before calling this function)\n        // The remaining amount of collateral token will be flash loaned from the flash lender\n        // to reach the leveraged amount\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        collateralToken.safeTransferFrom(msg.sender, address(this), assets);\n\n        // Create the flash loan params data\n        FlashLoanParams memory params = FlashLoanParams(\n            receiver,\n            assets,\n            dLoopCore.getLeveragedAssets(assets),\n            debtTokenToCollateralSwapData,\n            dLoopCore\n        );\n        bytes memory data = _encodeParamsToData(params);\n        address debtToken = address(dLoopCore.debtToken());\n        uint256 maxFlashLoanAmount = flashLender.maxFlashLoan(debtToken);\n\n        // This value is used to check if the shares increased after the flash loan\n        uint256 sharesBeforeDeposit = dLoopCore.balanceOf(address(this));\n\n        // Approve the flash lender to spend the flash loan amount of debt token from this contract\n        ERC20(debtToken).forceApprove(\n            address(flashLender),\n            maxFlashLoanAmount +\n                flashLender.flashFee(debtToken, maxFlashLoanAmount)\n        );\n\n        // The main logic will be done in the onFlashLoan function\n        flashLender.flashLoan(this, debtToken, maxFlashLoanAmount, data);\n\n        // Check if the shares increased after the flash loan\n        uint256 sharesAfterDeposit = dLoopCore.balanceOf(address(this));\n        if (sharesAfterDeposit <= sharesBeforeDeposit) {\n            revert SharesNotIncreasedAfterFlashLoan(\n                sharesBeforeDeposit,\n                sharesAfterDeposit\n            );\n        }\n\n        /**\n         * Make sure the shares minted is not less than the minimum output shares\n         * for slippage protection\n         *\n         * We only perform slippage protection outside of the flash loan callback\n         * as we only need to care about the last state after the flash loan\n         */\n        shares = sharesAfterDeposit - sharesBeforeDeposit;\n        if (shares < minOutputShares) {\n            revert ReceivedSharesNotMetMinReceiveAmount(\n                shares,\n                minOutputShares\n            );\n        }\n\n        // Transfer the minted shares to the receiver\n        SafeERC20.safeTransferFrom(dLoopCore, address(this), receiver, shares);\n\n        // Return the shares minted\n        return shares;\n    }\n\n    /* Flash loan entrypoint */\n\n    /**\n     * @dev Callback function for flash loans\n     * @param initiator Address that initiated the flash loan\n     * @param token Address of the flash-borrowed token\n     * @param data Additional data passed to the flash loan\n     * @return bytes32 The flash loan callback success bytes\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256, // amount (flash loan amount)\n        uint256, // fee (flash loan fee)\n        bytes calldata data\n    ) external override returns (bytes32) {\n        if (msg.sender != address(flashLender))\n            revert UnknownLender(msg.sender, address(flashLender));\n        if (initiator != address(this))\n            revert UnknownInitiator(initiator, address(this));\n\n        // Decode the flash loan params data\n        FlashLoanParams memory flashLoanParams = _decodeDataToParams(data);\n        DLoopCoreBase dLoopCore = flashLoanParams.dLoopCore;\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n\n        // Make sure the input dLoopCore is compatible with this periphery contract\n        if (token != address(debtToken))\n            revert IncompatibleDLoopCoreDebtToken(token, address(debtToken));\n\n        // Calculate the maxDebtInputAmount for slippage protection\n        uint256 requiredAdditionalCollateralAmount = flashLoanParams\n            .leveragedCollateralAmount -\n            flashLoanParams.depositCollateralAmount;\n\n        // Swap the flash loan debt token to the collateral token\n        uint256 debtTokenAmountUsedInSwap = _swapExactOutput(\n            debtToken,\n            collateralToken,\n            requiredAdditionalCollateralAmount, // exact output amount\n            type(uint256).max, // no slippage protection\n            address(this),\n            block.timestamp,\n            flashLoanParams.debtTokenToCollateralSwapData\n        );\n\n        // This value is used to check if the debt token balance increased after the deposit\n        uint256 debtTokenBalanceBeforeDeposit = debtToken.balanceOf(\n            address(this)\n        );\n\n        /**\n         * Deposit the collateral token to the core vault\n         *\n         * The receiver is this periphery contract as the core contract will send both debt token and\n         * the minted shares to the receiver. This contract needs the debt token to repay the flash loan.\n         *\n         * The minted shares will be sent to the receiver later (outside of the flash loan callback)\n         */\n        collateralToken.forceApprove(\n            address(dLoopCore),\n            flashLoanParams.leveragedCollateralAmount\n        );\n        dLoopCore.deposit(\n            flashLoanParams.leveragedCollateralAmount,\n            address(this)\n        );\n\n        // Debt token balance after deposit, which is used to sanity check the debt token balance increased after the deposit\n        uint256 debtTokenBalanceAfterDeposit = debtToken.balanceOf(\n            address(this)\n        );\n\n        // Make sure to receive the debt token from the core vault to repay the flash loan\n        if (debtTokenBalanceAfterDeposit <= debtTokenBalanceBeforeDeposit) {\n            revert DebtTokenBalanceNotIncreasedAfterDeposit(\n                debtTokenBalanceBeforeDeposit,\n                debtTokenBalanceAfterDeposit\n            );\n        }\n\n        // Calculate the debt token received after the deposit\n        uint256 debtTokenReceivedAfterDeposit = debtTokenBalanceAfterDeposit -\n            debtTokenBalanceBeforeDeposit;\n\n        // Make sure the debt token received after the deposit is not less than the debt token used in the swap\n        // to allow repaying the flash loan\n        if (debtTokenReceivedAfterDeposit < debtTokenAmountUsedInSwap) {\n            revert DebtTokenReceivedNotMetUsedAmount(\n                debtTokenReceivedAfterDeposit,\n                debtTokenAmountUsedInSwap\n            );\n        }\n\n        // Return the success bytes\n        return FLASHLOAN_CALLBACK;\n    }\n\n    /**\n     * @dev Encodes flash loan parameters to data\n     * @param _flashLoanParams Flash loan parameters\n     * @return data Encoded data\n     */\n    function _encodeParamsToData(\n        FlashLoanParams memory _flashLoanParams\n    ) internal pure returns (bytes memory data) {\n        data = abi.encode(\n            _flashLoanParams.receiver,\n            _flashLoanParams.depositCollateralAmount,\n            _flashLoanParams.leveragedCollateralAmount,\n            _flashLoanParams.debtTokenToCollateralSwapData,\n            _flashLoanParams.dLoopCore\n        );\n    }\n\n    /**\n     * @dev Decodes data to flash loan deposit parameters\n     * @param data Encoded data\n     * @return _flashLoanParams Decoded flash loan parameters\n     */\n    function _decodeDataToParams(\n        bytes memory data\n    ) internal pure returns (FlashLoanParams memory _flashLoanParams) {\n        (\n            _flashLoanParams.receiver,\n            _flashLoanParams.depositCollateralAmount,\n            _flashLoanParams.leveragedCollateralAmount,\n            _flashLoanParams.debtTokenToCollateralSwapData,\n            _flashLoanParams.dLoopCore\n        ) = abi.decode(data, (address, uint256, uint256, bytes, DLoopCoreBase));\n    }\n}\n"
    },
    "contracts/dloop/periphery/DLoopRedeemerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {BasisPointConstants} from \"contracts/common/BasisPointConstants.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interface/flashloan/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interface/flashloan/IERC3156FlashLender.sol\";\nimport {DLoopCoreBase} from \"../core/DLoopCoreBase.sol\";\nimport {SwappableVault} from \"../libraries/SwappableVault.sol\";\nimport {RescuableVault} from \"../libraries/RescuableVault.sol\";\n\n/**\n * @title DLoopRedeemerBase\n * @dev A helper contract for withdrawing assets from the core vault with flash loans\n *      - Suppose that the core contract has leverage of 3x, and the collateral token is WETH, debt token is dUSD, price of WETH is 1000, price of dUSD is 2000\n *      - ie, given user has 300 shares representing 300 WETH, and wants to withdraw 300 WETH, this contract will do a flash loan to get 200 * 2000 dUSD\n *        to repay the debt in the core vault, then withdraw 300 WETH from the core vault. The contract will swap 200 WETH to 200 * 2000 dUSD to repay the flash loan.\n *      - In the final state, the user has 100 WETH (300 - 200), and the core contract has 0 WETH as collateral, 0 dUSD as debt\n *      - NOTE: This contract only support redeem() from DLoopCore contracts, not withdraw()\n */\nabstract contract DLoopRedeemerBase is\n    IERC3156FlashBorrower,\n    Ownable,\n    SwappableVault,\n    RescuableVault\n{\n    using SafeERC20 for ERC20;\n\n    /* Constants */\n\n    bytes32 public constant FLASHLOAN_CALLBACK =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /* Core state */\n\n    IERC3156FlashLender public immutable flashLender;\n\n    /* Errors */\n\n    error UnknownLender(address msgSender, address flashLender);\n    error UnknownInitiator(address initiator, address thisContract);\n    error IncompatibleDLoopCoreDebtToken(\n        address currentDebtToken,\n        address dLoopCoreDebtToken\n    );\n    error SharesNotDecreasedAfterFlashLoan(\n        uint256 sharesBeforeWithdraw,\n        uint256 sharesAfterWithdraw\n    );\n    error InsufficientOutput(uint256 received, uint256 expected);\n    error UnexpectedIncreaseInDebtToken(\n        uint256 debtTokenBalanceBefore,\n        uint256 debtTokenBalanceAfter\n    );\n    error UnexpectedDecreaseInCollateralToken(\n        uint256 collateralTokenBalanceBefore,\n        uint256 collateralTokenBalanceAfter\n    );\n    error UnexpectedDecreaseInCollateralTokenAfterFlashLoan(\n        uint256 collateralTokenBalanceBefore,\n        uint256 collateralTokenBalanceAfter\n    );\n    error IncorrectSharesBurned(uint256 expected, uint256 actual);\n    error WithdrawnCollateralTokenAmountNotMetMinReceiveAmount(\n        uint256 withdrawnCollateralTokenAmount,\n        uint256 minReceiveCollateralTokenAmount\n    );\n\n    /* Structs */\n\n    struct FlashLoanParams {\n        address owner;\n        address receiver;\n        uint256 shares;\n        uint256 collateralToRemoveFromLending;\n        bytes collateralToDebtTokenSwapData;\n        DLoopCoreBase dLoopCore;\n    }\n\n    /**\n     * @dev Constructor for the DLoopRedeemerBase contract\n     * @param _flashLender Address of the flash loan provider\n     */\n    constructor(IERC3156FlashLender _flashLender) Ownable(msg.sender) {\n        flashLender = _flashLender;\n    }\n\n    /* Withdraw */\n\n    /**\n     * @dev Redeems shares from the core vault with flash loans\n     *      - The required debt token to withdraw will be flash loaned from the flash lender\n     * @param shares Amount of shares to redeem\n     * @param receiver Address to receive the assets\n     * @param minOutputCollateralAmount Minimum amount of collateral token to receive (slippage protection)\n     * @param collateralToDebtTokenSwapData Swap data from collateral token to debt token\n     * @param dLoopCore Address of the DLoopCore contract to use\n     * @return assets Amount of assets redeemed\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        uint256 minOutputCollateralAmount,\n        bytes calldata collateralToDebtTokenSwapData,\n        DLoopCoreBase dLoopCore\n    ) public returns (uint256 assets) {\n        // We assume the owner is always the msg.sender, means you cannot redeem shares on behalf of others\n        address owner = msg.sender;\n\n        // Transfer the shares to the periphery contract to prepare for the redeeming process\n        SafeERC20.safeTransferFrom(dLoopCore, owner, address(this), shares);\n\n        // Do not need to transfer the debt token to repay the lending pool, as it will be done with flash loan\n\n        // This amount is representing the leveraged amount\n        uint256 collateralToRemoveFromLending = dLoopCore.convertToAssets(\n            shares\n        );\n\n        // Create the flash loan params data\n        FlashLoanParams memory params = FlashLoanParams(\n            owner,\n            receiver,\n            shares,\n            collateralToRemoveFromLending,\n            collateralToDebtTokenSwapData,\n            dLoopCore\n        );\n        bytes memory data = _encodeParamsToData(params);\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n        uint256 maxFlashLoanAmount = flashLender.maxFlashLoan(\n            address(debtToken)\n        );\n\n        // This value is used to calculate the shares burned after the flash loan\n        uint256 sharesBeforeRedeem = dLoopCore.balanceOf(owner);\n\n        // This value is used to calculate the received collateral token amount after the flash loan\n        uint256 collateralTokenBalanceBefore = collateralToken.balanceOf(\n            address(this)\n        );\n\n        // Approve the flash lender to spend the flash loan amount of debt token from this contract\n        debtToken.forceApprove(\n            address(flashLender),\n            maxFlashLoanAmount +\n                flashLender.flashFee(address(debtToken), maxFlashLoanAmount)\n        );\n\n        // The main logic will be done in the onFlashLoan function\n        flashLender.flashLoan(\n            this,\n            address(debtToken),\n            maxFlashLoanAmount,\n            data\n        );\n\n        // Check if the shares decreased after the flash loan\n        uint256 sharesAfterRedeem = dLoopCore.balanceOf(owner);\n        if (sharesAfterRedeem >= sharesBeforeRedeem) {\n            revert SharesNotDecreasedAfterFlashLoan(\n                sharesBeforeRedeem,\n                sharesAfterRedeem\n            );\n        }\n\n        // Make sure the burned shares is exactly the shares amount\n        uint256 actualBurnedShares = sharesBeforeRedeem - sharesAfterRedeem;\n        if (actualBurnedShares != shares) {\n            revert IncorrectSharesBurned(shares, actualBurnedShares);\n        }\n\n        // Collateral balance after the flash loan\n        uint256 collateralTokenBalanceAfter = collateralToken.balanceOf(\n            address(this)\n        );\n\n        // Calculate the received collateral token amount after the flash loan\n        if (collateralTokenBalanceAfter <= collateralTokenBalanceBefore) {\n            revert UnexpectedDecreaseInCollateralTokenAfterFlashLoan(\n                collateralTokenBalanceBefore,\n                collateralTokenBalanceAfter\n            );\n        }\n\n        // Make sure the received collateral token amount is not less than the minimum output collateral amount\n        // for slippage protection\n        uint256 receivedCollateralTokenAmount = collateralTokenBalanceAfter -\n            collateralTokenBalanceBefore;\n        if (receivedCollateralTokenAmount < minOutputCollateralAmount) {\n            revert WithdrawnCollateralTokenAmountNotMetMinReceiveAmount(\n                receivedCollateralTokenAmount,\n                minOutputCollateralAmount\n            );\n        }\n\n        // Transfer the received collateral token to the receiver\n        collateralToken.safeTransfer(receiver, receivedCollateralTokenAmount);\n\n        // Return the received collateral token amount\n        return receivedCollateralTokenAmount;\n    }\n\n    /* Flash loan entrypoint */\n\n    /**\n     * @dev Callback function for flash loans\n     * @param initiator Address that initiated the flash loan\n     * @param token Address of the flash-borrowed token\n     * @param data Encoded flash loan parameters\n     * @return bytes32 The flash loan callback success bytes\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256, // amount (flash loan amount)\n        uint256, // fee (flash loan fee)\n        bytes calldata data\n    ) external override returns (bytes32) {\n        if (msg.sender != address(flashLender))\n            revert UnknownLender(msg.sender, address(flashLender));\n        if (initiator != address(this))\n            revert UnknownInitiator(initiator, address(this));\n\n        // Decode the flash loan params data\n        FlashLoanParams memory flashLoanParams = _decodeDataToParams(data);\n        DLoopCoreBase dLoopCore = flashLoanParams.dLoopCore;\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n\n        // Make sure the input dLoopCore is compatible with this periphery contract\n        if (token != address(debtToken))\n            revert IncompatibleDLoopCoreDebtToken(token, address(debtToken));\n\n        // This value is used to calculate the debt token was used from the flash loan\n        uint256 debtTokenBalanceBefore = debtToken.balanceOf(address(this));\n\n        /**\n         * Redeem the shares to get the collateral token\n         * The core vault will also take the debt token from the periphery contract\n         * to repay the debt and then withdraw the collateral token\n         *\n         * The receiver is this periphery contract as it needs to use the collateral token\n         * to swap to the debt token to repay the flash loan\n         *\n         * The owner is the owner of the shares as it needs to burn the shares\n         */\n        debtToken.forceApprove(\n            address(dLoopCore),\n            type(uint256).max // No slippage tolerance\n        );\n        dLoopCore.redeem(\n            flashLoanParams.shares,\n            address(this), // receiver\n            flashLoanParams.owner // owner\n        );\n        // Approve back to 0 to avoid any potential exploits later\n        debtToken.forceApprove(address(dLoopCore), 0);\n\n        // Calculate the debt token was used from the flash loan\n        uint256 debtTokenBalanceAfter = debtToken.balanceOf(address(this));\n        if (debtTokenBalanceAfter > debtTokenBalanceBefore) {\n            revert UnexpectedIncreaseInDebtToken(\n                debtTokenBalanceBefore,\n                debtTokenBalanceAfter\n            );\n        }\n        uint256 debtTokenUsed = debtTokenBalanceBefore - debtTokenBalanceAfter;\n\n        // Swap the collateral token to the debt token to repay the flash loan\n        _swapExactOutput(\n            collateralToken,\n            debtToken,\n            debtTokenUsed,\n            type(uint256).max, // No slippage tolerance\n            address(this),\n            block.timestamp,\n            flashLoanParams.collateralToDebtTokenSwapData\n        );\n\n        // Return the success bytes\n        return FLASHLOAN_CALLBACK;\n    }\n\n    /**\n     * @dev Encodes flash loan parameters to data\n     * @param _flashLoanParams Flash loan parameters\n     * @return data Encoded data\n     */\n    function _encodeParamsToData(\n        FlashLoanParams memory _flashLoanParams\n    ) internal pure returns (bytes memory data) {\n        data = abi.encode(\n            _flashLoanParams.owner,\n            _flashLoanParams.receiver,\n            _flashLoanParams.shares,\n            _flashLoanParams.collateralToRemoveFromLending,\n            _flashLoanParams.collateralToDebtTokenSwapData,\n            _flashLoanParams.dLoopCore\n        );\n    }\n\n    /**\n     * @dev Decodes data to flash loan withdraw parameters\n     * @param data Encoded data\n     * @return _flashLoanParams Decoded flash loan parameters\n     */\n    function _decodeDataToParams(\n        bytes memory data\n    ) internal pure returns (FlashLoanParams memory _flashLoanParams) {\n        (\n            _flashLoanParams.owner,\n            _flashLoanParams.receiver,\n            _flashLoanParams.shares,\n            _flashLoanParams.collateralToRemoveFromLending,\n            _flashLoanParams.collateralToDebtTokenSwapData,\n            _flashLoanParams.dLoopCore\n        ) = abi.decode(\n            data,\n            (address, address, uint256, uint256, bytes, DLoopCoreBase)\n        );\n    }\n}\n"
    },
    "contracts/dloop/periphery/interface/flashloan/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\n\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/dloop/periphery/interface/flashloan/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(\n        address token,\n        uint256 amount\n    ) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "contracts/dloop/periphery/libraries/SwapHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {BasisPointConstants} from \"contracts/common/BasisPointConstants.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\ninterface PriceGetter {\n    function getAssetPriceFromOracle(\n        address asset\n    ) external view returns (uint256);\n}\n\nlibrary SwapHelper {\n    error SlippageToleranceCannotExceedOneHundredPercent(\n        uint256 slippageTolerance\n    );\n\n    /**\n     * @notice Estimates the input amount from an exact output amount\n     * @param inputToken The input token\n     * @param outputToken The output token\n     * @param outputAmount The output amount\n     * @param slippageTolerance The slippage tolerance\n     * @param priceGetter The price getter\n     * @return maxDebtInputAmount The max input amount\n     */\n    function estimateInputAmountFromExactOutputAmount(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 outputAmount,\n        uint256 slippageTolerance,\n        PriceGetter priceGetter\n    ) internal view returns (uint256) {\n        // Calculate the estimated input amount from the given output amount\n        uint256 estimatedInputAmount = (outputAmount *\n            (priceGetter.getAssetPriceFromOracle(address(outputToken)) *\n                (10 ** inputToken.decimals()))) /\n            (priceGetter.getAssetPriceFromOracle(address(inputToken)) *\n                (10 ** outputToken.decimals()));\n        // Calculate the max input amount with slippage tolerance\n        uint256 maxInputAmount = (estimatedInputAmount *\n            (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS + slippageTolerance)) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n        return maxInputAmount;\n    }\n\n    /**\n     * @notice Get the max input amount with slippage tolerance\n     * @param amount The amount\n     * @param slippageTolerance The slippage tolerance\n     * @return maxInputAmount The max input amount\n     */\n    function getMaxInputAmountWithSlippageTolerance(\n        uint256 amount,\n        uint256 slippageTolerance\n    ) internal pure returns (uint256) {\n        return\n            (amount *\n                (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS +\n                    slippageTolerance)) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n    }\n\n    /**\n     * @notice Get the min output amount with slippage tolerance\n     * @param amount The amount\n     * @param slippageTolerance The slippage tolerance\n     * @return minOutputAmount The min output amount\n     */\n    function getMinOutputAmountWithSlippageTolerance(\n        uint256 amount,\n        uint256 slippageTolerance\n    ) internal pure returns (uint256) {\n        if (slippageTolerance >= BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert SlippageToleranceCannotExceedOneHundredPercent(\n                slippageTolerance\n            );\n        }\n\n        return\n            (amount *\n                (BasisPointConstants.ONE_HUNDRED_PERCENT_BPS -\n                    slippageTolerance)) /\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n    }\n}\n"
    },
    "contracts/dloop/periphery/venue/odos/DLoopDepositorOdos.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\n\nimport {DLoopDepositorBase, ERC20, IERC3156FlashLender} from \"../../DLoopDepositorBase.sol\";\nimport {OdosSwapLogic, IOdosRouterV2} from \"./OdosSwapLogic.sol\";\n\n/**\n * @title DLoopDepositorOdos\n * @dev Implementation of DLoopDepositorBase with Odos swap functionality\n */\ncontract DLoopDepositorOdos is DLoopDepositorBase {\n    IOdosRouterV2 public immutable odosRouter;\n\n    /**\n     * @dev Constructor for the DLoopDepositorOdos contract\n     * @param _flashLender Address of the flash loan provider\n     * @param _odosRouter Address of the Odos router\n     */\n    constructor(\n        IERC3156FlashLender _flashLender,\n        IOdosRouterV2 _odosRouter\n    ) DLoopDepositorBase(_flashLender) {\n        odosRouter = _odosRouter;\n    }\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return address[] Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens()\n        public\n        pure\n        override\n        returns (address[] memory)\n    {\n        // Return empty array as there is no restricted rescue token\n        return new address[](0);\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for the minimum input tokens using Odos\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory dStableToUnderlyingSwapData\n    ) internal override returns (uint256) {\n        return\n            OdosSwapLogic.swapExactOutput(\n                inputToken,\n                outputToken,\n                amountOut,\n                amountInMaximum,\n                receiver,\n                deadline,\n                dStableToUnderlyingSwapData,\n                odosRouter\n            );\n    }\n}\n"
    },
    "contracts/dloop/periphery/venue/odos/DLoopRedeemerOdos.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\n\nimport {DLoopRedeemerBase, ERC20, IERC3156FlashLender} from \"../../DLoopRedeemerBase.sol\";\nimport {OdosSwapLogic, IOdosRouterV2} from \"./OdosSwapLogic.sol\";\n\n/**\n * @title DLoopRedeemerOdos\n * @dev Implementation of DLoopRedeemerBase with Odos swap functionality\n */\ncontract DLoopRedeemerOdos is DLoopRedeemerBase {\n    IOdosRouterV2 public immutable odosRouter;\n\n    /**\n     * @dev Constructor for the DLoopRedeemerOdos contract\n     * @param _flashLender Address of the flash loan provider\n     * @param _odosRouter Address of the Odos router\n     */\n    constructor(\n        IERC3156FlashLender _flashLender,\n        IOdosRouterV2 _odosRouter\n    ) DLoopRedeemerBase(_flashLender) {\n        odosRouter = _odosRouter;\n    }\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return address[] Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens()\n        public\n        pure\n        override\n        returns (address[] memory)\n    {\n        // Return empty array as there is no restricted rescue token\n        return new address[](0);\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for the minimum input tokens using Odos\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory underlyingToDStableSwapData\n    ) internal override returns (uint256) {\n        return\n            OdosSwapLogic.swapExactOutput(\n                inputToken,\n                outputToken,\n                amountOut,\n                amountInMaximum,\n                receiver,\n                deadline,\n                underlyingToDStableSwapData,\n                odosRouter\n            );\n    }\n}\n"
    },
    "contracts/dloop/periphery/venue/odos/OdosSwapLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity 0.8.20;\n\nimport {ERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {IOdosRouterV2} from \"contracts/odos/interface/IOdosRouterV2.sol\";\nimport {OdosSwapUtils} from \"contracts/odos/OdosSwapUtils.sol\";\n\n/**\n * @title OdosSwapLogic\n * @dev Library for common Odos swap functions used in dLOOP contracts\n */\nlibrary OdosSwapLogic {\n    using SafeERC20 for ERC20;\n\n    /**\n     * @dev Swaps an exact amount of output tokens for input tokens using Odos router\n     * @param inputToken Input token to be swapped\n     * @param outputToken Output token to receive (used for validating the swap direction)\n     * @param amountOut Exact amount of output tokens to receive\n     * @param amountInMaximum Maximum amount of input tokens to spend\n     * @param receiver Address to receive the output tokens (not used directly in Odos, but kept for interface consistency)\n     * @param swapData Encoded swap data for Odos router\n     * @param odosRouter Odos router instance\n     * @return uint256 Amount of input tokens used\n     */\n    function swapExactOutput(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256, // deadline, not used in Odos\n        bytes memory swapData,\n        IOdosRouterV2 odosRouter\n    ) external returns (uint256) {\n        // Use the OdosSwapUtils library to execute the swap\n        uint256 actualAmountOut = OdosSwapUtils.excuteSwapOperation(\n            odosRouter,\n            address(inputToken),\n            amountInMaximum,\n            amountOut,\n            swapData\n        );\n\n        // If we received more than requested, transfer the surplus to the receiver\n        if (actualAmountOut > amountOut && receiver != address(this)) {\n            uint256 surplus = actualAmountOut - amountOut;\n            ERC20(outputToken).safeTransfer(receiver, surplus);\n        }\n\n        // Return the actual output amount\n        return actualAmountOut;\n    }\n}\n"
    },
    "contracts/odos/interface/IOdosRouterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\n/**\n * @dev Interface for Odos Router V2.\n * @dev Generated from original ABI: https://fraxscan.com/address/0x56c85a254dd12ee8d9c04049a4ab62769ce98210#code\n */\npragma solidity ^0.8.20;\n\ninterface IOdosRouterV2 {\n    struct swapTokenInfo {\n        address inputToken;\n        uint256 inputAmount;\n        address inputReceiver;\n        address outputToken;\n        uint256 outputQuote;\n        uint256 outputMin;\n        address outputReceiver;\n    }\n\n    struct inputTokenInfo {\n        address tokenAddress;\n        uint256 amountIn;\n        address receiver;\n    }\n\n    struct outputTokenInfo {\n        address tokenAddress;\n        uint256 relativeValue;\n        address receiver;\n    }\n\n    struct permit2Info {\n        address contractAddress;\n        uint256 nonce;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    event Swap(\n        address sender,\n        uint256 inputAmount,\n        address inputToken,\n        uint256 amountOut,\n        address outputToken,\n        int256 slippage,\n        uint32 referralCode\n    );\n\n    event SwapMulti(\n        address sender,\n        uint256[] amountsIn,\n        address[] tokensIn,\n        uint256[] amountsOut,\n        address[] tokensOut,\n        uint32 referralCode\n    );\n\n    function FEE_DENOM() external view returns (uint256);\n\n    function REFERRAL_WITH_FEE_THRESHOLD() external view returns (uint256);\n\n    function addressList(uint256) external view returns (address);\n\n    function owner() external view returns (address);\n\n    function referralLookup(\n        uint32\n    )\n        external\n        view\n        returns (uint64 referralFee, address beneficiary, bool registered);\n\n    function registerReferralCode(\n        uint32 _referralCode,\n        uint64 _referralFee,\n        address _beneficiary\n    ) external;\n\n    function renounceOwnership() external;\n\n    function setSwapMultiFee(uint256 _swapMultiFee) external;\n\n    function swap(\n        swapTokenInfo calldata tokenInfo,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external payable returns (uint256 amountOut);\n\n    function swapCompact() external payable returns (uint256);\n\n    function swapMulti(\n        inputTokenInfo[] calldata inputs,\n        outputTokenInfo[] calldata outputs,\n        uint256 valueOutMin,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external payable returns (uint256[] memory amountsOut);\n\n    function swapMultiCompact()\n        external\n        payable\n        returns (uint256[] memory amountsOut);\n\n    function swapMultiFee() external view returns (uint256);\n\n    function swapMultiPermit2(\n        permit2Info calldata permit2,\n        inputTokenInfo[] calldata inputs,\n        outputTokenInfo[] calldata outputs,\n        uint256 valueOutMin,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external payable returns (uint256[] memory amountsOut);\n\n    function swapPermit2(\n        permit2Info calldata permit2,\n        swapTokenInfo calldata tokenInfo,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external returns (uint256 amountOut);\n\n    function swapRouterFunds(\n        inputTokenInfo[] calldata inputs,\n        outputTokenInfo[] calldata outputs,\n        uint256 valueOutMin,\n        bytes calldata pathDefinition,\n        address executor\n    ) external returns (uint256[] memory amountsOut);\n\n    function transferOwnership(address newOwner) external;\n\n    function transferRouterFunds(\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        address dest\n    ) external;\n\n    function writeAddressList(address[] calldata addresses) external;\n\n    receive() external payable;\n}\n"
    },
    "contracts/odos/OdosSwapUtils.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.20;\n\nimport \"./interface/IOdosRouterV2.sol\";\nimport \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/**\n * @title OdosSwapUtils\n * @notice Library for handling Odos swaps in liquidator contracts\n */\nlibrary OdosSwapUtils {\n    using SafeTransferLib for ERC20;\n\n    /// @notice Custom error for failed swap with no revert reason\n    error SwapFailed();\n    /// @notice Custom error when actual output amount is less than expected\n    error InsufficientOutput(uint256 expected, uint256 actual);\n\n    /**\n     * @notice Performs an swap operation using Odos router with swap data\n     * @param router Odos router contract\n     * @param inputToken Input token\n     * @param maxIn Maximum input amount\n     * @param exactOut Exact output amount\n     * @param swapData Encoded swap path data\n     */\n    function excuteSwapOperation(\n        IOdosRouterV2 router,\n        address inputToken,\n        uint256 maxIn,\n        uint256 exactOut,\n        bytes memory swapData\n    ) internal returns (uint256) {\n        ERC20(inputToken).approve(address(router), maxIn);\n\n        (bool success, bytes memory result) = address(router).call(swapData);\n        if (!success) {\n            // Decode the revert reason if present\n            if (result.length > 0) {\n                // First try to decode the standard revert reason\n                assembly {\n                    let resultLength := mload(result)\n                    revert(add(32, result), resultLength)\n                }\n            }\n            revert SwapFailed();\n        }\n\n        uint256 actualAmountOut;\n        assembly {\n            actualAmountOut := mload(add(result, 32))\n        }\n\n        if (actualAmountOut < exactOut) {\n            revert InsufficientOutput(exactOut, actualAmountOut);\n        }\n\n        return actualAmountOut;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}