{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC4626.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";\nimport {SafeERC20} from \"../utils/SafeERC20.sol\";\nimport {IERC4626} from \"../../../interfaces/IERC4626.sol\";\nimport {Math} from \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC-4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC-20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC-20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation introduces configurable virtual assets and shares to help developers mitigate that risk.\n * The `_decimalsOffset()` corresponds to an offset in the decimal representation between the underlying asset's decimals\n * and the vault decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which\n * itself determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default\n * offset (0) makes it non-profitable even if an attacker is able to capture value from multiple user deposits, as a result\n * of the value being captured by the virtual shares (out of the attacker's donation) matching the attacker's expected gains.\n * With a larger offset, the attack becomes orders of magnitude more expensive than it is profitable. More details about the\n * underlying math can be found xref:ROOT:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _underlyingDecimals;\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC-20 or ERC-777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _underlyingDecimals + _decimalsOffset();\n    }\n\n    /// @inheritdoc IERC4626\n    function asset() public view virtual returns (address) {\n        return address(_asset);\n    }\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view virtual returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If asset() is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(IERC20(asset()), caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(IERC20(asset()), receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/common/BasisPointConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nlibrary BasisPointConstants {\n    // Shared definitions of how we represent percentages and basis points\n    uint16 public constant ONE_BPS = 100; // 1 basis point with 2 decimals\n    uint32 public constant ONE_PERCENT_BPS = ONE_BPS * 100;\n    uint32 public constant ONE_HUNDRED_PERCENT_BPS = ONE_PERCENT_BPS * 100;\n}\n"
    },
    "contracts/common/Compare.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nlibrary Compare {\n    /**\n     * @dev Returns true if observed and expected differ by no more than the tolerance (absolute comparison).\n     *      This is useful for allowing small rounding differences (e.g., 1 wei) in balance deltas.\n     * @param observed The observed value (e.g., balance delta actually seen)\n     * @param expected The expected value\n     * @param tolerance The allowed absolute difference between observed and expected\n     */\n    function isWithinTolerance(uint256 observed, uint256 expected, uint256 tolerance) internal pure returns (bool) {\n        if (observed > expected) {\n            return observed - expected <= tolerance;\n        }\n        return expected - observed <= tolerance;\n    }\n\n    /**\n     * @dev Direction of expected balance change between two observations\n     */\n    enum BalanceDirection {\n        Increase,\n        Decrease\n    }\n\n    struct BalanceCheckResult {\n        bool directionOk;\n        uint256 observedDelta;\n        bool toleranceOk;\n    }\n\n    /**\n     * @dev Checks a balance change from before to after against an expected delta and tolerance.\n     *      This helper allows callers to keep custom error types local while sharing the core logic.\n     * @param beforeBalance The balance before the operation\n     * @param afterBalance The balance after the operation\n     * @param expectedDelta The expected absolute change amount\n     * @param tolerance The allowed absolute difference between observed and expected\n     * @param direction The expected direction of change (Increase or Decrease)\n     * @return result Struct containing: directionOk, observedDelta, toleranceOk\n     */\n    function checkBalanceDelta(\n        uint256 beforeBalance,\n        uint256 afterBalance,\n        uint256 expectedDelta,\n        uint256 tolerance,\n        BalanceDirection direction\n    ) internal pure returns (BalanceCheckResult memory result) {\n        if (direction == BalanceDirection.Increase) {\n            result.directionOk = afterBalance > beforeBalance;\n            if (result.directionOk) {\n                result.observedDelta = afterBalance - beforeBalance;\n            }\n        } else {\n            result.directionOk = afterBalance < beforeBalance;\n            if (result.directionOk) {\n                result.observedDelta = beforeBalance - afterBalance;\n            }\n        }\n\n        if (!result.directionOk) {\n            // Short-circuit: when direction is not satisfied, tolerance check is irrelevant\n            result.toleranceOk = false;\n            return result;\n        }\n\n        result.toleranceOk = isWithinTolerance(result.observedDelta, expectedDelta, tolerance);\n        return result;\n    }\n}\n"
    },
    "contracts/common/Erc20Helper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nlibrary Erc20Helper {\n    /**\n     * @dev Checks if a token is an ERC-20\n     * @param token Address of the token\n     * @return bool True if the token is an ERC-20, false otherwise\n     */\n    function isERC20(address token) internal view returns (bool) {\n        try ERC20(token).totalSupply() returns (uint256) {\n            try ERC20(token).balanceOf(address(this)) returns (uint256) {\n                return true;\n            } catch {\n                return false;\n            }\n        } catch {\n            return false;\n        }\n    }\n}\n"
    },
    "contracts/common/RescuableVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\n/**\n * @title RescuableVault\n * @dev A helper contract for rescuing tokens accidentally sent to the contract\n *      - The derived contract must implement the getRestrictedRescueTokens() function\n */\nabstract contract RescuableVault is Ownable, ReentrancyGuard {\n    using SafeERC20 for ERC20;\n\n    /* Virtual Methods - Required to be implemented by derived contracts */\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return address[] Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens() public view virtual returns (address[] memory);\n\n    /* Rescue Functions */\n\n    /**\n     * @dev Rescues tokens accidentally sent to the contract (except for the collateral token and debt token)\n     * @param token Address of the token to rescue\n     * @param receiver Address to receive the rescued tokens\n     * @param amount Amount of tokens to rescue\n     */\n    function rescueToken(address token, address receiver, uint256 amount) public onlyOwner nonReentrant {\n        // The vault does not hold any debt token and collateral token, so it is not necessary to restrict the rescue of debt token and collateral token\n        // We can just rescue any ERC-20 token\n\n        address[] memory restrictedRescueTokens = getRestrictedRescueTokens();\n\n        // Check if the token is restricted\n        for (uint256 i = 0; i < restrictedRescueTokens.length; i++) {\n            if (token == restrictedRescueTokens[i]) {\n                revert(\"Cannot rescue restricted token\");\n            }\n        }\n\n        // Rescue the token\n        ERC20(token).safeTransfer(receiver, amount);\n    }\n}\n"
    },
    "contracts/common/SwappableVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { Compare } from \"contracts/common/Compare.sol\";\n\n/**\n * @title SwappableVault\n * @dev Base contract for swap functions\n *      - Need to implement the _swapExactOutputImplementation function\n *      - The wrapper function _swapExactOutput has some sanity checks\n */\nabstract contract SwappableVault {\n    error SpentInputTokenAmountGreaterThanAmountInMaximum(uint256 spentInputTokenAmount, uint256 amountInMaximum);\n    error ReceivedOutputTokenAmountNotEqualAmountOut(uint256 receivedOutputTokenAmount, uint256 amountOut);\n    error OutputTokenBalanceNotIncreasedAfterSwap(uint256 outputTokenBalanceBefore, uint256 outputTokenBalanceAfter);\n    error SpentInputTokenAmountNotEqualReturnedAmountIn(uint256 spentInputTokenAmount, uint256 returnedAmountIn);\n\n    uint256 public constant BALANCE_DIFF_TOLERANCE = 1;\n\n    uint256 public breakPoint2;\n\n    /* Virtual functions */\n\n    /**\n     * @dev Swaps an exact amount of input assets for as much output assets as possible\n     * @param inputToken Input asset\n     * @param outputToken Output asset\n     * @param amountOut Amount of input assets\n     * @param amountInMaximum Minimum amount of output assets (slippage protection)\n     * @param receiver Address to receive the output assets\n     * @param deadline Deadline for the swap\n     * @param extraData Additional data for the swap\n     * @return amountIn Amount of input assets used for the swap\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory extraData\n    ) internal virtual returns (uint256);\n\n    /**\n     * @dev The difference tolerance for the swapped output amount\n     * @param expectedOutputAmount Expected output amount\n     * @return differenceTolerance The difference tolerance amount\n     */\n    function swappedOutputDifferenceToleranceAmount(uint256 expectedOutputAmount) public virtual returns (uint256);\n\n    /* Swap functions */\n\n    /**\n     * @dev A wrapper function for the _swapExactOutputImplementation function\n     *      - Add some sanity checks\n     * @param inputToken Input asset\n     * @param outputToken Output asset\n     * @param amountOut Amount of input assets\n     * @param amountInMaximum Minimum amount of output assets (slippage protection)\n     * @param receiver Address to receive the output assets\n     * @param deadline Deadline for the swap\n     * @param extraData Additional data for the swap\n     * @return amountIn Amount of input assets used for the swap\n     */\n    function _swapExactOutput(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory extraData\n    ) internal returns (uint256) {\n        uint256 inputTokenBalanceBefore = inputToken.balanceOf(address(this));\n        uint256 outputTokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        require(breakPoint2 != 40001, string.concat(\"40001: amountOut:\", uint256ToString(amountOut)));\n\n        setBreakPoint2(breakPoint2);\n\n        // Perform the swap\n        uint256 amountIn = _swapExactOutputImplementation(\n            inputToken,\n            outputToken,\n            amountOut,\n            amountInMaximum,\n            receiver,\n            deadline,\n            extraData\n        );\n\n        require(breakPoint2 != 40002, \"40002\");\n\n        uint256 inputTokenBalanceAfter = inputToken.balanceOf(address(this));\n        uint256 outputTokenBalanceAfter = outputToken.balanceOf(address(this));\n\n        // Input token: if decreased, ensure not over max and within tolerance of amountIn\n        {\n            require(breakPoint2 != 40003, \"40003\");\n            Compare.BalanceCheckResult memory inCheck = Compare.checkBalanceDelta(\n                inputTokenBalanceBefore,\n                inputTokenBalanceAfter,\n                amountIn,\n                BALANCE_DIFF_TOLERANCE,\n                Compare.BalanceDirection.Decrease\n            );\n            require(breakPoint2 != 40004, \"40004\");\n            if (inCheck.directionOk) {\n                // First check: ensure we don't spend more than the maximum allowed\n                if (inCheck.observedDelta > amountInMaximum) {\n                    revert SpentInputTokenAmountGreaterThanAmountInMaximum(inCheck.observedDelta, amountInMaximum);\n                }\n                require(breakPoint2 != 40005, string.concat(\"40005: amountIn:\", uint256ToString(amountIn),\",amountInMaximum:\", uint256ToString(amountInMaximum),\",observedDelta:\", uint256ToString(inCheck.observedDelta), \"BALANCE_DIFF_TOLERANCE:\", uint256ToString(BALANCE_DIFF_TOLERANCE),\",inputTokenBalanceBefore:\", uint256ToString(inputTokenBalanceBefore),\",inputTokenBalanceAfter:\", uint256ToString(inputTokenBalanceAfter)));\n                // Second check: ensure spent amount matches returned amount within tolerance\n                if (!inCheck.toleranceOk) {\n                    revert SpentInputTokenAmountNotEqualReturnedAmountIn(inCheck.observedDelta, amountIn);\n                }\n            }\n            require(breakPoint2 != 40006, \"40006\");\n            // If not decreased, no checks needed (not a risk for the caller)\n        }\n\n        // Output token: must increase and be within tolerance of amountOut\n        {\n            uint256 differenceTolerance = swappedOutputDifferenceToleranceAmount(amountOut);\n            Compare.BalanceCheckResult memory outCheck = Compare.checkBalanceDelta(\n                outputTokenBalanceBefore,\n                outputTokenBalanceAfter,\n                amountOut,\n                BALANCE_DIFF_TOLERANCE + differenceTolerance,\n                Compare.BalanceDirection.Increase\n            );\n            require(breakPoint2 != 40008, \"40008\");\n            if (!outCheck.directionOk) {\n                revert OutputTokenBalanceNotIncreasedAfterSwap(outputTokenBalanceBefore, outputTokenBalanceAfter);\n            }\n            require(breakPoint2 != 40009, string.concat(\"40009: amountOut:\", uint256ToString(amountOut),\",observedDelta:\", uint256ToString(outCheck.observedDelta),\",BALANCE_DIFF_TOLERANCE:\", uint256ToString(BALANCE_DIFF_TOLERANCE),\",outputTokenBalanceBefore:\", uint256ToString(outputTokenBalanceBefore),\",outputTokenBalanceAfter:\", uint256ToString(outputTokenBalanceAfter),\",inDelta:\", uint256ToString(inputTokenBalanceBefore - inputTokenBalanceAfter)));\n            if (!outCheck.toleranceOk) {\n                revert ReceivedOutputTokenAmountNotEqualAmountOut(outCheck.observedDelta, amountOut);\n            }\n            require(breakPoint2 != 40010, \"40010\");\n        }\n\n        return amountIn;\n    }\n\n    function uint256ToString(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 length;\n        while (j != 0) {\n            length++;\n            j /= 10;\n        }\n\n        bytes memory bstr = new bytes(length);\n        uint256 k = length;\n        j = _i;\n        while (j != 0) {\n            bstr[--k] = bytes1(uint8(48 + (j % 10)));\n            j /= 10;\n        }\n        return string(bstr);\n    }\n\n    function setBreakPoint2(uint256 _breakPoint2) public {\n        breakPoint2 = _breakPoint2;\n    }\n}\n"
    },
    "contracts/odos/interface/IOdosRouterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\n/**\n * @dev Interface for Odos Router V2.\n * @dev Generated from original ABI: https://fraxscan.com/address/0x56c85a254dd12ee8d9c04049a4ab62769ce98210#code\n */\npragma solidity ^0.8.20;\n\ninterface IOdosRouterV2 {\n    struct swapTokenInfo {\n        address inputToken;\n        uint256 inputAmount;\n        address inputReceiver;\n        address outputToken;\n        uint256 outputQuote;\n        uint256 outputMin;\n        address outputReceiver;\n    }\n\n    struct inputTokenInfo {\n        address tokenAddress;\n        uint256 amountIn;\n        address receiver;\n    }\n\n    struct outputTokenInfo {\n        address tokenAddress;\n        uint256 relativeValue;\n        address receiver;\n    }\n\n    struct permit2Info {\n        address contractAddress;\n        uint256 nonce;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    event Swap(\n        address sender,\n        uint256 inputAmount,\n        address inputToken,\n        uint256 amountOut,\n        address outputToken,\n        int256 slippage,\n        uint32 referralCode\n    );\n\n    event SwapMulti(\n        address sender,\n        uint256[] amountsIn,\n        address[] tokensIn,\n        uint256[] amountsOut,\n        address[] tokensOut,\n        uint32 referralCode\n    );\n\n    function FEE_DENOM() external view returns (uint256);\n\n    function REFERRAL_WITH_FEE_THRESHOLD() external view returns (uint256);\n\n    function addressList(uint256) external view returns (address);\n\n    function owner() external view returns (address);\n\n    function referralLookup(uint32) external view returns (uint64 referralFee, address beneficiary, bool registered);\n\n    function registerReferralCode(uint32 _referralCode, uint64 _referralFee, address _beneficiary) external;\n\n    function renounceOwnership() external;\n\n    function setSwapMultiFee(uint256 _swapMultiFee) external;\n\n    function swap(\n        swapTokenInfo calldata tokenInfo,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external payable returns (uint256 amountOut);\n\n    function swapCompact() external payable returns (uint256);\n\n    function swapMulti(\n        inputTokenInfo[] calldata inputs,\n        outputTokenInfo[] calldata outputs,\n        uint256 valueOutMin,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external payable returns (uint256[] memory amountsOut);\n\n    function swapMultiCompact() external payable returns (uint256[] memory amountsOut);\n\n    function swapMultiFee() external view returns (uint256);\n\n    function swapMultiPermit2(\n        permit2Info calldata permit2,\n        inputTokenInfo[] calldata inputs,\n        outputTokenInfo[] calldata outputs,\n        uint256 valueOutMin,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external payable returns (uint256[] memory amountsOut);\n\n    function swapPermit2(\n        permit2Info calldata permit2,\n        swapTokenInfo calldata tokenInfo,\n        bytes calldata pathDefinition,\n        address executor,\n        uint32 referralCode\n    ) external returns (uint256 amountOut);\n\n    function swapRouterFunds(\n        inputTokenInfo[] calldata inputs,\n        outputTokenInfo[] calldata outputs,\n        uint256 valueOutMin,\n        bytes calldata pathDefinition,\n        address executor\n    ) external returns (uint256[] memory amountsOut);\n\n    function transferOwnership(address newOwner) external;\n\n    function transferRouterFunds(address[] calldata tokens, uint256[] calldata amounts, address dest) external;\n\n    function writeAddressList(address[] calldata addresses) external;\n\n    receive() external payable;\n}\n"
    },
    "contracts/odos/OdosSwapUtils.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.20;\n\nimport \"./interface/IOdosRouterV2.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title OdosSwapUtils\n * @notice Library for handling Odos swaps in liquidator contracts\n */\nlibrary OdosSwapUtils {\n    using SafeERC20 for IERC20;\n\n    /// @notice Custom error for failed swap with no revert reason\n    error SwapFailed();\n    /// @notice Custom error when actual output amount is less than expected\n    error InsufficientOutput(uint256 expected, uint256 actual);\n\n    /**\n     * @notice Performs a swap operation using Odos router with swap data\n     * @param router Odos router contract\n     * @param inputToken Input token address\n     * @param outputToken Output token address\n     * @param maxIn Maximum input amount\n     * @param exactOut Exact output amount expected\n     * @param swapData Encoded swap path data\n     * @return actualAmountSpent The actual amount of input tokens spent\n     */\n    function executeSwapOperation(\n        IOdosRouterV2 router,\n        address inputToken,\n        address outputToken,\n        uint256 maxIn,\n        uint256 exactOut,\n        bytes memory swapData\n    ) internal returns (uint256 actualAmountSpent) {\n        uint256 outputBalanceBefore = IERC20(outputToken).balanceOf(address(this));\n\n        // Use forceApprove for external DEX router integration\n        IERC20(inputToken).forceApprove(address(router), maxIn);\n\n        (bool success, bytes memory result) = address(router).call(swapData);\n        if (!success) {\n            if (result.length > 0) {\n                assembly {\n                    let resultLength := mload(result)\n                    revert(add(32, result), resultLength)\n                }\n            }\n            revert SwapFailed();\n        }\n\n        assembly {\n            actualAmountSpent := mload(add(result, 32))\n        }\n\n        uint256 outputBalanceAfter = IERC20(outputToken).balanceOf(address(this));\n        uint256 actualAmountReceived = outputBalanceAfter - outputBalanceBefore;\n\n        if (actualAmountReceived < exactOut) {\n            revert InsufficientOutput(exactOut, actualAmountReceived);\n        }\n\n        IERC20(inputToken).approve(address(router), 0);\n\n        return actualAmountSpent;\n    }\n}\n"
    },
    "contracts/odos/OdosSwapUtilsDebug.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.20;\n\nimport \"./interface/IOdosRouterV2.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title OdosSwapUtils\n * @notice Library for handling Odos swaps in liquidator contracts\n */\nlibrary OdosSwapUtils {\n    using SafeERC20 for IERC20;\n\n    /// @notice Custom error for failed swap with no revert reason\n    error SwapFailed();\n    /// @notice Custom error when actual output amount is less than expected\n    error InsufficientOutput(uint256 expected, uint256 actual);\n\n    /**\n     * @notice Performs a swap operation using Odos router with swap data\n     * @param router Odos router contract\n     * @param inputToken Input token address\n     * @param outputToken Output token address\n     * @param maxIn Maximum input amount\n     * @param exactOut Exact output amount expected\n     * @param swapData Encoded swap path data\n     * @return actualAmountSpent The actual amount of input tokens spent\n     */\n    function executeSwapOperationWithBreakPoint(\n        IOdosRouterV2 router,\n        address inputToken,\n        address outputToken,\n        uint256 maxIn,\n        uint256 exactOut,\n        bytes memory swapData,\n        uint256 breakPoint\n    ) internal returns (uint256 actualAmountSpent) {\n        uint256 outputBalanceBefore = IERC20(outputToken).balanceOf(address(this));\n\n        // Use forceApprove for external DEX router integration\n        IERC20(inputToken).forceApprove(address(router), maxIn);\n\n        (bool success, bytes memory result) = address(router).call(swapData);\n        if (!success) {\n            require(breakPoint != 70001, \"70001\");\n            if (result.length > 0) {\n                require(breakPoint != 70002, \"70002\");\n                assembly {\n                    let resultLength := mload(result)\n                    revert(add(32, result), resultLength)\n                }\n            }\n            require(breakPoint != 70003, \"70003\");\n            revert SwapFailed();\n        }\n\n        assembly {\n            actualAmountSpent := mload(add(result, 32))\n        }\n\n        require(breakPoint != 70004, \"70004\");\n\n        // Declare variables closer to usage to reduce stack depth\n        uint256 outputBalanceAfter;\n        {\n            outputBalanceAfter = IERC20(outputToken).balanceOf(address(this));\n\n            uint256 actualAmountReceived = outputBalanceAfter - outputBalanceBefore;\n            require(breakPoint != 70005, string.concat(\"70005: actualAmountReceived:\", uint256ToString(actualAmountReceived), \", exactOut:\", uint256ToString(exactOut)));\n            if (actualAmountReceived < exactOut) {\n                revert InsufficientOutput(exactOut, actualAmountReceived);\n            }\n        }\n\n        require(breakPoint != 70006, \"70006\");\n\n        IERC20(inputToken).approve(address(router), 0);\n\n        return actualAmountSpent;\n    }\n\n    function uint256ToString(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 length;\n        while (j != 0) {\n            length++;\n            j /= 10;\n        }\n\n        bytes memory bstr = new bytes(length);\n        uint256 k = length;\n        j = _i;\n        while (j != 0) {\n            bstr[--k] = bytes1(uint8(48 + (j % 10)));\n            j /= 10;\n        }\n        return string(bstr);\n    }\n}\n"
    },
    "contracts/vaults/dloop/core/DLoopCoreBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { BasisPointConstants } from \"contracts/common/BasisPointConstants.sol\";\nimport { ERC4626, ERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { Erc20Helper } from \"contracts/common/Erc20Helper.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { RescuableVault } from \"contracts/common/RescuableVault.sol\";\nimport { DLoopCoreLogic } from \"./DLoopCoreLogic.sol\";\nimport { Compare } from \"contracts/common/Compare.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title DLoopCoreBase\n * @dev A contract that executes leveraged operations on a lending pool using a collateral token and a debt token\n *      - A leveraged position is created by supplying a collateral token to the lending pool and borrowing a debt token\n *      - The leverage ratio will be changed if the collateral and debt values are changed (due to price changes)\n *      - The leverage can be increased by supplying more collateral token or decreasing the debt token\n *      - The leverage can be decreased by withdrawing collateral token or increasing the debt token\n *      - In order to keep the vault balanced, user can call increaseLeverage or decreaseLeverage to increase or decrease the leverage\n *        when it is away from the target leverage\n *      - There is a subsidy for the caller when increasing the leverage.\n *      - The withdrawal fee is being applied when calling redeem and withdraw. The fee is not being transferred to a fee receiver, instead\n *        it is being shared to the current shares holders. It means, the vault of the vault's share will be a bit increased after a user's withdrawal.\n *      - The withdrawal fee is not applied for decreaseLeverage(), as this operation is not a vault withdrawal, instead, it repay and withdraw\n *        from the underlying pool to rebalance the vault position, not vault's shares are being burned.\n *\n * @notice Withdrawal fee retention (no external transfers)\n * @dev The withdrawal fee is retained by the vault and is not sent to any external recipient.\n *      Users receive net assets after fee; the difference remains in the vault and accrues to remaining shares.\n *      - previewWithdraw treats `assets` as the desired net and converts to gross using:\n *        gross = assets * ONE_HUNDRED_PERCENT_BPS / (ONE_HUNDRED_PERCENT_BPS - withdrawalFeeBps).\n *      - previewRedeem returns the net assets after applying the fee.\n *      - During _withdraw, only the net amount is transferred to `receiver`; the fee stays in the vault balance.\n */\nabstract contract DLoopCoreBase is ERC4626, Ownable, ReentrancyGuard, RescuableVault {\n    using SafeERC20 for ERC20;\n\n    /* Core state */\n\n    uint32 public lowerBoundTargetLeverageBps;\n    uint32 public upperBoundTargetLeverageBps;\n    uint256 public maxSubsidyBps;\n    uint256 public minDeviationBps;\n    uint256 public withdrawalFeeBps;\n\n    /* Constants */\n\n    uint32 public immutable targetLeverageBps; // ie. 30000 = 300% in basis points, means 3x leverage\n    ERC20 public immutable collateralToken;\n    ERC20 public immutable debtToken;\n\n    uint256 public constant BALANCE_DIFF_TOLERANCE = 1;\n    uint256 public constant LEVERAGE_DIFF_TOLERANCE = 1;\n    uint256 public constant MAX_WITHDRAWAL_FEE_BPS = 10 * BasisPointConstants.ONE_PERCENT_BPS; // 100%\n\n    /* Events */\n\n    event IncreaseLeverage(\n        address indexed caller,\n        uint256 inputCollateralTokenAmount,\n        uint256 minReceivedDebtTokenAmount,\n        uint256 suppliedCollateralTokenAmount,\n        uint256 borrowedDebtTokenAmount\n    );\n\n    event DecreaseLeverage(\n        address indexed caller,\n        uint256 inputDebtTokenAmount,\n        uint256 minReceivedCollateralTokenAmount,\n        uint256 repaidDebtTokenAmount,\n        uint256 withdrawnCollateralTokenAmount\n    );\n\n    event MaxSubsidyBpsSet(uint256 oldMaxSubsidyBps, uint256 newMaxSubsidyBps);\n\n    event MinDeviationBpsSet(uint256 oldMinDeviationBps, uint256 newMinDeviationBps);\n\n    event LeverageBoundsSet(uint32 lowerBoundTargetLeverageBps, uint32 upperBoundTargetLeverageBps);\n\n    event WithdrawalFeeBpsSet(uint256 oldWithdrawalFeeBps, uint256 newWithdrawalFeeBps);\n\n    event LeftoverCollateralTokensTransferred(address indexed token, uint256 amount, address indexed receiver);\n\n    event LeftoverDebtTokensTransferred(address indexed token, uint256 amount, address indexed receiver);\n\n    /* Errors */\n\n    error TooImbalanced(\n        uint256 currentLeverageBps,\n        uint256 lowerBoundTargetLeverageBps,\n        uint256 upperBoundTargetLeverageBps\n    );\n    error InsufficientAllowanceOfDebtAssetToRepay(\n        address owner,\n        address spender,\n        address debtAsset,\n        uint256 requiredAllowance\n    );\n    error InsufficientAllowanceOfCollateralAssetToSupply(\n        address owner,\n        address spender,\n        address collateralAsset,\n        uint256 requiredAllowance\n    );\n    error DecreaseLeverageOutOfRange(\n        uint256 newLeverageBps,\n        uint256 targetLeverageBps, // lower bound\n        uint256 currentLeverageBps // upper bound\n    );\n    error IncreaseLeverageOutOfRange(\n        uint256 newLeverageBps,\n        uint256 targetLeverageBps, // upper bound\n        uint256 currentLeverageBps // lower bound\n    );\n    error TokenBalanceNotDecreasedAfterRepay(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedRepayAmountToPool(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error TokenBalanceNotDecreasedAfterSupply(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedSupplyAmountToPool(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error TokenBalanceNotIncreasedAfterBorrow(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedBorrowAmountFromPool(\n        address token,\n        uint256 borrowedAmountBefore,\n        uint256 borrowedAmountAfter,\n        uint256 expectedBorrowedAmount\n    );\n    error TokenBalanceNotIncreasedAfterWithdraw(\n        address token,\n        uint256 tokenBalanceBefore,\n        uint256 tokenBalanceAfter,\n        uint256 expectedTokenBalance\n    );\n    error UnexpectedWithdrawAmountFromPool(\n        address token,\n        uint256 withdrawableAmountBefore,\n        uint256 withdrawableAmountAfter,\n        uint256 expectedWithdrawableAmount\n    );\n    error InvalidLeverageBounds(uint256 lowerBound, uint256 targetLeverage, uint256 upperBound);\n    error AssetPriceIsZero(address asset);\n    error LeverageExceedsTarget(uint256 currentLeverageBps, uint256 targetLeverageBps);\n    error LeverageBelowTarget(uint256 currentLeverageBps, uint256 targetLeverageBps);\n    error IncreaseLeverageReceiveLessThanMinAmount(uint256 receivedDebtTokenAmount, uint256 minReceivedDebtTokenAmount);\n    error DecreaseLeverageReceiveLessThanMinAmount(\n        uint256 receivedCollateralTokenAmount,\n        uint256 minReceivedCollateralTokenAmount\n    );\n    error ZeroShares();\n    error WithdrawalFeeIsGreaterThanMaxFee(uint256 withdrawalFeeBps, uint256 maxWithdrawalFeeBps);\n    error InvalidTargetLeverage(uint256 targetLeverageBps);\n    error InvalidCollateralToken(address token);\n    error InvalidDebtToken(address token);\n\n    /**\n     * @dev Constructor for the DLoopCore contract\n     * @param _name Name of the vault token\n     * @param _symbol Symbol of the vault token\n     * @param _collateralToken Address of the collateral token\n     * @param _debtToken Address of the debt token\n     * @param _targetLeverageBps Target leverage in basis points\n     * @param _lowerBoundTargetLeverageBps Lower bound of target leverage in basis points\n     * @param _upperBoundTargetLeverageBps Upper bound of target leverage in basis points\n     * @param _maxSubsidyBps Maximum subsidy in basis points\n     * @param _minDeviationBps Minimum deviation of leverage from the target leverage in basis points\n     * @param _withdrawalFeeBps Initial withdrawal fee in basis points\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        ERC20 _collateralToken,\n        ERC20 _debtToken,\n        uint32 _targetLeverageBps,\n        uint32 _lowerBoundTargetLeverageBps,\n        uint32 _upperBoundTargetLeverageBps,\n        uint256 _maxSubsidyBps,\n        uint256 _minDeviationBps,\n        uint256 _withdrawalFeeBps\n    ) ERC20(_name, _symbol) ERC4626(_collateralToken) Ownable(msg.sender) {\n        debtToken = _debtToken;\n        collateralToken = _collateralToken;\n\n        if (_targetLeverageBps < BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert InvalidTargetLeverage(_targetLeverageBps);\n        }\n\n        if (_lowerBoundTargetLeverageBps >= _targetLeverageBps || _targetLeverageBps >= _upperBoundTargetLeverageBps) {\n            revert InvalidLeverageBounds(\n                _lowerBoundTargetLeverageBps,\n                _targetLeverageBps,\n                _upperBoundTargetLeverageBps\n            );\n        }\n\n        // Make sure collateral token is ERC-20\n        if (!Erc20Helper.isERC20(address(_collateralToken))) {\n            revert InvalidCollateralToken(address(_collateralToken));\n        }\n\n        // Make sure debt token is ERC-20\n        if (!Erc20Helper.isERC20(address(_debtToken))) {\n            revert InvalidDebtToken(address(_debtToken));\n        }\n\n        targetLeverageBps = _targetLeverageBps;\n        lowerBoundTargetLeverageBps = _lowerBoundTargetLeverageBps;\n        upperBoundTargetLeverageBps = _upperBoundTargetLeverageBps;\n        maxSubsidyBps = _maxSubsidyBps;\n        minDeviationBps = _minDeviationBps;\n        withdrawalFeeBps = _withdrawalFeeBps;\n    }\n\n    /* Virtual Methods - Required to be implemented by derived contracts */\n\n    /**\n     * @dev Gets the total collateral and debt of a user in base currency\n     * @param user Address of the user\n     * @return totalCollateralBase Total collateral in base currency\n     * @return totalDebtBase Total debt in base currency\n     */\n    function getTotalCollateralAndDebtOfUserInBase(\n        address user\n    ) public view returns (uint256 totalCollateralBase, uint256 totalDebtBase) {\n        // Collateral side: balance of the aToken corresponding to collateralToken\n        uint256 collateralBalanceInTokenAmount = getCollateralValueInTokenAmount(address(collateralToken), user);\n        totalCollateralBase = convertFromTokenAmountToBaseCurrency(\n            collateralBalanceInTokenAmount,\n            address(collateralToken)\n        );\n\n        // Debt side: sum of variable + stable debt token balances corresponding to debtToken\n        uint256 debtBalanceInTokenAmount = getDebtValueInTokenAmount(address(debtToken), user);\n        totalDebtBase = convertFromTokenAmountToBaseCurrency(debtBalanceInTokenAmount, address(debtToken));\n        return (totalCollateralBase, totalDebtBase);\n    }\n\n    /**\n     * @dev Get the collateral value in token amount in the underlying pool\n     * @param token The address of the token\n     * @param user The address of the user\n     * @return collateralTokenAmount The collateral token amount\n     */\n    function getCollateralValueInTokenAmount(\n        address token,\n        address user\n    ) public view virtual returns (uint256 collateralTokenAmount);\n\n    /**\n     * @dev Get the debt value in token amount in the underlying pool\n     * @param token The address of the token\n     * @param user The address of the user\n     * @return debtTokenAmount The debt token amount\n     */\n    function getDebtValueInTokenAmount(\n        address token,\n        address user\n    ) public view virtual returns (uint256 debtTokenAmount);\n\n    /**\n     * @dev Gets the additional rescue tokens\n     *      - As the getRestrictedRescueTokens function is very critical and we do not\n     *        want to override it in the derived contracts, we use this function to\n     *        get the additional rescue tokens\n     * @return address[] Additional rescue tokens\n     */\n    function _getAdditionalRescueTokensImplementation() internal view virtual returns (address[] memory);\n\n    /**\n     * @dev Gets the asset price from the oracle\n     * @param asset Address of the asset\n     * @return uint256 Price of the asset\n     */\n    function _getAssetPriceFromOracleImplementation(address asset) internal view virtual returns (uint256);\n\n    /**\n     * @dev Supply tokens to the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to supply\n     * @param onBehalfOf Address to supply on behalf of\n     */\n    function _supplyToPoolImplementation(address token, uint256 amount, address onBehalfOf) internal virtual;\n\n    /**\n     * @dev Borrow tokens from the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to borrow\n     * @param onBehalfOf Address to borrow on behalf of\n     */\n    function _borrowFromPoolImplementation(address token, uint256 amount, address onBehalfOf) internal virtual;\n\n    /**\n     * @dev Repay debt to the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to repay\n     * @param onBehalfOf Address to repay on behalf of\n     */\n    function _repayDebtToPoolImplementation(address token, uint256 amount, address onBehalfOf) internal virtual;\n\n    /**\n     * @dev Withdraw tokens from the lending pool\n     * @param token Address of the token\n     * @param amount Amount of tokens to withdraw\n     * @param onBehalfOf Address to withdraw on behalf of\n     */\n    function _withdrawFromPoolImplementation(address token, uint256 amount, address onBehalfOf) internal virtual;\n\n    /* Wrapper Functions */\n\n    /**\n     * @dev Supply tokens to the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to supply\n     * @param onBehalfOf Address to supply on behalf of\n     * @return uint256 The amount of tokens supplied\n     */\n    function _supplyToPool(address token, uint256 amount, address onBehalfOf) internal returns (uint256) {\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeSupply = ERC20(token).balanceOf(onBehalfOf);\n\n        _supplyToPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterSupply = ERC20(token).balanceOf(onBehalfOf);\n\n        Compare.BalanceCheckResult memory check = Compare.checkBalanceDelta(\n            tokenBalanceBeforeSupply,\n            tokenBalanceAfterSupply,\n            amount,\n            BALANCE_DIFF_TOLERANCE,\n            Compare.BalanceDirection.Decrease\n        );\n        if (!check.directionOk) {\n            revert TokenBalanceNotDecreasedAfterSupply(\n                token,\n                tokenBalanceBeforeSupply,\n                tokenBalanceAfterSupply,\n                amount\n            );\n        }\n        if (!check.toleranceOk) {\n            revert UnexpectedSupplyAmountToPool(token, tokenBalanceBeforeSupply, tokenBalanceAfterSupply, amount);\n        }\n\n        // Return the observed value to avoid the case when the actual amount is 1 wei different from the expected amount\n        return check.observedDelta;\n    }\n\n    /**\n     * @dev Borrow tokens from the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to borrow\n     * @param onBehalfOf Address to borrow on behalf of\n     * @return uint256 The amount of tokens borrowed\n     */\n    function _borrowFromPool(address token, uint256 amount, address onBehalfOf) internal returns (uint256) {\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeBorrow = ERC20(token).balanceOf(onBehalfOf);\n\n        _borrowFromPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterBorrow = ERC20(token).balanceOf(onBehalfOf);\n\n        Compare.BalanceCheckResult memory check = Compare.checkBalanceDelta(\n            tokenBalanceBeforeBorrow,\n            tokenBalanceAfterBorrow,\n            amount,\n            BALANCE_DIFF_TOLERANCE,\n            Compare.BalanceDirection.Increase\n        );\n        if (!check.directionOk) {\n            revert TokenBalanceNotIncreasedAfterBorrow(\n                token,\n                tokenBalanceBeforeBorrow,\n                tokenBalanceAfterBorrow,\n                amount\n            );\n        }\n        if (!check.toleranceOk) {\n            revert UnexpectedBorrowAmountFromPool(token, tokenBalanceBeforeBorrow, tokenBalanceAfterBorrow, amount);\n        }\n\n        // Return the observed value to avoid the case when the actual amount is 1 wei different from the expected amount\n        return check.observedDelta;\n    }\n\n    /**\n     * @dev Repay debt to the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to repay\n     * @param onBehalfOf Address to repay on behalf of\n     * @return uint256 The amount of tokens repaid\n     */\n    function _repayDebtToPool(address token, uint256 amount, address onBehalfOf) internal returns (uint256) {\n        // Get the debt position before repaying\n        uint256 debtPositionBeforeRepay = getDebtValueInTokenAmount(token, onBehalfOf);\n\n        // Cap the amount to repay to the debt position to avoid\n        // later balance assertion\n        amount = Math.min(amount, debtPositionBeforeRepay);\n\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeRepay = ERC20(token).balanceOf(onBehalfOf);\n\n        _repayDebtToPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterRepay = ERC20(token).balanceOf(onBehalfOf);\n\n        Compare.BalanceCheckResult memory check = Compare.checkBalanceDelta(\n            tokenBalanceBeforeRepay,\n            tokenBalanceAfterRepay,\n            amount,\n            BALANCE_DIFF_TOLERANCE,\n            Compare.BalanceDirection.Decrease\n        );\n        if (!check.directionOk) {\n            revert TokenBalanceNotDecreasedAfterRepay(token, tokenBalanceBeforeRepay, tokenBalanceAfterRepay, amount);\n        }\n        if (!check.toleranceOk) {\n            revert UnexpectedRepayAmountToPool(token, tokenBalanceBeforeRepay, tokenBalanceAfterRepay, amount);\n        }\n\n        // Return the observed value to avoid the case when the actual amount is 1 wei different from the expected amount\n        return check.observedDelta;\n    }\n\n    /**\n     * @dev Withdraw tokens from the lending pool, and make sure the output is as expected\n     * @param token Address of the token\n     * @param amount Amount of tokens to withdraw\n     * @param onBehalfOf Address to withdraw on behalf of\n     * @return uint256 The amount of tokens withdrawn\n     */\n    function _withdrawFromPool(address token, uint256 amount, address onBehalfOf) internal returns (uint256) {\n        // Get the collateral position before withdrawing\n        uint256 collateralPositionBeforeWithdraw = getCollateralValueInTokenAmount(token, onBehalfOf);\n\n        // Cap the amount to withdraw to the collateral position to avoid\n        // later balance assertion\n        amount = Math.min(amount, collateralPositionBeforeWithdraw);\n\n        // At this step, we assume that the funds from the depositor are already in the vault\n\n        uint256 tokenBalanceBeforeWithdraw = ERC20(token).balanceOf(onBehalfOf);\n\n        _withdrawFromPoolImplementation(token, amount, onBehalfOf);\n\n        uint256 tokenBalanceAfterWithdraw = ERC20(token).balanceOf(onBehalfOf);\n\n        Compare.BalanceCheckResult memory check = Compare.checkBalanceDelta(\n            tokenBalanceBeforeWithdraw,\n            tokenBalanceAfterWithdraw,\n            amount,\n            BALANCE_DIFF_TOLERANCE,\n            Compare.BalanceDirection.Increase\n        );\n        if (!check.directionOk) {\n            revert TokenBalanceNotIncreasedAfterWithdraw(\n                token,\n                tokenBalanceBeforeWithdraw,\n                tokenBalanceAfterWithdraw,\n                amount\n            );\n        }\n        if (!check.toleranceOk) {\n            revert UnexpectedWithdrawAmountFromPool(\n                token,\n                tokenBalanceBeforeWithdraw,\n                tokenBalanceAfterWithdraw,\n                amount\n            );\n        }\n\n        // Return the observed value to avoid the case when the actual amount is 1 wei different from the expected amount\n        return check.observedDelta;\n    }\n\n    /* Safety */\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return address[] Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens() public view virtual override returns (address[] memory) {\n        // Get the additional rescue tokens from the derived contract\n        return _getAdditionalRescueTokensImplementation();\n    }\n\n    /* Helper Functions */\n\n    /**\n     * @dev Gets the asset price from the oracle\n     * @param asset Address of the asset\n     * @return uint256 Price of the asset\n     */\n    function getAssetPriceFromOracle(address asset) public view returns (uint256) {\n        uint256 assetPrice = _getAssetPriceFromOracleImplementation(asset);\n\n        // Sanity check\n        if (assetPrice == 0) {\n            revert AssetPriceIsZero(asset);\n        }\n\n        return assetPrice;\n    }\n\n    /**\n     * @dev Converts an amount in base currency to the actual amount in the token\n     * @param amountInBase Amount in base currency\n     * @param token Address of the token\n     * @return amountInToken Amount in the token\n     */\n    function convertFromBaseCurrencyToToken(uint256 amountInBase, address token) public view returns (uint256) {\n        return\n            DLoopCoreLogic.convertFromBaseCurrencyToToken(\n                amountInBase,\n                ERC20(token).decimals(),\n                getAssetPriceFromOracle(token)\n            );\n    }\n\n    /**\n     * @dev Converts an amount in the token to the actual amount in base currency\n     * @param amountInToken Amount in the token\n     * @param token Address of the token\n     * @return amountInBase Amount in base currency\n     */\n    function convertFromTokenAmountToBaseCurrency(uint256 amountInToken, address token) public view returns (uint256) {\n        return\n            DLoopCoreLogic.convertFromTokenAmountToBaseCurrency(\n                amountInToken,\n                ERC20(token).decimals(),\n                getAssetPriceFromOracle(token)\n            );\n    }\n\n    /**\n     * @dev Override of totalAssets from ERC4626\n     * @return uint256 Total assets in the vault\n     */\n    function totalAssets() public view virtual override returns (uint256) {\n        // We override this function to return the total assets in the vault\n        // with respect to the position in the lending pool\n        // The dLend interest will be distributed to the dToken\n        (uint256 totalCollateralBase, ) = getTotalCollateralAndDebtOfUserInBase(address(this));\n        // The price decimals is cancelled out in the division (as the amount and price are in the same unit)\n        return convertFromBaseCurrencyToToken(totalCollateralBase, address(collateralToken));\n    }\n\n    /* Safety */\n\n    /**\n     * @dev Returns whether the current leverage is too imbalanced\n     * @return bool True if leverage is too imbalanced, false otherwise\n     */\n    function isTooImbalanced() public view returns (bool) {\n        return\n            DLoopCoreLogic.isTooImbalanced(\n                getCurrentLeverageBps(),\n                lowerBoundTargetLeverageBps,\n                upperBoundTargetLeverageBps\n            );\n    }\n\n    /* Deposit and Mint */\n\n    /**\n     * @dev Deposits assets into the vault\n     *      - It will send the borrowed debt token and the minted shares to the receiver\n     *      - The minted shares represent the position of the supplied collateral assets in the lending pool\n     * @param caller Address of the caller\n     * @param receiver Address to receive the minted shares\n     * @param assets Amount of assets to deposit\n     * @param shares Amount of shares to mint\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override nonReentrant {\n        if (shares == 0) {\n            revert ZeroShares();\n        }\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - The current collateral token balance is 0 WETH\n         * - The current debt token balance is 0 dUSD\n         * - The current shares supply is 0\n         * - Assume that the price of WETH is 2000 dUSD\n         *\n         * 1. User deposits 300 WETH\n         * 2. The vault supplies 300 WETH to the lending pool\n         * 3. The vault borrows 400,000 dUSD (300 * 2000 * 66.6666666%) from the lending pool\n         *    - 66.666% is to keep the target leverage 3x\n         * 4. The vault sends 400,000 dUSD to the receiver\n         * 5. The vault mints 300 shares to the user (representing 300 WETH position in the lending pool)\n         *\n         * The current leverage is: (300 * 2000) / (300 * 2000 - 400,000) = 3x\n         */\n\n        // Make sure the current leverage is within the target range\n        if (isTooImbalanced()) {\n            revert TooImbalanced(getCurrentLeverageBps(), lowerBoundTargetLeverageBps, upperBoundTargetLeverageBps);\n        }\n\n        uint256 debtAssetBorrowed = _supplyAndBorrowFromPoolImplementation(caller, assets);\n\n        // Transfer the debt asset to the receiver\n        debtToken.safeTransfer(receiver, debtAssetBorrowed);\n\n        // Mint the vault's shares to the depositor\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Handles the logic of supplying collateral token and borrowing debt token\n     * @param caller Address of the caller\n     * @param supplyAssetAmount Amount of assets to supply\n     * @return borrowedDebtTokenAmount Amount of debt asset to borrow\n     */\n    function _supplyAndBorrowFromPoolImplementation(\n        address caller,\n        uint256 supplyAssetAmount // supply amount\n    ) private returns (uint256 borrowedDebtTokenAmount) {\n        // Get current leverage before transferring, supplying and borrowing\n        // to avoid unexpected impact from the child contract implementation\n        // IMPORTANT: this is the leverage before supplying\n        uint256 currentLeverageBpsBeforeSupply = getCurrentLeverageBps();\n\n        // If do not have enough allowance, revert with the error message\n        // This is to early-revert with instruction in the error message\n        if (collateralToken.allowance(caller, address(this)) < supplyAssetAmount) {\n            revert InsufficientAllowanceOfCollateralAssetToSupply(\n                caller,\n                address(this),\n                address(collateralToken),\n                supplyAssetAmount\n            );\n        }\n\n        // Transfer the assets to the vault (need the allowance before calling this function)\n        collateralToken.safeTransferFrom(caller, address(this), supplyAssetAmount);\n\n        // At this step, the fund from the depositor is already in the vault\n\n        // In this case, the vault is user of the lending pool\n        // So, we need to supply the collateral token to the pool on behalf of the vault\n        // and then borrow the debt token from the pool on behalf of the vault\n\n        // Supply the collateral token to the lending pool\n        uint256 actualSupplyAssetAmount = _supplyToPool(\n            address(collateralToken),\n            supplyAssetAmount,\n            address(this) // the vault is the supplier\n        );\n\n        // Get the amount of debt token to borrow that keeps the current leverage\n        uint256 debtTokenAmountToBorrow = DLoopCoreLogic.getBorrowAmountThatKeepCurrentLeverage(\n            actualSupplyAssetAmount,\n            currentLeverageBpsBeforeSupply,\n            targetLeverageBps,\n            ERC20(collateralToken).decimals(),\n            getAssetPriceFromOracle(address(collateralToken)),\n            ERC20(debtToken).decimals(),\n            getAssetPriceFromOracle(address(debtToken))\n        );\n\n        // Borrow the max amount of debt token\n        borrowedDebtTokenAmount = _borrowFromPool(\n            address(debtToken),\n            debtTokenAmountToBorrow,\n            address(this) // the vault is the borrower\n        );\n\n        // Transfer the unused collateral token to the caller\n        if (actualSupplyAssetAmount < supplyAssetAmount - BALANCE_DIFF_TOLERANCE) {\n            uint256 unusedCollateralTokenAmount = supplyAssetAmount - actualSupplyAssetAmount;\n            collateralToken.safeTransfer(caller, unusedCollateralTokenAmount);\n            emit LeftoverCollateralTokensTransferred(address(collateralToken), unusedCollateralTokenAmount, caller);\n        }\n\n        return borrowedDebtTokenAmount;\n    }\n\n    /* Withdraw and Redeem */\n\n    /**\n     * @dev Withdraws collateral assets from the vault\n     *      - It requires to spend the debt token to repay the debt\n     *      - It will send the withdrawn collateral assets to the receiver and burn the shares\n     *      - The burned shares represent the position of the withdrawn assets in the lending pool\n     *      - The shares and assets are now reflected the charged withdrawal fee, thus no need to apply withdrawal fee again\n     * @param caller Address of the caller\n     * @param receiver Address to receive the withdrawn assets\n     * @param owner Address of the owner\n     * @param assets Amount of assets to remove from the lending pool\n     * @param shares Amount of shares to burn\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal override nonReentrant {\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - The current shares supply is 300\n         * - The current leverage is 3x\n         * - The current collateral token balance is 300 WETH\n         * - The current debt token balance is 400,000 dUSD (300 * 2000 * 66.6666666%)\n         * - Assume that the price of WETH is 2000 dUSD\n         *\n         * 1. User has 100 shares\n         * 2. User wants to withdraw 100 WETH\n         * 3. The vault burns 100 shares\n         * 4. The vault transfers 133,333 dUSD (100 * 2000 * 66.6666666%) from the user to the vault\n         *    - 66.6666% is to keep the target leverage 3x\n         * 5. The vault repays 133,333 dUSD to the lending pool\n         *    - The debt is now 266,667 dUSD (400,000 - 133,333)\n         * 6. The vault withdraws 100 WETH from the lending pool\n         *    - The collateral is now 200 WETH (300 - 100)\n         * 7. The vault sends 100 WETH to the receiver\n         *\n         * The current leverage is: (200 * 2000) / (200 * 2000 - 266,667) = 3x\n         */\n\n        // Note that we need the allowance before calling this function\n        // - Allowance for the message sender to spend the shares on behalf of the owner\n        // - Allowance for the vault to burn the shares\n\n        // If the owner is not the caller, then we need to spend the allowance\n        // so that the caller can spend the shares on behalf of the owner\n        if (owner != caller) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // Burn the shares\n        _burn(owner, shares);\n\n        // Make sure the current leverage is within the target range\n        if (isTooImbalanced()) {\n            revert TooImbalanced(getCurrentLeverageBps(), lowerBoundTargetLeverageBps, upperBoundTargetLeverageBps);\n        }\n\n        // Withdraw the collateral from the lending pool\n        // After this step, the _withdrawFromPool wrapper function will also assert that\n        // the withdrawn amount is exactly the amount requested.\n        (uint256 withdrawnCollateralTokenAmount, ) = _repayDebtAndWithdrawFromPoolImplementation(caller, assets);\n\n        // Transfer the net asset to the receiver\n        collateralToken.safeTransfer(receiver, withdrawnCollateralTokenAmount);\n\n        // Emit ERC4626 Withdraw with amount actually sent\n        emit Withdraw(caller, receiver, owner, withdrawnCollateralTokenAmount, shares);\n    }\n\n    /**\n     * @dev Handles the logic for repaying debt and withdrawing collateral from the pool\n     *      - It calculates the required debt token to repay to keep the current leverage\n     *        given the expected withdraw amount\n     *      - Then performs the actual repay and withdraw\n     * @param caller Address of the caller\n     * @param collateralTokenToWithdraw The amount of collateral token to withdraw\n     * @return withdrawnCollateralTokenAmount The amount of collateral token withdrawn\n     * @return actualRepaidDebtTokenAmount The amount of debt token repaid\n     */\n    function _repayDebtAndWithdrawFromPoolImplementation(\n        address caller,\n        uint256 collateralTokenToWithdraw\n    ) private returns (uint256 withdrawnCollateralTokenAmount, uint256 actualRepaidDebtTokenAmount) {\n        // Get the current leverage before repaying the debt (IMPORTANT: this is the leverage before repaying the debt)\n        // It is used to calculate the expected withdrawable amount that keeps the current leverage\n        uint256 leverageBpsBeforeRepayDebt = getCurrentLeverageBps();\n\n        // Get the amount of debt token to repay to keep the current leverage\n        uint256 estimatedRepaidDebtTokenAmount = DLoopCoreLogic.getRepayAmountThatKeepCurrentLeverage(\n            collateralTokenToWithdraw,\n            leverageBpsBeforeRepayDebt,\n            ERC20(collateralToken).decimals(),\n            getAssetPriceFromOracle(address(collateralToken)),\n            ERC20(debtToken).decimals(),\n            getAssetPriceFromOracle(address(debtToken))\n        );\n\n        // If don't have enough allowance, revert with the error message\n        // This is to early-revert with instruction in the error message\n        if (debtToken.allowance(caller, address(this)) < estimatedRepaidDebtTokenAmount) {\n            revert InsufficientAllowanceOfDebtAssetToRepay(\n                caller,\n                address(this),\n                address(debtToken),\n                estimatedRepaidDebtTokenAmount\n            );\n        }\n\n        // Transfer the debt token to the vault to repay the debt\n        debtToken.safeTransferFrom(caller, address(this), estimatedRepaidDebtTokenAmount);\n\n        // In this case, the vault is user of the lending pool\n        // So, we need to repay the debt to the pool on behalf of the vault\n        // and then withdraw the collateral from the pool on behalf of the vault\n\n        // Repay the debt to withdraw the collateral\n        // Update the repaid debt token amount to the actual amount as this\n        // variable is also the return value of this function\n        actualRepaidDebtTokenAmount = _repayDebtToPool(\n            address(debtToken),\n            estimatedRepaidDebtTokenAmount,\n            address(this) // the vault is the borrower\n        );\n\n        // Withdraw the collateral\n        // At this step, the _withdrawFromPool wrapper function will also assert that\n        // the withdrawn amount is exactly the amount requested.\n        withdrawnCollateralTokenAmount = _withdrawFromPool(\n            address(collateralToken),\n            collateralTokenToWithdraw,\n            address(this) // the vault is the receiver\n        );\n\n        // Transfer the unused debt token to the caller\n        if (actualRepaidDebtTokenAmount < estimatedRepaidDebtTokenAmount - BALANCE_DIFF_TOLERANCE) {\n            uint256 unusedDebtTokenAmount = estimatedRepaidDebtTokenAmount - actualRepaidDebtTokenAmount;\n            debtToken.safeTransfer(caller, unusedDebtTokenAmount);\n            emit LeftoverDebtTokensTransferred(address(debtToken), unusedDebtTokenAmount, caller);\n        }\n\n        return (withdrawnCollateralTokenAmount, actualRepaidDebtTokenAmount);\n    }\n\n    /* Withdrawal fee */\n\n    /**\n     * @notice Sets the withdrawal fee in basis points\n     * @dev Only callable by the contract owner\n     * @param newWithdrawalFeeBps The new withdrawal fee in basis points\n     */\n    function setWithdrawalFeeBps(uint256 newWithdrawalFeeBps) public onlyOwner nonReentrant {\n        if (newWithdrawalFeeBps > MAX_WITHDRAWAL_FEE_BPS) {\n            revert WithdrawalFeeIsGreaterThanMaxFee(newWithdrawalFeeBps, MAX_WITHDRAWAL_FEE_BPS);\n        }\n        uint256 oldWithdrawalFeeBps = withdrawalFeeBps;\n        withdrawalFeeBps = newWithdrawalFeeBps;\n        emit WithdrawalFeeBpsSet(oldWithdrawalFeeBps, newWithdrawalFeeBps);\n    }\n\n    /* Rebalance */\n\n    /**\n     * @notice Increases the leverage of the user by supplying collateral token and borrowing more debt token\n     * @dev Requires spending collateral token from the user's wallet to supply to the pool.\n     *      Will send the borrowed debt token to the user's wallet.\n     * @param inputCollateralTokenAmount The amount of collateral token to deposit\n     * @param minReceivedDebtTokenAmount The minimum amount of debt token to receive\n     */\n    function increaseLeverage(\n        uint256 inputCollateralTokenAmount,\n        uint256 minReceivedDebtTokenAmount\n    ) public nonReentrant {\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - Assume that the price of WETH is 2000 dUSD\n         * - The current leverage is 1.25x\n         *   - Total collateral: 100 WETH (100 * 2000 = 200,000 dUSD)\n         *   - Total debt: 40,000 dUSD\n         *   - Leverage: 200,000 / (200,000 - 40,000) = 1.25x\n         *   - Assume that there is 0 collateral token in the vault\n         *\n         * 1. User call increaseLeverage with 50 WETH\n         * 2. The vault transfers 50 WETH from the user's wallet to the vault\n         * 3. The vault supplies 50 WETH to the lending pool\n         * 4. The vault borrows 100,000 dUSD (50 * 2000) from the lending pool\n         * 5. The vault sends 100,000 dUSD to the user\n         *\n         * The current leverage is now increased:\n         *    - Total collateral: 150 WETH (150 * 2000 = 300,000 dUSD)\n         *    - Total debt: 140,000 dUSD\n         *    - Leverage: 300,000 / (300,000 - 140,000) = 1.875x\n         */\n\n        // Make sure only increase the leverage if it is below the target leverage\n        uint256 currentLeverageBpsBeforeIncreaseLeverage = getCurrentLeverageBps();\n        if (currentLeverageBpsBeforeIncreaseLeverage >= targetLeverageBps) {\n            revert LeverageExceedsTarget(currentLeverageBpsBeforeIncreaseLeverage, targetLeverageBps);\n        }\n\n        // Get the amount of debt token to borrow to increase the leverage, given the input collateral token amount\n        uint256 borrowedDebtTokenAmount = DLoopCoreLogic.getDebtBorrowTokenAmountToIncreaseLeverage(\n            inputCollateralTokenAmount,\n            getCurrentSubsidyBps(),\n            ERC20(collateralToken).decimals(),\n            getAssetPriceFromOracle(address(collateralToken)),\n            ERC20(debtToken).decimals(),\n            getAssetPriceFromOracle(address(debtToken))\n        );\n\n        // Transfer the input collateral token from the caller to the vault\n        collateralToken.safeTransferFrom(msg.sender, address(this), inputCollateralTokenAmount);\n\n        // Supply the collateral token to the lending pool\n        uint256 actualSuppliedCollateralTokenAmount = _supplyToPool(\n            address(collateralToken),\n            inputCollateralTokenAmount,\n            address(this)\n        );\n\n        // At this step, the _borrowFromPool wrapper function will also assert that\n        // the borrowed amount is exactly the amount requested, thus we can safely\n        // have the slippage check before calling this function\n        // Update the debt token amount borrowed to the actual amount\n        uint256 actualBorrowedDebtTokenAmount = _borrowFromPool(\n            address(debtToken),\n            borrowedDebtTokenAmount,\n            address(this)\n        );\n\n        // Slippage protection, to make sure the user receives at least minReceivedDebtTokenAmount\n        // At this step, we check against the actual amount borrowed from the pool\n        if (actualBorrowedDebtTokenAmount < minReceivedDebtTokenAmount) {\n            revert IncreaseLeverageReceiveLessThanMinAmount(actualBorrowedDebtTokenAmount, minReceivedDebtTokenAmount);\n        }\n\n        // Make sure new current leverage is increased and not above the target leverage\n        uint256 newCurrentLeverageBps = getCurrentLeverageBps();\n        if (\n            newCurrentLeverageBps > targetLeverageBps ||\n            newCurrentLeverageBps <= currentLeverageBpsBeforeIncreaseLeverage\n        ) {\n            revert IncreaseLeverageOutOfRange(\n                newCurrentLeverageBps,\n                targetLeverageBps,\n                currentLeverageBpsBeforeIncreaseLeverage\n            );\n        }\n\n        if (actualBorrowedDebtTokenAmount > 0) {\n            // Transfer the debt token to the user\n            debtToken.safeTransfer(msg.sender, actualBorrowedDebtTokenAmount);\n        }\n\n        emit IncreaseLeverage(\n            msg.sender,\n            inputCollateralTokenAmount,\n            minReceivedDebtTokenAmount,\n            actualSuppliedCollateralTokenAmount, // Supplied collateral token amount\n            actualBorrowedDebtTokenAmount // Borrowed debt token amount\n        );\n    }\n\n    /**\n     * @notice Decreases the leverage of the user by repaying debt and withdrawing collateral\n     * @dev Requires spending debt token from the user's wallet to repay debt to the pool.\n     *      Will send the withdrawn collateral asset to the user's wallet.\n     * @param inputDebtTokenAmount The amount of debt token to repay\n     * @param minReceivedCollateralTokenAmount The minimum amount of collateral asset to receive\n     */\n    function decreaseLeverage(\n        uint256 inputDebtTokenAmount,\n        uint256 minReceivedCollateralTokenAmount\n    ) public nonReentrant {\n        /**\n         * Example of how this function works:\n         *\n         * Suppose that the target leverage is 3x, and the baseLTVAsCollateral is 70%\n         * - The collateral token is WETH\n         * - The debt here is dUSD\n         * - Assume that the price of WETH is 2000 dUSD\n         * - The current leverage is 4x\n         *   - Total collateral: 100 WETH (100 * 2000 = 200,000 dUSD)\n         *   - Total debt: 150,000 dUSD\n         *   - Leverage: 200,000 / (200,000 - 150,000) = 4x\n         *\n         * 1. User call decreaseLeverage with 20,000 dUSD\n         * 2. The vault transfers 20,000 dUSD from the user's wallet to the vault\n         * 3. The vault repays 20,000 dUSD to the lending pool\n         * 4. The vault withdraws 10 WETH (20,000 / 2000) from the lending pool\n         * 5. The vault sends 10 WETH to the user\n         *\n         * The current leverage is now decreased:\n         *    - Total collateral: 90 WETH (90 * 2000 = 180,000 dUSD)\n         *    - Total debt: 130,000 dUSD\n         *    - Leverage: 180,000 / (180,000 - 130,000) = 3.6x\n         */\n\n        // Make sure only decrease the leverage if it is above the target leverage\n        uint256 currentLeverageBps = getCurrentLeverageBps();\n        if (currentLeverageBps <= targetLeverageBps) {\n            revert LeverageBelowTarget(currentLeverageBps, targetLeverageBps);\n        }\n\n        // Get the amount of collateral token to withdraw to decrease the leverage, given the input debt token amount\n        uint256 withdrawnCollateralTokenAmount = DLoopCoreLogic.getCollateralWithdrawTokenAmountToDecreaseLeverage(\n            inputDebtTokenAmount,\n            getCurrentSubsidyBps(),\n            ERC20(collateralToken).decimals(),\n            getAssetPriceFromOracle(address(collateralToken)),\n            ERC20(debtToken).decimals(),\n            getAssetPriceFromOracle(address(debtToken))\n        );\n\n        // Transfer the additional debt token from the caller to the vault\n        debtToken.safeTransferFrom(msg.sender, address(this), inputDebtTokenAmount);\n\n        // Repay the debt token to the lending pool\n        _repayDebtToPool(address(debtToken), inputDebtTokenAmount, address(this));\n\n        // At this step, the _withdrawFromPool wrapper function will also assert that\n        // the withdrawn amount is exactly the amount requested, thus we can safely\n        // have the slippage check before calling this function\n        // Update the withdrawn collateral token amount to the actual amount\n        uint256 actualWithdrawnCollateralTokenAmount = _withdrawFromPool(\n            address(collateralToken),\n            withdrawnCollateralTokenAmount,\n            address(this)\n        );\n\n        // Slippage protection, to make sure the user receives at least minReceivedAmount\n        // At this step, we check against the actual amount withdrawn from the pool\n        if (actualWithdrawnCollateralTokenAmount < minReceivedCollateralTokenAmount) {\n            revert DecreaseLeverageReceiveLessThanMinAmount(\n                actualWithdrawnCollateralTokenAmount,\n                minReceivedCollateralTokenAmount\n            );\n        }\n\n        // Make sure new current leverage is decreased and not below the target leverage\n        uint256 newCurrentLeverageBps = getCurrentLeverageBps();\n        if (newCurrentLeverageBps < targetLeverageBps || newCurrentLeverageBps >= currentLeverageBps) {\n            revert DecreaseLeverageOutOfRange(newCurrentLeverageBps, targetLeverageBps, currentLeverageBps);\n        }\n\n        if (actualWithdrawnCollateralTokenAmount > 0) {\n            // Transfer the collateral asset to the user\n            collateralToken.safeTransfer(msg.sender, actualWithdrawnCollateralTokenAmount);\n        }\n\n        emit DecreaseLeverage(\n            msg.sender,\n            inputDebtTokenAmount,\n            minReceivedCollateralTokenAmount,\n            inputDebtTokenAmount, // Repaid debt token amount\n            actualWithdrawnCollateralTokenAmount // Withdrawn collateral token amount\n        );\n    }\n\n    /* Informational */\n\n    /**\n     * @notice Gets the current leverage in basis points\n     * @dev Calculates leverage based on total collateral and debt values\n     * @return uint256 The current leverage in basis points\n     */\n    function getCurrentLeverageBps() public view returns (uint256) {\n        (uint256 totalCollateralBase, uint256 totalDebtBase) = getTotalCollateralAndDebtOfUserInBase(address(this));\n\n        return DLoopCoreLogic.getCurrentLeverageBps(totalCollateralBase, totalDebtBase);\n    }\n\n    /**\n     * @notice Gets the current subsidy in basis points\n     * @dev Calculates subsidy based on leverage deviation from target\n     * @return uint256 The current subsidy in basis points\n     */\n    function getCurrentSubsidyBps() public view returns (uint256) {\n        return\n            DLoopCoreLogic.getCurrentSubsidyBps(\n                getCurrentLeverageBps(),\n                targetLeverageBps,\n                maxSubsidyBps,\n                minDeviationBps\n            );\n    }\n\n    /**\n     * @notice Gets the address of the collateral token\n     * @return address The address of the collateral token\n     */\n    function getCollateralTokenAddress() public view returns (address) {\n        return address(collateralToken);\n    }\n\n    /**\n     * @notice Gets the address of the debt token\n     * @return address The address of the debt token\n     */\n    function getDebtTokenAddress() public view returns (address) {\n        return address(debtToken);\n    }\n\n    /**\n     * @notice Gets the default maximum subsidy in basis points\n     * @return uint256 The default maximum subsidy in basis points\n     */\n    function getDefaultMaxSubsidyBps() public view returns (uint256) {\n        return maxSubsidyBps;\n    }\n\n    /* Admin */\n\n    /**\n     * @notice Sets the maximum subsidy in basis points\n     * @dev Only callable by the contract owner\n     * @param _maxSubsidyBps New maximum subsidy in basis points\n     */\n    function setMaxSubsidyBps(uint256 _maxSubsidyBps) public onlyOwner nonReentrant {\n        uint256 oldMaxSubsidyBps = maxSubsidyBps;\n        maxSubsidyBps = _maxSubsidyBps;\n        emit MaxSubsidyBpsSet(oldMaxSubsidyBps, _maxSubsidyBps);\n    }\n\n    /**\n     * @notice Sets the minimum deviation of leverage from the target leverage in basis points\n     * @dev Only callable by the contract owner\n     * @param _minDeviationBps New minimum deviation of leverage from the target leverage in basis points\n     */\n    function setMinDeviationBps(uint256 _minDeviationBps) public onlyOwner nonReentrant {\n        uint256 oldMinDeviationBps = minDeviationBps;\n        minDeviationBps = _minDeviationBps;\n        emit MinDeviationBpsSet(oldMinDeviationBps, _minDeviationBps);\n    }\n\n    /**\n     * @dev Sets the lower and upper bounds of target leverage\n     * @param _lowerBoundTargetLeverageBps New lower bound of target leverage in basis points\n     * @param _upperBoundTargetLeverageBps New upper bound of target leverage in basis points\n     */\n    function setLeverageBounds(\n        uint32 _lowerBoundTargetLeverageBps,\n        uint32 _upperBoundTargetLeverageBps\n    ) public onlyOwner nonReentrant {\n        if (_lowerBoundTargetLeverageBps >= targetLeverageBps || targetLeverageBps >= _upperBoundTargetLeverageBps) {\n            revert InvalidLeverageBounds(_lowerBoundTargetLeverageBps, targetLeverageBps, _upperBoundTargetLeverageBps);\n        }\n\n        lowerBoundTargetLeverageBps = _lowerBoundTargetLeverageBps;\n        upperBoundTargetLeverageBps = _upperBoundTargetLeverageBps;\n\n        emit LeverageBoundsSet(_lowerBoundTargetLeverageBps, _upperBoundTargetLeverageBps);\n    }\n\n    /* Overrides to add leverage check */\n\n    /**\n     * @dev See {IERC4626-maxDeposit}.\n     */\n    function maxDeposit(address _user) public view override returns (uint256) {\n        // Don't allow deposit if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        return super.maxDeposit(_user);\n    }\n\n    /**\n     * @dev See {IERC4626-maxMint}.\n     */\n    function maxMint(address _user) public view override returns (uint256) {\n        // Don't allow mint if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        return super.maxMint(_user);\n    }\n\n    /**\n     * @dev See {IERC4626-maxWithdraw}.\n     */\n    function maxWithdraw(address _user) public view override returns (uint256) {\n        // Don't allow withdraw if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        // Return the maximum NET assets after fee\n        return DLoopCoreLogic.getNetAmountAfterFee(super.maxWithdraw(_user), withdrawalFeeBps);\n    }\n\n    /**\n     * @dev See {IERC4626-maxRedeem}.\n     */\n    function maxRedeem(address _user) public view override returns (uint256) {\n        // Don't allow redeem if the leverage is too imbalanced\n        if (isTooImbalanced()) {\n            return 0;\n        }\n        // Fee applies on assets, not on shares. Max redeemable shares remain unchanged.\n        return super.maxRedeem(_user);\n    }\n\n    /**\n     * @dev See {IERC4626-previewWithdraw}.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return super.previewWithdraw(DLoopCoreLogic.getGrossAmountRequiredForNet(assets, withdrawalFeeBps));\n    }\n\n    /**\n     * @dev See {IERC4626-previewRedeem}.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return DLoopCoreLogic.getNetAmountAfterFee(super.previewRedeem(shares), withdrawalFeeBps);\n    }\n}\n"
    },
    "contracts/vaults/dloop/core/DLoopCoreLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport { BasisPointConstants } from \"contracts/common/BasisPointConstants.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { Compare } from \"contracts/common/Compare.sol\";\n\n/**\n * This library contains the stateless implementation of the DLoopCore logic\n */\nlibrary DLoopCoreLogic {\n    error CollateralLessThanDebt(uint256 totalCollateralBase, uint256 totalDebtBase);\n    error InvalidLeverage(uint256 leverageBps);\n    error TotalCollateralBaseIsZero();\n    error TotalCollateralBaseIsLessThanTotalDebtBase(uint256 totalCollateralBase, uint256 totalDebtBase);\n    error InputCollateralTokenAmountIsZero();\n    error InputDebtTokenAmountIsZero();\n    error InvalidWithdrawalFeeBps(uint256 withdrawalFeeBps);\n    error DenominatorIsZero(uint256 expectedTargetLeverageBps, uint256 totalCollateralBase, uint256 totalDebtBase);\n    error FailedGettingCollateralTokenDepositAmount(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase\n    );\n    error FailedGettingDebtTokenRepayAmountNumerator(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase\n    );\n    error FailedGettingDebtTokenRepayAmountDenominator(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase\n    );\n\n    /**\n     * @dev Gets the current leverage in basis points\n     * @param totalCollateralBase The total collateral in base currency\n     * @param totalDebtBase The total debt in base currency\n     * @return uint256 The current leverage in basis points\n     */\n    function getCurrentLeverageBps(uint256 totalCollateralBase, uint256 totalDebtBase) internal pure returns (uint256) {\n        if (totalCollateralBase < totalDebtBase) {\n            revert CollateralLessThanDebt(totalCollateralBase, totalDebtBase);\n        }\n        if (totalCollateralBase == 0) {\n            return 0;\n        }\n        if (totalCollateralBase == totalDebtBase) {\n            return type(uint256).max; // infinite leverage\n        }\n        // The leverage will be 1 if totalDebtBase is 0 (no more debt)\n        // In this case, totalCollateralBase > totalDebtBase, thus the denominator is always positive\n        uint256 leverageBps = ((totalCollateralBase * BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) /\n            (totalCollateralBase - totalDebtBase));\n        if (leverageBps < BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert InvalidLeverage(leverageBps);\n        }\n        return leverageBps;\n    }\n\n    /**\n     * @dev Gets the current subsidy in basis points\n     * @param currentLeverageBps The current leverage in basis points\n     * @param targetLeverageBps The target leverage in basis points\n     * @param maxSubsidyBps The maximum subsidy in basis points\n     * @param minDeviationBps The minimum deviation of leverage from the target leverage in basis points\n     * @return uint256 The current subsidy in basis points\n     */\n    function getCurrentSubsidyBps(\n        uint256 currentLeverageBps,\n        uint256 targetLeverageBps,\n        uint256 maxSubsidyBps,\n        uint256 minDeviationBps\n    ) internal pure returns (uint256) {\n        uint256 subsidyBps;\n        if (currentLeverageBps > targetLeverageBps) {\n            uint256 deviationBps = currentLeverageBps - targetLeverageBps;\n            if (deviationBps < minDeviationBps) {\n                return 0;\n            }\n            subsidyBps = Math.mulDiv(deviationBps, BasisPointConstants.ONE_HUNDRED_PERCENT_BPS, targetLeverageBps);\n        } else {\n            uint256 deviationBps = targetLeverageBps - currentLeverageBps;\n            if (deviationBps < minDeviationBps) {\n                return 0;\n            }\n            subsidyBps = Math.mulDiv(deviationBps, BasisPointConstants.ONE_HUNDRED_PERCENT_BPS, targetLeverageBps);\n        }\n        if (subsidyBps > maxSubsidyBps) {\n            return maxSubsidyBps;\n        }\n        return subsidyBps;\n    }\n\n    /**\n     * @dev Converts an amount in base currency to the actual amount in the token\n     * @param amountInBase Amount in base currency\n     * @param tokenDecimals The decimals of the token\n     * @param tokenPriceInBase The price of the token in base currency\n     * @return amountInToken Amount in the token\n     */\n    function convertFromBaseCurrencyToToken(\n        uint256 amountInBase,\n        uint256 tokenDecimals,\n        uint256 tokenPriceInBase\n    ) internal pure returns (uint256) {\n        // The price decimals is cancelled out in the division (as the amount and price are in the same unit)\n        return Math.mulDiv(amountInBase, 10 ** tokenDecimals, tokenPriceInBase);\n    }\n\n    /**\n     * @dev Converts an amount in the token to the actual amount in base currency\n     * @param amountInToken Amount in the token\n     * @param tokenDecimals The decimals of the token\n     * @param tokenPriceInBase The price of the token in base currency\n     * @return amountInBase Amount in base currency\n     */\n    function convertFromTokenAmountToBaseCurrency(\n        uint256 amountInToken,\n        uint256 tokenDecimals,\n        uint256 tokenPriceInBase\n    ) internal pure returns (uint256) {\n        // The token decimals is cancelled out in the division (as the amount and price are in the same unit)\n        return Math.mulDiv(amountInToken, tokenPriceInBase, 10 ** tokenDecimals);\n    }\n\n    /**\n     * @dev Returns whether the current leverage is too imbalanced\n     * @param currentLeverageBps The current leverage in basis points\n     * @param lowerBoundTargetLeverageBps The lower bound of the target leverage in basis points\n     * @param upperBoundTargetLeverageBps The upper bound of the target leverage in basis points\n     * @return bool True if leverage is too imbalanced, false otherwise\n     */\n    function isTooImbalanced(\n        uint256 currentLeverageBps,\n        uint256 lowerBoundTargetLeverageBps,\n        uint256 upperBoundTargetLeverageBps\n    ) internal pure returns (bool) {\n        // If there is no deposit yet, we don't need to rebalance, thus it is not too imbalanced\n        return\n            currentLeverageBps != 0 &&\n            (currentLeverageBps < lowerBoundTargetLeverageBps || currentLeverageBps > upperBoundTargetLeverageBps);\n    }\n\n    /**\n     * @dev Calculates the unleveraged amount of the assets with the current leverage\n     * @param leveragedAssets Amount of leveraged assets\n     * @param leverageBps The leverage in basis points\n     * @return unleveragedAssets Amount of unleveraged assets\n     */\n    function getUnleveragedAssetsWithLeverage(\n        uint256 leveragedAssets,\n        uint256 leverageBps\n    ) internal pure returns (uint256) {\n        return Math.mulDiv(leveragedAssets, BasisPointConstants.ONE_HUNDRED_PERCENT_BPS, leverageBps);\n    }\n\n    /**\n     * @dev Calculates the leveraged amount of the assets with the target leverage\n     * @param assets Amount of assets\n     * @param leverageBps The leverage in basis points\n     * @return leveragedAssets Amount of leveraged assets\n     */\n    function getLeveragedAssetsWithLeverage(uint256 assets, uint256 leverageBps) internal pure returns (uint256) {\n        return Math.mulDiv(assets, leverageBps, BasisPointConstants.ONE_HUNDRED_PERCENT_BPS);\n    }\n\n    /**\n     * @dev Gets the repay amount that keeps the current leverage\n     * @param targetWithdrawAmount The target withdraw amount\n     * @param leverageBpsBeforeRepayDebt The leverage in basis points before repaying debt\n     * @param collateralTokenDecimals The decimals of the collateral token\n     * @param collateralTokenPriceInBase The price of the collateral token in base currency\n     * @param debtTokenDecimals The decimals of the debt token\n     * @param debtTokenPriceInBase The price of the debt token in base currency\n     * @return repayAmount The repay amount that keeps the current leverage\n     */\n    function getRepayAmountThatKeepCurrentLeverage(\n        uint256 targetWithdrawAmount,\n        uint256 leverageBpsBeforeRepayDebt,\n        uint256 collateralTokenDecimals,\n        uint256 collateralTokenPriceInBase,\n        uint256 debtTokenDecimals,\n        uint256 debtTokenPriceInBase\n    ) internal pure returns (uint256 repayAmount) {\n        /* Formula definition:\n         * - C1: totalCollateralBase before repay (in base currency)\n         * - D1: totalDebtBase before repay (in base currency)\n         * - C2: totalCollateralBase after repay (in base currency)\n         * - D2: totalDebtBase after repay (in base currency)\n         * - T: target leverage\n         * - x: withdraw amount in base currency\n         * - y: repay amount in base currency\n         *\n         * We have:\n         *        C1 / (C1-D1) = C2 / (C2-D2)\n         *        C2 = C1-x\n         *        D2 = D1-y\n         *        C1 / (C1-D1) = T <=> C1 = (C1-D1) * T <=> C1 = C1*T - D1*T <=> C1*T - C1 = D1*T <=> C1 = D1*T/(T-1)\n         *\n         * Formula expression:\n         *        C1 / (C1-D1) = (C1-x) / (C1-x-D1+y)\n         *    <=> C1 * (C1-x-D1+y) = (C1-x) * (C1-D1)\n         *    <=> C1^2 - C1*x - C1*D1 + C1*y = C1^2 - C1*D1 - C1*x + D1*x\n         *    <=> C1^2 - C1*x - C1*D1 + C1*y = C1^2 - C1*x - C1*D1 + D1*x\n         *    <=> C1*y = x*D1\n         *    <=> y = x*D1 / C1\n         *    <=> y = x*D1 / [D1*T / (T-1)]\n         *    <=> y = x * (T-1)/T\n         *\n         * Suppose that T' = T * ONE_HUNDRED_PERCENT_BPS, then:\n         *\n         *  => T = T' / ONE_HUNDRED_PERCENT_BPS\n         * where T' is the target leverage in basis points unit\n         *\n         * We have:\n         *      y = x * (T-1)/T\n         *  <=> y = x * (T' / ONE_HUNDRED_PERCENT_BPS - 1) / (T' / ONE_HUNDRED_PERCENT_BPS)\n         *  <=> y = x * (T' - ONE_HUNDRED_PERCENT_BPS) / T'\n         */\n\n        // Short-circuit when leverageBpsBeforeRepayDebt == 0\n        if (leverageBpsBeforeRepayDebt == 0) {\n            // no collateral means no debt yet, so nothing to repay\n            return 0;\n        }\n\n        // Convert the target withdraw amount to base\n        uint256 targetWithdrawAmountInBase = convertFromTokenAmountToBaseCurrency(\n            targetWithdrawAmount,\n            collateralTokenDecimals,\n            collateralTokenPriceInBase\n        );\n\n        // Calculate the repay amount in base\n        uint256 repayAmountInBase = Math.mulDiv(\n            targetWithdrawAmountInBase,\n            leverageBpsBeforeRepayDebt - BasisPointConstants.ONE_HUNDRED_PERCENT_BPS,\n            leverageBpsBeforeRepayDebt\n        );\n\n        return convertFromBaseCurrencyToToken(repayAmountInBase, debtTokenDecimals, debtTokenPriceInBase);\n    }\n\n    /**\n     * @dev Gets the borrow amount that keeps the current leverage\n     * @param suppliedCollateralAmount The actual supplied amount of collateral asset\n     * @param leverageBpsBeforeSupply Leverage in basis points before supplying\n     * @param targetLeverageBps The target leverage in basis points\n     * @param collateralTokenDecimals The decimals of the collateral token\n     * @param collateralTokenPriceInBase The price of the collateral token in base currency\n     * @param debtTokenDecimals The decimals of the debt token\n     * @param debtTokenPriceInBase The price of the debt token in base currency\n     * @return expectedBorrowAmount The expected borrow amount that keeps the current leverage\n     */\n    function getBorrowAmountThatKeepCurrentLeverage(\n        uint256 suppliedCollateralAmount,\n        uint256 leverageBpsBeforeSupply,\n        uint256 targetLeverageBps,\n        uint256 collateralTokenDecimals,\n        uint256 collateralTokenPriceInBase,\n        uint256 debtTokenDecimals,\n        uint256 debtTokenPriceInBase\n    ) internal pure returns (uint256 expectedBorrowAmount) {\n        /* Formula definition:\n         * - C1: totalCollateralBase before supply (in base currency)\n         * - D1: totalDebtBase before supply (in base currency)\n         * - C2: totalCollateralBase after supply (in base currency)\n         * - D2: totalDebtBase after supply (in base currency)\n         * - T: target leverage\n         * - x: supply amount in base currency\n         * - y: borrow amount in base currency\n         *\n         * We have:\n         *      C1 / (C1-D1) = C2 / (C2-D2)\n         *      C2 = C1+x\n         *      D2 = D1+y\n         *      C1 / (C1-D1) = T <=> C1 = (C1-D1) * T <=> C1 = C1*T - D1*T <=> C1*T - C1 = D1*T <=> C1 = D1*T/(T-1)\n         *\n         * Formula expression:\n         *      C1 / (C1-D1) = (C1+x) / (C1+x-D1-y)\n         *  <=> C1 * (C1+x-D1-y) = (C1+x) * (C1-D1)\n         *  <=> C1^2 + C1*x - C1*D1 - C1*y = C1^2 - C1*D1 + C1*x - D1*x\n         *  <=> C1*y = x*D1\n         *  <=> y = x*D1 / C1\n         *  <=> y = x * (T-1)/T\n         *\n         * Suppose that:\n         *      T' = T * ONE_HUNDRED_PERCENT_BPS, then:\n         *   => T = T' / ONE_HUNDRED_PERCENT_BPS\n         * where:\n         *      - T' is the target leverage in basis points unit\n         *\n         * This is the formula to calculate the borrow amount that keeps the current leverage:\n         *      y = x * (T-1)/T\n         *  <=> y = x * (T' / ONE_HUNDRED_PERCENT_BPS - 1) / (T' / ONE_HUNDRED_PERCENT_BPS)\n         *  <=> y = x * (T' - ONE_HUNDRED_PERCENT_BPS) / T'\n         */\n\n        if (leverageBpsBeforeSupply == 0) {\n            // This is the case when there is no deposit yet, so we use the target leverage\n            leverageBpsBeforeSupply = targetLeverageBps;\n        }\n\n        // Convert the actual supplied amount to base\n        uint256 suppliedCollateralAmountInBase = convertFromTokenAmountToBaseCurrency(\n            suppliedCollateralAmount,\n            collateralTokenDecimals,\n            collateralTokenPriceInBase\n        );\n\n        // Calculate the borrow amount in base currency that keeps the current leverage\n        uint256 borrowAmountInBase = Math.mulDiv(\n            suppliedCollateralAmountInBase,\n            leverageBpsBeforeSupply - BasisPointConstants.ONE_HUNDRED_PERCENT_BPS,\n            leverageBpsBeforeSupply\n        );\n\n        return convertFromBaseCurrencyToToken(borrowAmountInBase, debtTokenDecimals, debtTokenPriceInBase);\n    }\n\n    /**\n     * @dev Gets the collateral token amount to reach the target leverage\n     *      - This method is only being called for increasing the leverage quote in quoteRebalanceAmountToReachTargetLeverage()\n     *      - It will failed if the current leverage is above the target leverage (which requires the user to call decreaseLeverage)\n     * @param expectedTargetLeverageBps The expected target leverage in basis points unit\n     * @param totalCollateralBase The total collateral base\n     * @param totalDebtBase The total debt base\n     * @param subsidyBps The subsidy in basis points unit\n     * @return requiredCollateralDepositAmountInBase The collateral deposit amount in base currency\n     */\n    function getCollateralTokenDepositAmountToReachTargetLeverage(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 subsidyBps\n    ) internal pure returns (uint256 requiredCollateralDepositAmountInBase) {\n        /**\n         * Find the amount of collateral to be deposited and the corresponding amount of debt token to be borrowed to rebalance\n         *\n         * The amount of debt token to be borrowed is a bit more than the deposited collateral to pay for the rebalancing subsidy\n         * - Rebalancing caller will receive the debt token as the subsidy\n         *\n         * Formula definition:\n         * - C: totalCollateralBase\n         * - D: totalDebtBase\n         * - T: target leverage\n         * - k: subsidy (0.01 means 1%)\n         * - x: change amount of collateral in base currency\n         * - y: change amount of debt in base currency\n         *\n         * We have:\n         *      y = x*(1+k)   (borrow a bit more debt than the deposited collateral to pay for the rebalancing subsidy)\n         *\n         * Because this is a deposit collateral and borrow debt process, the formula is:\n         *      (C + x) / (C + x - D - y) = T\n         *  <=> C + x = T * (C + x - D - y)\n         *  <=> C + x = T * (C + x - D - x*(1+k))\n         *  <=> C + x = T * (C + x - D - x - x*k)\n         *  <=> C + x = T * (C - D - x*k)\n         *  <=> C + x = T*C - T*D - T*x*k\n         *  <=> x + T*x*k = T*C - T*D - C\n         *  <=> x*(1 + T*k) = T*(C - D) - C\n         *  <=> x = (T*(C - D) - C) / (1 + T*k)\n         *\n         * Suppose that:\n         *      TT = T * ONE_HUNDRED_PERCENT_BPS\n         *      kk = k * ONE_HUNDRED_PERCENT_BPS\n         * then:\n         *      T = TT / ONE_HUNDRED_PERCENT_BPS\n         *      k = kk / ONE_HUNDRED_PERCENT_BPS\n         * where:\n         *      - TT is the target leverage in basis points unit\n         *      - kk is the subsidy in basis points unit\n         *\n         * We have:\n         *      x = (T*(C - D) - C) / (1 + T*k)\n         *  <=> x = (TT*(C - D)/ONE_HUNDRED_PERCENT_BPS - C) / (1 + TT*kk/ONE_HUNDRED_PERCENT_BPS^2)\n         *  <=> x = (TT*(C - D) - C*ONE_HUNDRED_PERCENT_BPS) / (ONE_HUNDRED_PERCENT_BPS + TT*kk/ONE_HUNDRED_PERCENT_BPS)\n         *  <=> x = (TT*(C - D) - C*ONE_HUNDRED_PERCENT_BPS) / denominator\n         * where:\n         *      denominator = ONE_HUNDRED_PERCENT_BPS + TT*kk/ONE_HUNDRED_PERCENT_BPS\n         *\n         * If x < 0, the transaction will be reverted due to the underflow/overflow\n         *\n         * If x = 0, it means the user should not rebalance, so the direction is 0\n         *\n         * Finally, we have y = (1+k)*x:\n         *   => y = (1+k) * x\n         *  <=> y = (1 + kk/ONE_HUNDRED_PERCENT_BPS) * x\n         *  <=> y = (ONE_HUNDRED_PERCENT_BPS + kk) * x / ONE_HUNDRED_PERCENT_BPS\n         *\n         * The value of y here is for reference (the expected amount of debt to borrow)\n         */\n        if (totalCollateralBase == 0) {\n            revert TotalCollateralBaseIsZero();\n        }\n        if (totalCollateralBase < totalDebtBase) {\n            revert TotalCollateralBaseIsLessThanTotalDebtBase(totalCollateralBase, totalDebtBase);\n        }\n\n        // Now, totalCollateralBase is guaranteed to be greater than totalDebtBase\n        // Use trySub to avoid overflow/underflow\n        (bool success, uint256 numerator) = Math.trySub(\n            expectedTargetLeverageBps * (totalCollateralBase - totalDebtBase),\n            totalCollateralBase * BasisPointConstants.ONE_HUNDRED_PERCENT_BPS\n        );\n        if (!success) {\n            revert FailedGettingCollateralTokenDepositAmount(\n                expectedTargetLeverageBps,\n                totalCollateralBase,\n                totalDebtBase\n            );\n        }\n\n        uint256 denominator = BasisPointConstants.ONE_HUNDRED_PERCENT_BPS +\n            Math.mulDiv(expectedTargetLeverageBps, subsidyBps, BasisPointConstants.ONE_HUNDRED_PERCENT_BPS);\n\n        // Use ceilDiv as we want to round up required collateral deposit amount in base currency\n        // to avoid getting the new leverage above the target leverage, which will revert the\n        // rebalance process (due to post-process assertion)\n        // The logic is to deposit a bit more collateral, and borrow a bit more debt (due to rounding),\n        // which will guarantee the new leverage cannot be more than the target leverage, avoid\n        // unexpected post-process assertion revert.\n        // This denominator cannot be zero because it is equal to: 100% + x\n        // where is x is uint256, thus is always >= 100%, thus is always positive\n        requiredCollateralDepositAmountInBase = Math.ceilDiv(numerator, denominator);\n\n        return requiredCollateralDepositAmountInBase;\n    }\n\n    /**\n     * @dev Gets the debt amount in base currency to be borrowed to increase the leverage\n     * @param inputCollateralDepositAmountInBase The collateral deposit amount in base currency\n     * @param subsidyBps The subsidy in basis points unit\n     * @return outputDebtBorrowAmountInBase The debt amount in base currency to be borrowed\n     */\n    function getDebtBorrowAmountInBaseToIncreaseLeverage(\n        uint256 inputCollateralDepositAmountInBase,\n        uint256 subsidyBps\n    ) internal pure returns (uint256 outputDebtBorrowAmountInBase) {\n        /**\n         * The formula is:\n         *      y = (1+k) * x\n         *  <=> y = (1 + kk/ONE_HUNDRED_PERCENT_BPS) * x\n         *  <=> y = (ONE_HUNDRED_PERCENT_BPS + kk) * x / ONE_HUNDRED_PERCENT_BPS\n         *\n         * where:\n         *      - y is the debt amount in base currency to be borrowed\n         *      - x is the collateral amount in base currency to be deposited\n         *      - kk is the subsidy in basis points unit\n         */\n\n        // Use rounding down with mulDiv with Rounding.Floor as we want to borrow a bit less, to avoid\n        // getting the new leverage above the target leverage, which will revert the\n        // rebalance process (due to post-process assertion)\n        // Borrow a bit less debt (rounding), given the same deposit amount of collateral token\n        // means the new leverage should be lower than the actual leverage (with decimal without rounding)\n        // As we calculate the estimated final leverage is reaching the target leverage,\n        // if we round up, the new leverage can be more than the target leverage (given\n        // the same deposit amount of collateral token), which will revert the rebalance process (due to post-process assertion)\n        return\n            Math.mulDiv(\n                inputCollateralDepositAmountInBase,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS + subsidyBps,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS,\n                Math.Rounding.Floor\n            );\n    }\n\n    /**\n     * @dev Gets the debt token amount to be borrowed to increase the leverage, given the input collateral token amount\n     * @param inputCollateralDepositTokenAmount The collateral deposit amount in token unit\n     * @param subsidyBps The subsidy in basis points unit\n     * @param collateralTokenDecimals The collateral token decimals\n     * @param collateralTokenPriceInBase The collateral token price in base currency\n     * @param debtTokenDecimals The debt token decimals\n     * @param debtTokenPriceInBase The debt token price in base currency\n     * @return outputDebtBorrowTokenAmount The debt token amount to be borrowed in token unit\n     */\n    function getDebtBorrowTokenAmountToIncreaseLeverage(\n        uint256 inputCollateralDepositTokenAmount,\n        uint256 subsidyBps,\n        uint256 collateralTokenDecimals,\n        uint256 collateralTokenPriceInBase,\n        uint256 debtTokenDecimals,\n        uint256 debtTokenPriceInBase\n    ) internal pure returns (uint256 outputDebtBorrowTokenAmount) {\n        // Make sure the input collateral token amount is not zero\n        if (inputCollateralDepositTokenAmount == 0) {\n            revert InputCollateralTokenAmountIsZero();\n        }\n\n        // Calculate everything before transferring, supplying and borrowing to avoid\n        // any potential impact from the child contract implementation\n\n        // Calculate the amount of collateral token in base currency to deposit\n        uint256 inputCollateralDepositAmountInBase = convertFromTokenAmountToBaseCurrency(\n            inputCollateralDepositTokenAmount,\n            collateralTokenDecimals,\n            collateralTokenPriceInBase\n        );\n\n        // The amount of debt token to borrow is equal to the amount of collateral token deposited\n        // plus the subsidy (bonus for the caller)\n        uint256 borrowedDebtTokenInBase = getDebtBorrowAmountInBaseToIncreaseLeverage(\n            inputCollateralDepositAmountInBase,\n            subsidyBps\n        );\n\n        // Convert the amount of debt token in base currency to token unit\n        outputDebtBorrowTokenAmount = convertFromBaseCurrencyToToken(\n            borrowedDebtTokenInBase,\n            debtTokenDecimals,\n            debtTokenPriceInBase\n        );\n\n        return outputDebtBorrowTokenAmount;\n    }\n\n    /**\n     * @dev Gets the debt amount in base currency to reach the target leverage\n     *      - This method is only being called for decreasing the leverage quote in quoteRebalanceAmountToReachTargetLeverage()\n     *      - It will failed if the current leverage is below the target leverage (which requires the user to call increaseLeverage)\n     * @param expectedTargetLeverageBps The expected target leverage in basis points unit\n     * @param totalCollateralBase The total collateral base\n     * @param totalDebtBase The total debt base\n     * @param subsidyBps The subsidy in basis points unit\n     * @return requiredDebtRepayAmountInBase The debt amount in base currency to be repaid\n     */\n    function getDebtRepayAmountInBaseToReachTargetLeverage(\n        uint256 expectedTargetLeverageBps,\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 subsidyBps\n    ) internal pure returns (uint256 requiredDebtRepayAmountInBase) {\n        /**\n         * Find the amount of debt to be repaid and the corresponding amount of collateral to be withdraw to rebalance\n         *\n         * The amount of collateral to be withdraw to rebalance which is a bit more than the repay amount of debt token\n         * to pay for the rebalancing subsidy\n         * - Rebalancing caller will receive the collateral token as the subsidy\n         *\n         * Formula definition:\n         * - C: totalCollateralBase\n         * - D: totalDebtBase\n         * - T: target leverage\n         * - k: subsidy (0.01 means 1%)\n         * - x: change amount of collateral in base currency\n         * - y: change amount of debt in base currency\n         *\n         * We have:\n         *      x = y*(1+k)   (withdraw a bit more collateral than the debt to pay for the rebalancing subsidy)\n         *\n         * Because this is a repay debt and withdraw collateral process, the formula is:\n         *      (C - x) / (C - x - D + y) = T\n         *  <=> C - y*(1+k) = T * (C - y*(1+k) - D + y)\n         *  <=> C - y*(1+k) = T * (C - y - y*k - D + y)\n         *  <=> C - y*(1+k) = T * (C - D - y*k)\n         *  <=> y*(1+k) = C - T * (C - D - y*k)\n         *  <=> y*(1+k) = C - T*C + T*D + T*y*k\n         *  <=> y*(1+k) - T*y*k = C - T*C + T*D\n         *  <=> y*(1 + k - T*k) = C - T*C + T*D\n         *  <=> y = (C - T*C + T*D) / (1 + k - T*k)\n         *\n         * Suppose that:\n         *      TT = T * ONE_HUNDRED_PERCENT_BPS\n         *      kk = k * ONE_HUNDRED_PERCENT_BPS\n         * then:\n         *      T = TT / ONE_HUNDRED_PERCENT_BPS\n         *      k = kk / ONE_HUNDRED_PERCENT_BPS\n         * where:\n         *      - TT is the target leverage in basis points unit\n         *      - kk is the subsidy in basis points unit\n         *\n         * We have:\n         *      y = (C - T*C + T*D) / (1 + k - T*k)\n         *  <=> y = (C - TT*C/ONE_HUNDRED_PERCENT_BPS + TT*D/ONE_HUNDRED_PERCENT_BPS) / (1 + kk/ONE_HUNDRED_PERCENT_BPS - TT*kk/ONE_HUNDRED_PERCENT_BPS^2)\n         *  <=> y = (C*ONE_HUNDRED_PERCENT_BPS - TT*C + TT*D) / (ONE_HUNDRED_PERCENT_BPS + kk - TT*kk/ONE_HUNDRED_PERCENT_BPS)\n         *  <=> y = (C*ONE_HUNDRED_PERCENT_BPS - TT*C + TT*D) / denominator\n         *  <=> y = (C*ONE_HUNDRED_PERCENT_BPS - TT*(C - D)) / denominator\n         * where:\n         *      denominator = ONE_HUNDRED_PERCENT_BPS + kk - TT*kk/ONE_HUNDRED_PERCENT_BPS\n         *\n         * If y < 0, the transaction will be reverted due to the underflow/overflow\n         *\n         * If y = 0, it means the user should not rebalance, so the direction is 0\n         *\n         * Finally, we have x = (1+k)*y:\n         *   => x = (1+k) * y\n         *  <=> x = (1 + kk/ONE_HUNDRED_PERCENT_BPS) * y\n         *  <=> x = (ONE_HUNDRED_PERCENT_BPS + kk) * y / ONE_HUNDRED_PERCENT_BPS\n         *\n         * The value of x here is for reference (the expected amount of collateral to withdraw)\n         */\n        if (totalCollateralBase == 0) {\n            revert TotalCollateralBaseIsZero();\n        }\n        if (totalCollateralBase < totalDebtBase) {\n            revert TotalCollateralBaseIsLessThanTotalDebtBase(totalCollateralBase, totalDebtBase);\n        }\n\n        // Now, totalCollateralBase is greater than totalDebtBase, thus: totalCollateralBase - totalDebtBase > 0\n        // Use trySub to avoid overflow/underflow\n        (bool successNumerator, uint256 numerator) = Math.trySub(\n            totalCollateralBase * BasisPointConstants.ONE_HUNDRED_PERCENT_BPS,\n            expectedTargetLeverageBps * (totalCollateralBase - totalDebtBase)\n        );\n        if (!successNumerator) {\n            revert FailedGettingDebtTokenRepayAmountNumerator(\n                expectedTargetLeverageBps,\n                totalCollateralBase,\n                totalDebtBase\n            );\n        }\n\n        (bool successDenominator, uint256 denominator) = Math.trySub(\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS + subsidyBps,\n            Math.mulDiv(expectedTargetLeverageBps, subsidyBps, BasisPointConstants.ONE_HUNDRED_PERCENT_BPS)\n        );\n        if (!successDenominator) {\n            revert FailedGettingDebtTokenRepayAmountDenominator(\n                expectedTargetLeverageBps,\n                totalCollateralBase,\n                totalDebtBase\n            );\n        }\n\n        if (denominator == 0) {\n            revert DenominatorIsZero(expectedTargetLeverageBps, totalCollateralBase, totalDebtBase);\n        }\n\n        // Do not use ceilDiv as we want to round down required debt repay amount in base currency\n        // to avoid getting the new leverage below the target leverage, which will revert the\n        // rebalance process (due to post-process assertion)\n        // The logic is to repay a bit less, and withdraw a bit more collateral (due to rounding),\n        // which will guarantee the new leverage cannot be less than the target leverage, avoid\n        // unexpected post-process assertion revert.\n        requiredDebtRepayAmountInBase = numerator / denominator;\n\n        return requiredDebtRepayAmountInBase;\n    }\n\n    /**\n     * @dev Gets the collateral token amount to be withdraw to repay the debt token\n     * @param inputDebtRepayAmountInBase The debt amount in base currency to be repaid\n     * @param subsidyBps The subsidy in basis points unit\n     * @return outputCollateralTokenAmount The collateral token amount to be withdraw\n     */\n    function getCollateralWithdrawAmountInBaseToDecreaseLeverage(\n        uint256 inputDebtRepayAmountInBase,\n        uint256 subsidyBps\n    ) internal pure returns (uint256 outputCollateralTokenAmount) {\n        /**\n         * The formula is:\n         *      x = (1+k) * y\n         *  <=> x = (1 + kk/ONE_HUNDRED_PERCENT_BPS) * y\n         *  <=> x = (ONE_HUNDRED_PERCENT_BPS + kk) * y / ONE_HUNDRED_PERCENT_BPS\n         *\n         * where:\n         *      - x is the collateral amount in base currency to be withdraw\n         *      - y is the debt amount in base currency to be repaid\n         *      - kk is the subsidy in basis points unit\n         */\n\n        // Use rounding up with mulDiv with Rounding.Ceil as we want to withdraw a bit more, to avoid\n        // getting the new leverage below the target leverage, which will revert the\n        // rebalance process (due to post-process assertion)\n        // Withdraw a bit more collateral (rounding), given the same repay amount of debt token\n        // means the new leverage should be higher than the actual leverage (with decimal without rounding)\n        // As we calculate the estimated final leverage is reaching the target leverage,\n        // if we round down, the new leverage can be less than the target leverage (given\n        // the same repay amount of debt token), which will revert the rebalance process (due to post-process assertion)\n        return\n            Math.mulDiv(\n                inputDebtRepayAmountInBase,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS + subsidyBps,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS,\n                Math.Rounding.Ceil\n            );\n    }\n\n    /**\n     * @dev Gets the collateral token amount to be withdraw to repay the debt token\n     * @param inputDebtRepayTokenAmount The debt amount in token unit to be repaid\n     * @param subsidyBps The subsidy in basis points unit\n     * @param collateralTokenDecimals The collateral token decimals\n     * @param collateralTokenPriceInBase The collateral token price in base currency\n     * @param debtTokenDecimals The debt token decimals\n     * @param debtTokenPriceInBase The debt token price in base currency\n     * @return outputCollateralWithdrawTokenAmount The collateral token amount to be withdraw in token unit\n     */\n    function getCollateralWithdrawTokenAmountToDecreaseLeverage(\n        uint256 inputDebtRepayTokenAmount,\n        uint256 subsidyBps,\n        uint256 collateralTokenDecimals,\n        uint256 collateralTokenPriceInBase,\n        uint256 debtTokenDecimals,\n        uint256 debtTokenPriceInBase\n    ) internal pure returns (uint256 outputCollateralWithdrawTokenAmount) {\n        // Make sure the input debt token amount is not zero\n        if (inputDebtRepayTokenAmount == 0) {\n            revert InputDebtTokenAmountIsZero();\n        }\n\n        // Calculate everything before transferring, repaying and withdrawing to avoid\n        // any potential impact from the child contract implementation\n\n        // Calculate the amount of debt token in base currency to repay\n        uint256 inputDebtRepayAmountInBase = convertFromTokenAmountToBaseCurrency(\n            inputDebtRepayTokenAmount,\n            debtTokenDecimals,\n            debtTokenPriceInBase\n        );\n\n        // The amount of collateral asset to withdraw is equal to the amount of debt token repaid\n        // plus the subsidy (bonus for the caller)\n        uint256 withdrawCollateralTokenInBase = getCollateralWithdrawAmountInBaseToDecreaseLeverage(\n            inputDebtRepayAmountInBase,\n            subsidyBps\n        );\n\n        // Convert the amount of collateral token in base currency to token unit\n        outputCollateralWithdrawTokenAmount = convertFromBaseCurrencyToToken(\n            withdrawCollateralTokenInBase,\n            collateralTokenDecimals,\n            collateralTokenPriceInBase\n        );\n\n        return outputCollateralWithdrawTokenAmount;\n    }\n\n    /**\n     * @dev Quotes the rebalance amount to reach the target leverage in token unit\n     * @param totalCollateralBase The total collateral base\n     * @param totalDebtBase The total debt base\n     * @param currentLeverageBps The current leverage in basis points unit\n     * @param targetLeverageBps The target leverage in basis points unit\n     * @param subsidyBps The subsidy in basis points unit\n     * @param collateralTokenDecimals The collateral token decimals\n     * @param collateralTokenPriceInBase The collateral token price in base currency\n     * @param debtTokenDecimals The debt token decimals\n     * @param debtTokenPriceInBase The debt token price in base currency\n     * @return inputTokenAmount The amount of token to call increaseLeverage or decreaseLeverage (in token unit)\n     * @return estimatedOutputTokenAmount The estimated output token amount after the rebalance (in token unit)\n     * @return direction The direction of the rebalance (1 for increase, -1 for decrease, 0 means no rebalance)\n     */\n    function quoteRebalanceAmountToReachTargetLeverage(\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 currentLeverageBps,\n        uint256 targetLeverageBps,\n        uint256 subsidyBps,\n        uint256 collateralTokenDecimals,\n        uint256 collateralTokenPriceInBase,\n        uint256 debtTokenDecimals,\n        uint256 debtTokenPriceInBase\n    ) public pure returns (uint256 inputTokenAmount, uint256 estimatedOutputTokenAmount, int8 direction) {\n        if (totalCollateralBase == 0) {\n            // No collateral means no debt and no leverage, so no rebalance is needed\n            return (0, 0, 0);\n        }\n\n        // If the current leverage is below the target leverage, the user should increase the leverage\n        if (currentLeverageBps < targetLeverageBps) {\n            // In this case, the input amount is the collateral amount to be deposit\n            // and the output amount is the debt amount to be borrow\n            uint256 inputCollateralAmountInBase = getCollateralTokenDepositAmountToReachTargetLeverage(\n                targetLeverageBps,\n                totalCollateralBase,\n                totalDebtBase,\n                subsidyBps\n            );\n            inputTokenAmount = convertFromBaseCurrencyToToken(\n                inputCollateralAmountInBase,\n                collateralTokenDecimals,\n                collateralTokenPriceInBase\n            );\n            uint256 estimatedDebtAmountInBase = getDebtBorrowAmountInBaseToIncreaseLeverage(\n                inputCollateralAmountInBase,\n                subsidyBps\n            );\n            estimatedOutputTokenAmount = convertFromBaseCurrencyToToken(\n                estimatedDebtAmountInBase,\n                debtTokenDecimals,\n                debtTokenPriceInBase\n            );\n            direction = 1;\n            return (inputTokenAmount, estimatedOutputTokenAmount, direction);\n        }\n        // If the current leverage is above the target leverage, the user should decrease the leverage\n        else if (currentLeverageBps > targetLeverageBps) {\n            // In this case, the input amount is the debt amount to be repaid\n            // and the output amount is the collateral amount to be withdraw\n            uint256 inputDebtAmountInBase = getDebtRepayAmountInBaseToReachTargetLeverage(\n                targetLeverageBps,\n                totalCollateralBase,\n                totalDebtBase,\n                subsidyBps\n            );\n            inputTokenAmount = convertFromBaseCurrencyToToken(\n                inputDebtAmountInBase,\n                debtTokenDecimals,\n                debtTokenPriceInBase\n            );\n            uint256 estimatedCollateralAmountInBase = getCollateralWithdrawAmountInBaseToDecreaseLeverage(\n                inputDebtAmountInBase,\n                subsidyBps\n            );\n            estimatedOutputTokenAmount = convertFromBaseCurrencyToToken(\n                estimatedCollateralAmountInBase,\n                collateralTokenDecimals,\n                collateralTokenPriceInBase\n            );\n            direction = -1;\n            return (inputTokenAmount, estimatedOutputTokenAmount, direction);\n        }\n\n        // If the current leverage is equal to the target leverage, the user should not rebalance\n        return (0, 0, 0);\n    }\n\n    /**\n     * @dev Gets the gross amount required for a given net amount\n     * @param netAmount The net amount\n     * @param withdrawalFeeBps The withdrawal fee in basis points\n     * @return grossAmount The gross amount\n     */\n    function getGrossAmountRequiredForNet(\n        uint256 netAmount,\n        uint256 withdrawalFeeBps\n    ) internal pure returns (uint256 grossAmount) {\n        if (withdrawalFeeBps > BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert InvalidWithdrawalFeeBps(withdrawalFeeBps);\n        }\n        return\n            Math.mulDiv(\n                netAmount,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS - withdrawalFeeBps\n            );\n    }\n\n    /**\n     * @dev Gets the net amount after fee for a given gross amount\n     * @param grossAmount The gross amount\n     * @param withdrawalFeeBps The withdrawal fee in basis points\n     * @return netAmount The net amount\n     */\n    function getNetAmountAfterFee(\n        uint256 grossAmount,\n        uint256 withdrawalFeeBps\n    ) internal pure returns (uint256 netAmount) {\n        if (withdrawalFeeBps > BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert InvalidWithdrawalFeeBps(withdrawalFeeBps);\n        }\n        return\n            Math.mulDiv(\n                grossAmount,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS - withdrawalFeeBps,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS\n            );\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/DLoopDepositorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport { IERC3156FlashBorrower } from \"./interface/flashloan/IERC3156FlashBorrower.sol\";\nimport { IERC3156FlashLender } from \"./interface/flashloan/IERC3156FlashLender.sol\";\nimport { DLoopCoreBase } from \"../core/DLoopCoreBase.sol\";\nimport { SwappableVault } from \"contracts/common/SwappableVault.sol\";\nimport { RescuableVault } from \"contracts/common/RescuableVault.sol\";\nimport { BasisPointConstants } from \"contracts/common/BasisPointConstants.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SharedLogic } from \"./helper/SharedLogic.sol\";\n\n/**\n * @title DLoopDepositorBase\n * @dev A helper contract for depositing leveraged assets into the core vault with flash loans\n *      - Suppose that the core contract has leverage of 3x, and the collateral token is WETH, debt token is dUSD, price of WETH is 1000, price of dUSD is 2000\n *      - ie, given user has 100 WETH, and wants to deposit 300 WETH, this contract will do a flash loan to get 200 * 2000 dUSD, then swap to get 200 WETH\n *        and then deposit totally 200+100=300 WETH into the core vault, then user receive 300 shares. The contract uses the received 200 * 2000 dUSD\n *        to repay the flash loan.\n *      - In the final state, the user has 300 shares representing 300 WETH, and the core contract has 300 WETH as collateral, 200 dUSD as debt\n *      - NOTE: This contract only support deposit() to DLoopCore contracts, not mint()\n */\nabstract contract DLoopDepositorBase is\n    IERC3156FlashBorrower,\n    Ownable,\n    ReentrancyGuard,\n    SwappableVault,\n    RescuableVault\n{\n    using SafeERC20 for ERC20;\n\n    /* Constants */\n\n    bytes32 public constant FLASHLOAN_CALLBACK = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /* Core state */\n\n    IERC3156FlashLender public immutable flashLender;\n\n    uint256 public breakPoint;\n\n    /* Errors */\n\n    error UnknownLender(address msgSender, address flashLender);\n    error UnknownInitiator(address initiator, address thisContract);\n    error IncompatibleDLoopCoreDebtToken(address currentDebtToken, address dLoopCoreDebtToken);\n    error SharesNotIncreasedAfterFlashLoan(uint256 sharesBeforeDeposit, uint256 sharesAfterDeposit);\n    error DebtTokenBalanceNotIncreasedAfterDeposit(\n        uint256 debtTokenBalanceBeforeDeposit,\n        uint256 debtTokenBalanceAfterDeposit\n    );\n    error ReceivedSharesNotMetMinReceiveAmount(uint256 receivedShares, uint256 minOutputShares);\n    error DebtTokenReceivedNotMetUsedAmountWithFlashLoanFee(\n        uint256 debtTokenReceived,\n        uint256 debtTokenUsed,\n        uint256 flashLoanFee\n    );\n    error LeveragedCollateralAmountLessThanDepositCollateralAmount(\n        uint256 leveragedCollateralAmount,\n        uint256 depositCollateralAmount\n    );\n    error FlashLenderNotSameAsDebtToken(address flashLender, address debtToken);\n    error SlippageBpsCannotExceedOneHundredPercent(uint256 slippageBps);\n\n    /* Events */\n\n    event LeftoverDebtTokensTransferred(address indexed debtToken, uint256 amount, address indexed receiver);\n\n    /* Structs */\n\n    struct FlashLoanParams {\n        address receiver;\n        uint256 depositCollateralAmount;\n        uint256 leveragedCollateralAmount;\n        bytes debtTokenToCollateralSwapData;\n        DLoopCoreBase dLoopCore;\n    }\n\n    /**\n     * @dev Constructor for the DLoopDepositorBase contract\n     * @param _flashLender Address of the flash loan provider\n     */\n    constructor(IERC3156FlashLender _flashLender) Ownable(msg.sender) {\n        flashLender = _flashLender;\n    }\n\n    function setBreakPoint(uint256 _breakPoint) public {\n        breakPoint = _breakPoint;\n    }\n\n    /* RescuableVault Override */\n\n    /**\n     * @dev Gets the restricted rescue tokens\n     * @return restrictedTokens Restricted rescue tokens\n     */\n    function getRestrictedRescueTokens() public view virtual override returns (address[] memory restrictedTokens) {\n        // Return empty array as we no longer handle leftover debt tokens\n        return new address[](0);\n    }\n\n    /* Deposit */\n\n    /**\n     * @dev Calculates the minimum output shares for a given deposit amount and slippage bps\n     * @param depositAmount Amount of collateral token to deposit\n     * @param slippageBps Slippage bps\n     * @param dLoopCore Address of the DLoopCore contract\n     * @return minOutputShares Minimum output shares\n     */\n    function calculateMinOutputShares(\n        uint256 depositAmount,\n        uint256 slippageBps,\n        DLoopCoreBase dLoopCore\n    ) public view returns (uint256) {\n        if (slippageBps > BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert SlippageBpsCannotExceedOneHundredPercent(slippageBps);\n        }\n        uint256 expectedLeveragedAssets = SharedLogic.getLeveragedAssets(depositAmount, dLoopCore);\n        uint256 expectedShares = dLoopCore.convertToShares(expectedLeveragedAssets);\n        return\n            Math.mulDiv(\n                expectedShares,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS - slippageBps,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS\n            );\n    }\n\n    /**\n     * @dev Deposits assets into the core vault with flash loans\n     *      - The required collateral token to reeach the leveraged amount will be flash loaned from the flash lender\n     * @param assets Amount of assets to deposit\n     * @param receiver Address to receive the minted shares\n     * @param minOutputShares Minimum amount of shares to receive (slippage protection)\n     * @param debtTokenToCollateralSwapData Swap data from debt token to collateral token\n     * @param dLoopCore Address of the DLoopCore contract to use\n     * @return shares Amount of shares minted\n     */\n    function deposit(\n        uint256 assets, // deposit amount\n        address receiver,\n        uint256 minOutputShares,\n        bytes calldata debtTokenToCollateralSwapData,\n        DLoopCoreBase dLoopCore\n    ) public nonReentrant returns (uint256 shares) {\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n\n        // Transfer the collateral token to the vault (need the allowance before calling this function)\n        // The remaining amount of collateral token will be flash loaned from the flash lender\n        // to reach the leveraged amount\n        collateralToken.safeTransferFrom(msg.sender, address(this), assets);\n\n        uint256 leveragedCollateralAmount = SharedLogic.getLeveragedCollateralAmountWithSlippage(\n            assets,\n            minOutputShares,\n            dLoopCore\n        );\n\n        require(breakPoint != 8123, string.concat(\"8123: leveragedCollateralAmount:\", uint256ToString(leveragedCollateralAmount),\",assets:\", uint256ToString(assets),\",minOutputShares:\", uint256ToString(minOutputShares)));\n\n        // Create the flash loan params data\n        FlashLoanParams memory params = FlashLoanParams(\n            receiver,\n            assets,\n            leveragedCollateralAmount,\n            debtTokenToCollateralSwapData,\n            dLoopCore\n        );\n        bytes memory data = _encodeParamsToData(params);\n        uint256 maxFlashLoanAmount = flashLender.maxFlashLoan(address(debtToken));\n\n        // This value is used to check if the shares increased after the flash loan\n        uint256 sharesBeforeDeposit = dLoopCore.balanceOf(address(this));\n\n        // Approve the flash lender to spend the flash loan amount of debt token from this contract\n        ERC20(debtToken).forceApprove(\n            address(flashLender),\n            maxFlashLoanAmount + flashLender.flashFee(address(debtToken), maxFlashLoanAmount)\n        );\n\n        // Make sure the flashLender is the same as the debt token\n        if (address(flashLender) != address(debtToken)) {\n            revert FlashLenderNotSameAsDebtToken(address(flashLender), address(debtToken));\n        }\n\n        require(breakPoint != 10010, \"10010\");\n\n        // The main logic will be done in the onFlashLoan function\n        flashLender.flashLoan(this, address(debtToken), maxFlashLoanAmount, data);\n\n        require(breakPoint != 10011, \"10011\");\n\n        // The received debt token after deposit was used to repay the flash loan\n\n        // Check if the shares increased after the flash loan\n        uint256 sharesAfterDeposit = dLoopCore.balanceOf(address(this));\n        if (sharesAfterDeposit <= sharesBeforeDeposit) {\n            revert SharesNotIncreasedAfterFlashLoan(sharesBeforeDeposit, sharesAfterDeposit);\n        }\n\n        require(breakPoint != 10012, \"10012\");\n\n        // Finalize deposit and transfer shares\n        return\n            _finalizeDepositAndTransfer(\n                dLoopCore,\n                debtToken,\n                receiver,\n                sharesBeforeDeposit,\n                sharesAfterDeposit,\n                minOutputShares\n            );\n    }\n\n    /* Flash loan entrypoint */\n\n    /**\n     * @notice Callback function for flash loans\n     * @dev Handles the flash loan execution for leveraged deposits. Only callable by the flash lender.\n     * @param initiator Address that initiated the flash loan\n     * @param token Address of the flash-borrowed token\n     * @param flashLoanFee Flash loan fee amount\n     * @param data Additional data passed to the flash loan\n     * @return bytes32 The flash loan callback success bytes\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256, // amount (flash loan amount)\n        uint256 flashLoanFee, // fee (flash loan fee)\n        bytes calldata data\n    ) external override returns (bytes32) {\n        // This function does not need nonReentrant as the flash loan will be called by deposit() public\n        // function, which is already protected by nonReentrant\n        // Moreover, this function is only be able to be called by the address(this) (check the initiator condition)\n        // thus even though the flash loan is public and not protected by nonReentrant, it is still safe\n        if (msg.sender != address(flashLender)) revert UnknownLender(msg.sender, address(flashLender));\n        if (initiator != address(this)) revert UnknownInitiator(initiator, address(this));\n\n        // Decode the flash loan params data\n        FlashLoanParams memory flashLoanParams = _decodeDataToParams(data);\n        DLoopCoreBase dLoopCore = flashLoanParams.dLoopCore;\n        ERC20 collateralToken = dLoopCore.collateralToken();\n        ERC20 debtToken = dLoopCore.debtToken();\n\n        // Make sure the input dLoopCore is compatible with this periphery contract\n        if (token != address(debtToken)) revert IncompatibleDLoopCoreDebtToken(token, address(debtToken));\n\n        // Calculate and validate the required additional collateral amount\n        uint256 requiredAdditionalCollateralAmount = _calculateRequiredAdditionalCollateral(flashLoanParams);\n\n        require(breakPoint != 20006, string.concat(\"20006: requiredAdditionalCollateralAmount:\", uint256ToString(requiredAdditionalCollateralAmount)));\n\n        setBreakPoint2(breakPoint);\n\n        /**\n         * Swap the flash loan debt token to the collateral token\n         *\n         * Slippage protection is not needed here as the debt token to be used\n         * is from flash loan, which is required to repay the flash loan later\n         * Otherwise, the flash loan will be reverted\n         */\n        uint256 debtTokenAmountUsedInSwap = _swapExactOutput(\n            debtToken,\n            collateralToken,\n            requiredAdditionalCollateralAmount, // exact output amount\n            type(uint256).max, // no slippage protection\n            address(this),\n            block.timestamp,\n            flashLoanParams.debtTokenToCollateralSwapData\n        );\n\n        require(breakPoint != 20007, \"20007\");\n\n        // Execute deposit and validate debt token received\n        _executeDepositAndValidate(\n            flashLoanParams,\n            collateralToken,\n            debtToken,\n            debtTokenAmountUsedInSwap,\n            flashLoanFee\n        );\n\n        require(breakPoint != 20008, \"20008\");\n\n        // Return the success bytes\n        return FLASHLOAN_CALLBACK;\n    }\n\n    /* Setters */\n\n    /* Internal helpers */\n\n    /**\n     * @dev Calculates and validates the required additional collateral amount\n     * @param flashLoanParams Flash loan parameters\n     * @return requiredAdditionalCollateralAmount The required additional collateral amount\n     */\n    function _calculateRequiredAdditionalCollateral(\n        FlashLoanParams memory flashLoanParams\n    ) internal pure returns (uint256 requiredAdditionalCollateralAmount) {\n        // Calculate the required additional collateral amount to reach the leveraged amount\n        // and make sure the overall slippage is included, which is to make sure the output\n        // shares can be at least the min output shares (proven with formula)\n        if (flashLoanParams.leveragedCollateralAmount < flashLoanParams.depositCollateralAmount) {\n            revert LeveragedCollateralAmountLessThanDepositCollateralAmount(\n                flashLoanParams.leveragedCollateralAmount,\n                flashLoanParams.depositCollateralAmount\n            );\n        }\n        requiredAdditionalCollateralAmount = (flashLoanParams.leveragedCollateralAmount -\n            flashLoanParams.depositCollateralAmount);\n    }\n\n    /**\n     * @dev Executes deposit to dLoop core and validates debt token received\n     * @param flashLoanParams Flash loan parameters\n     * @param collateralToken The collateral token\n     * @param debtToken The debt token\n     * @param debtTokenAmountUsedInSwap Amount of debt token used in swap\n     * @param flashLoanFee Flash loan fee\n     */\n    function _executeDepositAndValidate(\n        FlashLoanParams memory flashLoanParams,\n        ERC20 collateralToken,\n        ERC20 debtToken,\n        uint256 debtTokenAmountUsedInSwap,\n        uint256 flashLoanFee\n    ) internal {\n        // This value is used to check if the debt token balance increased after the deposit\n        uint256 debtTokenBalanceBeforeDeposit = debtToken.balanceOf(address(this));\n\n        /**\n         * Deposit the collateral token to the core vault\n         *\n         * The receiver is this periphery contract as the core contract will send both debt token and\n         * the minted shares to the receiver. This contract needs the debt token to repay the flash loan.\n         *\n         * The minted shares will be sent to the receiver later (outside of the flash loan callback)\n         */\n        collateralToken.forceApprove(address(flashLoanParams.dLoopCore), flashLoanParams.leveragedCollateralAmount);\n        flashLoanParams.dLoopCore.deposit(flashLoanParams.leveragedCollateralAmount, address(this));\n\n        // Debt token balance after deposit, which is used to sanity check the debt token balance increased after the deposit\n        uint256 debtTokenBalanceAfterDeposit = debtToken.balanceOf(address(this));\n\n        // Make sure to receive the debt token from the core vault to repay the flash loan\n        if (debtTokenBalanceAfterDeposit <= debtTokenBalanceBeforeDeposit) {\n            revert DebtTokenBalanceNotIncreasedAfterDeposit(\n                debtTokenBalanceBeforeDeposit,\n                debtTokenBalanceAfterDeposit\n            );\n        }\n\n        // Calculate the debt token received after the deposit\n        uint256 debtTokenReceivedAfterDeposit = debtTokenBalanceAfterDeposit - debtTokenBalanceBeforeDeposit;\n\n        require(breakPoint != 30004, string.concat(\n            \"30004: debtTokenBalanceAfterDeposit:\",\n            uint256ToString(debtTokenBalanceAfterDeposit),\n            \",debtTokenBalanceBeforeDeposit:\",\n            uint256ToString(debtTokenBalanceBeforeDeposit),\n            \",debtTokenReceivedAfterDeposit:\",\n            uint256ToString(debtTokenReceivedAfterDeposit),\n            \",debtTokenAmountUsedInSwap:\",\n            uint256ToString(debtTokenAmountUsedInSwap),\n            \",flashLoanFee:\", uint256ToString(flashLoanFee)\n        ));\n\n        // Make sure the debt token received after the deposit is not less than the debt token used in the swap\n        // to allow repaying the flash loan\n        if (debtTokenReceivedAfterDeposit < debtTokenAmountUsedInSwap + flashLoanFee) {\n            revert DebtTokenReceivedNotMetUsedAmountWithFlashLoanFee(\n                debtTokenReceivedAfterDeposit,\n                debtTokenAmountUsedInSwap,\n                flashLoanFee\n            );\n        }\n\n        require(breakPoint != 30005, \"30005\");\n    }\n\n    /**\n     * @dev Finalizes deposit by validating shares and transferring to receiver\n     * @param dLoopCore The dLoopCore contract\n     * @param debtToken The debt token\n     * @param receiver Address to receive the shares\n     * @param sharesBeforeDeposit Shares before deposit\n     * @param sharesAfterDeposit Shares after deposit\n     * @param minOutputShares Minimum output shares for slippage protection\n     * @return shares Amount of shares minted\n     */\n    function _finalizeDepositAndTransfer(\n        DLoopCoreBase dLoopCore,\n        ERC20 debtToken,\n        address receiver,\n        uint256 sharesBeforeDeposit,\n        uint256 sharesAfterDeposit,\n        uint256 minOutputShares\n    ) internal returns (uint256 shares) {\n        /**\n         * Make sure the shares minted is not less than the minimum output shares\n         * for slippage protection\n         *\n         * We only perform slippage protection outside of the flash loan callback\n         * as we only need to care about the last state after the flash loan\n         */\n        shares = sharesAfterDeposit - sharesBeforeDeposit;\n        if (shares < minOutputShares) {\n            revert ReceivedSharesNotMetMinReceiveAmount(shares, minOutputShares);\n        }\n\n        require(breakPoint != 10013, \"10013\");\n\n        // There is no leftover collateral token, as all swapped collateral token\n        // (using flash loaned debt token) is used to deposit to the core contract\n\n        // Transfer any leftover debt tokens directly to the receiver\n        uint256 leftoverAmount = debtToken.balanceOf(address(this));\n        if (leftoverAmount > 0) {\n            debtToken.safeTransfer(receiver, leftoverAmount);\n            emit LeftoverDebtTokensTransferred(address(debtToken), leftoverAmount, receiver);\n        }\n\n        require(breakPoint != 10014, \"10014\");\n\n        // Transfer the minted shares to the receiver\n        SafeERC20.safeTransfer(dLoopCore, receiver, shares);\n\n        require(breakPoint != 10015, \"10015\");\n    }\n\n    /* Data encoding/decoding helpers */\n\n    /**\n     * @dev Encodes flash loan parameters to data\n     * @param _flashLoanParams Flash loan parameters\n     * @return data Encoded data\n     */\n    function _encodeParamsToData(FlashLoanParams memory _flashLoanParams) internal pure returns (bytes memory data) {\n        data = abi.encode(\n            _flashLoanParams.receiver,\n            _flashLoanParams.depositCollateralAmount,\n            _flashLoanParams.leveragedCollateralAmount,\n            _flashLoanParams.debtTokenToCollateralSwapData,\n            _flashLoanParams.dLoopCore\n        );\n    }\n\n    /**\n     * @dev Decodes data to flash loan deposit parameters\n     * @param data Encoded data\n     * @return _flashLoanParams Decoded flash loan parameters\n     */\n    function _decodeDataToParams(bytes memory data) internal pure returns (FlashLoanParams memory _flashLoanParams) {\n        (\n            _flashLoanParams.receiver,\n            _flashLoanParams.depositCollateralAmount,\n            _flashLoanParams.leveragedCollateralAmount,\n            _flashLoanParams.debtTokenToCollateralSwapData,\n            _flashLoanParams.dLoopCore\n        ) = abi.decode(data, (address, uint256, uint256, bytes, DLoopCoreBase));\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/helper/SharedLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { DLoopCoreBase } from \"../../core/DLoopCoreBase.sol\";\nimport { DLoopCoreLogic } from \"../../core/DLoopCoreLogic.sol\";\nimport { BasisPointConstants } from \"contracts/common/BasisPointConstants.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title SharedLogic\n * @dev Shared utility functions for dLoop periphery contracts\n */\nlibrary SharedLogic {\n    /* Errors */\n\n    error EstimatedOverallSlippageBpsCannotExceedOneHundredPercent(uint256 estimatedOverallSlippageBps);\n    error EstimatedSharesLessThanMinOutputShares(uint256 currentEstimatedShares, uint256 minOutputShares);\n\n    /**\n     * @dev Gets the leveraged assets for a given assets and dLoopCore\n     * Uses current leverage if > 0, otherwise falls back to target leverage\n     * @param assets Amount of assets\n     * @param dLoopCore Address of the DLoopCore contract\n     * @return leveragedAssets Amount of leveraged assets\n     */\n    function getLeveragedAssets(uint256 assets, DLoopCoreBase dLoopCore) internal view returns (uint256) {\n        return\n            dLoopCore.getCurrentLeverageBps() > 0\n                ? DLoopCoreLogic.getLeveragedAssetsWithLeverage(assets, dLoopCore.getCurrentLeverageBps())\n                : DLoopCoreLogic.getLeveragedAssetsWithLeverage(assets, dLoopCore.targetLeverageBps());\n    }\n\n    /**\n     * @dev Gets the unleveraged assets for a given leveraged assets and dLoopCore\n     * Uses current leverage if > 0, otherwise falls back to target leverage\n     * @param leveragedAssets Amount of leveraged assets\n     * @param dLoopCore Address of the DLoopCore contract\n     * @return unleveragedAssets Amount of unleveraged assets\n     */\n    function getUnleveragedAssets(uint256 leveragedAssets, DLoopCoreBase dLoopCore) internal view returns (uint256) {\n        return\n            dLoopCore.getCurrentLeverageBps() > 0\n                ? DLoopCoreLogic.getUnleveragedAssetsWithLeverage(leveragedAssets, dLoopCore.getCurrentLeverageBps())\n                : DLoopCoreLogic.getUnleveragedAssetsWithLeverage(leveragedAssets, dLoopCore.targetLeverageBps());\n    }\n\n    /**\n     * @dev Gets the leveraged collateral amount for a given assets and dLoopCore with slippage included\n     * @param assets Amount of assets\n     * @param minOutputShares Minimum output shares\n     * @param dLoopCore Address of the DLoopCore contract\n     * @return leveragedCollateralAmount Amount of leveraged collateral amount\n     *         with slippage included\n     */\n    function getLeveragedCollateralAmountWithSlippage(\n        uint256 assets,\n        uint256 minOutputShares,\n        DLoopCoreBase dLoopCore\n    ) internal view returns (uint256) {\n        // Get the leveraged assets with the current leverage\n        uint256 currentLeveragedAssets = getLeveragedAssets(assets, dLoopCore);\n\n        // Calculate the estimated overall slippage bps\n        uint256 estimatedOverallSlippageBps = calculateEstimatedOverallSlippageBps(\n            dLoopCore.convertToShares(currentLeveragedAssets),\n            minOutputShares\n        );\n\n        // Make sure the estimated overall slippage bps does not exceed 100%\n        if (estimatedOverallSlippageBps > BasisPointConstants.ONE_HUNDRED_PERCENT_BPS) {\n            revert EstimatedOverallSlippageBpsCannotExceedOneHundredPercent(estimatedOverallSlippageBps);\n        }\n\n        // Calculate the leveraged collateral amount to deposit with slippage included\n        // Explained with formula in _calculateEstimatedOverallSlippageBps()\n        uint256 leveragedCollateralAmount = Math.mulDiv(\n            currentLeveragedAssets,\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS - estimatedOverallSlippageBps,\n            BasisPointConstants.ONE_HUNDRED_PERCENT_BPS\n        );\n\n        return leveragedCollateralAmount;\n    }\n\n    /**\n     * @dev Calculates the estimated overall slippage bps\n     * @param currentEstimatedShares Current estimated shares\n     * @param minOutputShares Minimum output shares\n     * @return estimatedOverallSlippageBps Estimated overall slippage bps\n     */\n    function calculateEstimatedOverallSlippageBps(\n        uint256 currentEstimatedShares,\n        uint256 minOutputShares\n    ) internal pure returns (uint256) {\n        /*\n         * According to the formula in getBorrowAmountThatKeepCurrentLeverage() of DLoopCoreLogic,\n         * we have:\n         *      y = x * (T-1)/T\n         *  and\n         *      y = x * (T' - ONE_HUNDRED_PERCENT_BPS) / T'\n         *  and\n         *      T' = T * ONE_HUNDRED_PERCENT_BPS\n         * where:\n         *      - T: target leverage\n         *      - T': target leverage in basis points unit\n         *      - x: supply amount in base currency\n         *      - y: borrow amount in base currency\n         *\n         * We have:\n         *      x = (d + f) * (1 - s)\n         *   => y = (d + f) * (1 - s) * (T-1) / T\n         * where:\n         *      - d is the user's deposit collateral amount (original deposit amount) in base currency\n         *      - f is the flash loan amount of debt token in base currency\n         *      - s is the swap slippage (0.01 means 1%)\n         *\n         * We want find what is the condition of f so that we can borrow the debt token\n         * which is sufficient to cover up the flash loan amount. We want:\n         *      y >= f\n         *  <=> (d+f) * (1-s) * (T-1) / T >= f\n         *  <=> (d+f) * (1-s) * (T-1) >= T*f\n         *  <=> d * (1-s) * (T-1) >= T*f - f * (1-s) * (T-1)\n         *  <=> d * (1-s) * (T-1) >= f * (T - (1-s) * (T-1))\n         *  <=> (d * (1-s) * (T-1)) / (T - (1-s) * (T-1)) >= f    (as the denominator is greater than 0)\n         *  <=> f <= (d * (1-s) * (T-1)) / (T - (1-s) * (T-1))\n         *  <=> f <= (d * (1-s) * (T-1)) / (T - T + 1 + T*s - s)\n         *  <=> f <= (d * (1-s) * (T-1)) / (1 + T*s - s)\n         *\n         * Based on the above inequation, it means we can just adjust the flashloan amount to make\n         * sure the flashloan can be covered by the borrow amount.\n         *\n         * Thus, just need to infer the estimated slippage based on the provided min output shares\n         * and the current estimated shares\n         */\n        if (currentEstimatedShares < minOutputShares) {\n            revert EstimatedSharesLessThanMinOutputShares(currentEstimatedShares, minOutputShares);\n        }\n        return\n            Math.mulDiv(\n                currentEstimatedShares - minOutputShares,\n                BasisPointConstants.ONE_HUNDRED_PERCENT_BPS,\n                currentEstimatedShares\n            );\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/interface/flashloan/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/vaults/dloop/periphery/interface/flashloan/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "contracts/vaults/dloop/periphery/venue/odos/DLoopDepositorOdos.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport { DLoopDepositorBase, ERC20, IERC3156FlashLender, SharedLogic, DLoopCoreBase } from \"../../DLoopDepositorBase.sol\";\nimport { OdosSwapLogic, IOdosRouterV2 } from \"./OdosSwapLogic.sol\";\n\n/**\n * @title DLoopDepositorOdos\n * @dev Implementation of DLoopDepositorBase with Odos swap functionality\n */\ncontract DLoopDepositorOdos is DLoopDepositorBase {\n    IOdosRouterV2 public immutable odosRouter;\n    error InputTokenBalanceDoesNotDecreaseAfterSwap(uint256 inputTokenBalanceBefore, uint256 inputTokenBalanceAfter);\n    error LeveragedCollateralAmountLessThanAssets(uint256 leveragedCollateralAmount, uint256 assets);\n\n    /**\n     * @dev Constructor for the DLoopDepositorOdos contract\n     * @param _flashLender Address of the flash loan provider\n     * @param _odosRouter Address of the Odos router\n     */\n    constructor(IERC3156FlashLender _flashLender, IOdosRouterV2 _odosRouter) DLoopDepositorBase(_flashLender) {\n        odosRouter = _odosRouter;\n    }\n\n    /**\n     * @dev Estimates the amount of collateral token to swap for the flash loan\n     *      This method is specific for Odos venue only, as we cannot do exact output swap with Odos wrapper,\n     *      thus we can only relies on the quote to make sure the output amount is as expected\n     * @param assets Amount of assets\n     * @param minOutputShares Minimum output shares\n     * @param dLoopCore Address of the DLoopCore contract\n     * @return amount Amount of collateral token to swap for the flash loan\n     */\n    function estimateFlashLoanSwapOutputCollateralAmount(\n        uint256 assets,\n        uint256 minOutputShares,\n        DLoopCoreBase dLoopCore\n    ) public view returns (uint256) {\n        uint256 leveragedCollateralAmount = SharedLogic.getLeveragedCollateralAmountWithSlippage(\n            assets,\n            minOutputShares,\n            dLoopCore\n        );\n        if (leveragedCollateralAmount < assets) {\n            revert LeveragedCollateralAmountLessThanAssets(leveragedCollateralAmount, assets);\n        }\n        return leveragedCollateralAmount - assets;\n    }\n\n    /**\n     * @dev The difference tolerance for the swapped output amount\n     * @param expectedOutputAmount Expected output amount\n     * @return differenceTolerance The difference tolerance amount\n     */\n    function swappedOutputDifferenceToleranceAmount(uint256 expectedOutputAmount) public pure override returns (uint256) {\n        return OdosSwapLogic.swappedOutputDifferenceToleranceAmount(expectedOutputAmount);\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for the minimum input tokens using Odos\n     */\n    function _swapExactOutputImplementation(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory dStableToUnderlyingSwapData\n    ) internal override returns (uint256) {\n        // We check the actual spent amount of input token here, as the returned amount from Odos wrapper is not reliable\n        uint256 inputTokenBalanceBefore = inputToken.balanceOf(address(this));\n        OdosSwapLogic.swapExactOutputWithBreakPoint(\n            inputToken,\n            outputToken,\n            amountOut,\n            amountInMaximum,\n            receiver,\n            deadline,\n            dStableToUnderlyingSwapData,\n            odosRouter,\n            breakPoint\n        );\n        uint256 inputTokenBalanceAfter = inputToken.balanceOf(address(this));\n\n        if (inputTokenBalanceAfter >= inputTokenBalanceBefore) {\n            revert InputTokenBalanceDoesNotDecreaseAfterSwap(inputTokenBalanceBefore, inputTokenBalanceAfter);\n        }\n\n        return inputTokenBalanceBefore - inputTokenBalanceAfter;\n    }\n}\n"
    },
    "contracts/vaults/dloop/periphery/venue/odos/OdosSwapLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport { ERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { IOdosRouterV2 } from \"contracts/odos/interface/IOdosRouterV2.sol\";\nimport { OdosSwapUtils } from \"contracts/odos/OdosSwapUtils.sol\";\nimport { BasisPointConstants } from \"contracts/common/BasisPointConstants.sol\";\nimport { OdosSwapUtils as OdosSwapUtilsDebug } from \"contracts/odos/OdosSwapUtilsDebug.sol\";\n\nstruct SwapExactOutputVariables {\n    uint256 balanceBefore;\n    uint256 balanceAfter;\n    uint256 amountSpent;\n    uint256 actualReceived;\n    uint256 surplus;\n}\n\n/**\n * @title OdosSwapLogic\n * @dev Library for common Odos swap functions used in dLOOP contracts\n */\nlibrary OdosSwapLogic {\n    using SafeERC20 for ERC20;\n    \n    uint256 public constant DIFFERENCE_TOLERANCE_BPS = BasisPointConstants.ONE_PERCENT_BPS;\n\n    /**\n     * @dev The difference tolerance for the swapped output amount\n     * @param expectedOutputAmount Expected output amount\n     * @return differenceTolerance The difference tolerance amount\n     */\n    function swappedOutputDifferenceToleranceAmount(uint256 expectedOutputAmount) internal pure returns (uint256) {\n        return expectedOutputAmount * DIFFERENCE_TOLERANCE_BPS / BasisPointConstants.ONE_HUNDRED_PERCENT_BPS;\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for input tokens using Odos router\n     * @param inputToken Input token to be swapped\n     * @param outputToken Output token to receive (used for validating the swap direction)\n     * @param amountOut Exact amount of output tokens to receive\n     * @param amountInMaximum Maximum amount of input tokens to spend\n     * @param receiver Address to receive the output tokens (not used directly in Odos, but kept for interface consistency)\n     * @param swapData Encoded swap data for Odos router\n     * @param odosRouter Odos router instance\n     * @return uint256 Amount of input tokens used\n     */\n    function _swapExactOutputWithBreakPoint(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256, // deadline, not used in Odos\n        bytes memory swapData,\n        IOdosRouterV2 odosRouter,\n        uint256 breakPoint\n    ) internal returns (uint256) {\n        SwapExactOutputVariables memory vars;\n\n        // Measure the contract’s balance, not the receiver’s, because Odos router sends the\n        // output tokens to the caller (i.e. this contract). We refund any surplus afterwards.\n        vars.balanceBefore = ERC20(outputToken).balanceOf(address(this));\n\n        require(breakPoint != 60001, \"60001\");\n\n        // Use the OdosSwapUtils library to execute the swap\n        vars.amountSpent = OdosSwapUtilsDebug.executeSwapOperationWithBreakPoint(\n            odosRouter,\n            address(inputToken),\n            address(outputToken),\n            amountInMaximum,\n            amountOut,\n            swapData,\n            breakPoint\n        );\n\n        require(breakPoint != 60002, \"60002\");\n    \n        {\n            vars.balanceAfter = ERC20(outputToken).balanceOf(address(this));\n            vars.actualReceived = vars.balanceAfter - vars.balanceBefore;\n\n            // Safety check – OdosSwapUtils should already revert if insufficient, but double-check.\n            if (vars.actualReceived < amountOut) {\n                revert(\"INSUFFICIENT_OUTPUT\");\n            }\n\n            vars.surplus = vars.actualReceived - amountOut;\n\n            // Transfer surplus to receiver when receiver is not this contract and surplus exists\n            if (vars.surplus > 0 && receiver != address(this)) {\n                ERC20(outputToken).safeTransfer(receiver, vars.surplus);\n            }\n        }\n\n        return vars.amountSpent;\n    }\n\n    /**\n     * @dev Swaps an exact amount of output tokens for input tokens using Odos router\n     * @param inputToken Input token to be swapped\n     * @param outputToken Output token to receive (used for validating the swap direction)\n     * @param amountOut Exact amount of output tokens to receive\n     * @param amountInMaximum Maximum amount of input tokens to spend\n     * @param receiver Address to receive the output tokens (not used directly in Odos, but kept for interface consistency)\n     * @param swapData Encoded swap data for Odos router\n     * @param odosRouter Odos router instance\n     * @return uint256 Amount of input tokens used\n     */\n    function swapExactOutput(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline, // deadline, not used in Odos\n        bytes memory swapData,\n        IOdosRouterV2 odosRouter\n    ) external returns (uint256) {\n        return _swapExactOutputWithBreakPoint(\n            inputToken,\n            outputToken,\n            amountOut,\n            amountInMaximum,\n            receiver,\n            deadline,\n            swapData,\n            odosRouter,\n            0\n        );\n    }\n\n    function swapExactOutputWithBreakPoint(\n        ERC20 inputToken,\n        ERC20 outputToken,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address receiver,\n        uint256 deadline,\n        bytes memory swapData,\n        IOdosRouterV2 odosRouter,\n        uint256 breakPoint\n    ) external returns (uint256) {\n        return _swapExactOutputWithBreakPoint(\n            inputToken,\n            outputToken,\n            amountOut,\n            amountInMaximum,\n            receiver,\n            deadline,\n            swapData,\n            odosRouter,\n            breakPoint\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}