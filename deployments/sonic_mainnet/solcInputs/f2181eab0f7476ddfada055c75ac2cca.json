{
  "language": "Solidity",
  "sources": {
    "contracts/dlend/core/dependencies/openzeppelin/contracts/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data\n    ) internal view returns (bytes memory) {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\n\ninterface IERC20Detailed is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(\n            value <= type(uint224).max,\n            \"SafeCast: value doesn't fit in 224 bits\"\n        );\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(\n            value <= type(uint128).max,\n            \"SafeCast: value doesn't fit in 128 bits\"\n        );\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(\n            value <= type(uint96).max,\n            \"SafeCast: value doesn't fit in 96 bits\"\n        );\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(\n            value <= type(uint64).max,\n            \"SafeCast: value doesn't fit in 64 bits\"\n        );\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(\n            value <= type(uint32).max,\n            \"SafeCast: value doesn't fit in 32 bits\"\n        );\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(\n            value <= type(uint16).max,\n            \"SafeCast: value doesn't fit in 16 bits\"\n        );\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(\n            value <= type(uint8).max,\n            \"SafeCast: value doesn't fit in 8 bits\"\n        );\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(\n            value >= type(int128).min && value <= type(int128).max,\n            \"SafeCast: value doesn't fit in 128 bits\"\n        );\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(\n            value >= type(int64).min && value <= type(int64).max,\n            \"SafeCast: value doesn't fit in 64 bits\"\n        );\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(\n            value >= type(int32).min && value <= type(int32).max,\n            \"SafeCast: value doesn't fit in 32 bits\"\n        );\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(\n            value >= type(int16).min && value <= type(int16).max,\n            \"SafeCast: value doesn't fit in 16 bits\"\n        );\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(\n            value >= type(int8).min && value <= type(int8).max,\n            \"SafeCast: value doesn't fit in 8 bits\"\n        );\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(\n            value <= uint256(type(int256).max),\n            \"SafeCast: value doesn't fit in an int256\"\n        );\n        return int256(value);\n    }\n}\n"
    },
    "contracts/dlend/core/dependencies/openzeppelin/contracts/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport \"./IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(\n                oldAllowance >= value,\n                \"SafeERC20: decreased allowance below zero\"\n            );\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(\n                    token.approve.selector,\n                    spender,\n                    newAllowance\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/dlend/core/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {IPriceOracleGetter} from \"./IPriceOracleGetter.sol\";\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\n\n/**\n * @title IAaveOracle\n * @author Aave\n * @notice Defines the basic interface for the Aave Oracle\n */\ninterface IAaveOracle is IPriceOracleGetter {\n    /**\n     * @dev Emitted after the base currency is set\n     * @param baseCurrency The base currency of used for price quotes\n     * @param baseCurrencyUnit The unit of the base currency\n     */\n    event BaseCurrencySet(\n        address indexed baseCurrency,\n        uint256 baseCurrencyUnit\n    );\n\n    /**\n     * @dev Emitted after the price source of an asset is updated\n     * @param asset The address of the asset\n     * @param source The price source of the asset\n     */\n    event AssetSourceUpdated(address indexed asset, address indexed source);\n\n    /**\n     * @dev Emitted after the address of fallback oracle is updated\n     * @param fallbackOracle The address of the fallback oracle\n     */\n    event FallbackOracleUpdated(address indexed fallbackOracle);\n\n    /**\n     * @notice Returns the PoolAddressesProvider\n     * @return The address of the PoolAddressesProvider contract\n     */\n    function ADDRESSES_PROVIDER()\n        external\n        view\n        returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Sets or replaces price sources of assets\n     * @param assets The addresses of the assets\n     * @param sources The addresses of the price sources\n     */\n    function setAssetSources(\n        address[] calldata assets,\n        address[] calldata sources\n    ) external;\n\n    /**\n     * @notice Sets the fallback oracle\n     * @param fallbackOracle The address of the fallback oracle\n     */\n    function setFallbackOracle(address fallbackOracle) external;\n\n    /**\n     * @notice Returns a list of prices from a list of assets addresses\n     * @param assets The list of assets addresses\n     * @return The prices of the given assets\n     */\n    function getAssetsPrices(\n        address[] calldata assets\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice Returns the address of the source for an asset address\n     * @param asset The address of the asset\n     * @return The address of the source\n     */\n    function getSourceOfAsset(address asset) external view returns (address);\n\n    /**\n     * @notice Returns the address of the fallback oracle\n     * @return The address of the fallback oracle\n     */\n    function getFallbackOracle() external view returns (address);\n}\n"
    },
    "contracts/dlend/core/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n    /**\n     * @dev Emitted when the market identifier is updated.\n     * @param oldMarketId The old id of the market\n     * @param newMarketId The new id of the market\n     */\n    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n    /**\n     * @dev Emitted when the pool is updated.\n     * @param oldAddress The old address of the Pool\n     * @param newAddress The new address of the Pool\n     */\n    event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the pool configurator is updated.\n     * @param oldAddress The old address of the PoolConfigurator\n     * @param newAddress The new address of the PoolConfigurator\n     */\n    event PoolConfiguratorUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the price oracle is updated.\n     * @param oldAddress The old address of the PriceOracle\n     * @param newAddress The new address of the PriceOracle\n     */\n    event PriceOracleUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the ACL manager is updated.\n     * @param oldAddress The old address of the ACLManager\n     * @param newAddress The new address of the ACLManager\n     */\n    event ACLManagerUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the ACL admin is updated.\n     * @param oldAddress The old address of the ACLAdmin\n     * @param newAddress The new address of the ACLAdmin\n     */\n    event ACLAdminUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the price oracle sentinel is updated.\n     * @param oldAddress The old address of the PriceOracleSentinel\n     * @param newAddress The new address of the PriceOracleSentinel\n     */\n    event PriceOracleSentinelUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the pool data provider is updated.\n     * @param oldAddress The old address of the PoolDataProvider\n     * @param newAddress The new address of the PoolDataProvider\n     */\n    event PoolDataProviderUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when a new proxy is created.\n     * @param id The identifier of the proxy\n     * @param proxyAddress The address of the created proxy contract\n     * @param implementationAddress The address of the implementation contract\n     */\n    event ProxyCreated(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address indexed implementationAddress\n    );\n\n    /**\n     * @dev Emitted when a new non-proxied contract address is registered.\n     * @param id The identifier of the contract\n     * @param oldAddress The address of the old contract\n     * @param newAddress The address of the new contract\n     */\n    event AddressSet(\n        bytes32 indexed id,\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @dev Emitted when the implementation of the proxy registered with id is updated\n     * @param id The identifier of the contract\n     * @param proxyAddress The address of the proxy contract\n     * @param oldImplementationAddress The address of the old implementation contract\n     * @param newImplementationAddress The address of the new implementation contract\n     */\n    event AddressSetAsProxy(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address oldImplementationAddress,\n        address indexed newImplementationAddress\n    );\n\n    /**\n     * @notice Returns the id of the Aave market to which this contract points to.\n     * @return The market id\n     */\n    function getMarketId() external view returns (string memory);\n\n    /**\n     * @notice Associates an id with a specific PoolAddressesProvider.\n     * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n     * identify and validate multiple Aave markets.\n     * @param newMarketId The market id\n     */\n    function setMarketId(string calldata newMarketId) external;\n\n    /**\n     * @notice Returns an address by its identifier.\n     * @dev The returned address might be an EOA or a contract, potentially proxied\n     * @dev It returns ZERO if there is no registered address with the given id\n     * @param id The id\n     * @return The address of the registered for the specified id\n     */\n    function getAddressFromID(bytes32 id) external view returns (address);\n\n    /**\n     * @notice General function to update the implementation of a proxy registered with\n     * certain `id`. If there is no proxy registered, it will instantiate one and\n     * set as implementation the `newImplementationAddress`.\n     * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n     * setter function, in order to avoid unexpected consequences\n     * @param id The id\n     * @param newImplementationAddress The address of the new implementation\n     */\n    function setAddressAsProxy(\n        bytes32 id,\n        address newImplementationAddress\n    ) external;\n\n    /**\n     * @notice Sets an address for an id replacing the address saved in the addresses map.\n     * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n     * @param id The id\n     * @param newAddress The address to set\n     */\n    function setAddress(bytes32 id, address newAddress) external;\n\n    /**\n     * @notice Returns the address of the Pool proxy.\n     * @return The Pool proxy address\n     */\n    function getPool() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the Pool, or creates a proxy\n     * setting the new `pool` implementation when the function is called for the first time.\n     * @param newPoolImpl The new Pool implementation\n     */\n    function setPoolImpl(address newPoolImpl) external;\n\n    /**\n     * @notice Returns the address of the PoolConfigurator proxy.\n     * @return The PoolConfigurator proxy address\n     */\n    function getPoolConfigurator() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n     * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n     * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n     */\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n    /**\n     * @notice Returns the address of the price oracle.\n     * @return The address of the PriceOracle\n     */\n    function getPriceOracle() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle.\n     * @param newPriceOracle The address of the new PriceOracle\n     */\n    function setPriceOracle(address newPriceOracle) external;\n\n    /**\n     * @notice Returns the address of the ACL manager.\n     * @return The address of the ACLManager\n     */\n    function getACLManager() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL manager.\n     * @param newAclManager The address of the new ACLManager\n     */\n    function setACLManager(address newAclManager) external;\n\n    /**\n     * @notice Returns the address of the ACL admin.\n     * @return The address of the ACL admin\n     */\n    function getACLAdmin() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL admin.\n     * @param newAclAdmin The address of the new ACL admin\n     */\n    function setACLAdmin(address newAclAdmin) external;\n\n    /**\n     * @notice Returns the address of the price oracle sentinel.\n     * @return The address of the PriceOracleSentinel\n     */\n    function getPriceOracleSentinel() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle sentinel.\n     * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n     */\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n    /**\n     * @notice Returns the address of the data provider.\n     * @return The address of the DataProvider\n     */\n    function getPoolDataProvider() external view returns (address);\n\n    /**\n     * @notice Updates the address of the data provider.\n     * @param newDataProvider The address of the new DataProvider\n     */\n    function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "contracts/dlend/core/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n    /**\n     * @notice Returns the base currency address\n     * @dev Address 0x0 is reserved for USD as base currency.\n     * @return Returns the base currency address.\n     */\n    function BASE_CURRENCY() external view returns (address);\n\n    /**\n     * @notice Returns the base currency unit\n     * @dev 1 ether for ETH, 1e8 for USD.\n     * @return Returns the base currency unit.\n     */\n    function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n    /**\n     * @notice Returns the asset price in the base currency\n     * @param asset The address of the asset\n     * @return The price of the asset\n     */\n    function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/dlend/core/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IScaledBalanceToken\n * @author Aave\n * @notice Defines the basic interface for a scaled-balance token.\n */\ninterface IScaledBalanceToken {\n    /**\n     * @dev Emitted after the mint action\n     * @param caller The address performing the mint\n     * @param onBehalfOf The address of the user that will receive the minted tokens\n     * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\n     * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\n     * @param index The next liquidity index of the reserve\n     */\n    event Mint(\n        address indexed caller,\n        address indexed onBehalfOf,\n        uint256 value,\n        uint256 balanceIncrease,\n        uint256 index\n    );\n\n    /**\n     * @dev Emitted after the burn action\n     * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\n     * @param from The address from which the tokens will be burned\n     * @param target The address that will receive the underlying, if any\n     * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\n     * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\n     * @param index The next liquidity index of the reserve\n     */\n    event Burn(\n        address indexed from,\n        address indexed target,\n        uint256 value,\n        uint256 balanceIncrease,\n        uint256 index\n    );\n\n    /**\n     * @notice Returns the scaled balance of the user.\n     * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\n     * at the moment of the update\n     * @param user The user whose balance is calculated\n     * @return The scaled balance of the user\n     */\n    function scaledBalanceOf(address user) external view returns (uint256);\n\n    /**\n     * @notice Returns the scaled balance of the user and the scaled total supply.\n     * @param user The address of the user\n     * @return The scaled balance of the user\n     * @return The scaled total supply\n     */\n    function getScaledUserBalanceAndSupply(\n        address user\n    ) external view returns (uint256, uint256);\n\n    /**\n     * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n     * @return The scaled total supply\n     */\n    function scaledTotalSupply() external view returns (uint256);\n\n    /**\n     * @notice Returns last index interest was accrued to the user's balance\n     * @param user The address of the user\n     * @return The last index interest was accrued to the user's balance, expressed in ray\n     */\n    function getPreviousIndex(address user) external view returns (uint256);\n}\n"
    },
    "contracts/dlend/core/protocol/libraries/aave-upgradeability/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title VersionedInitializable\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n * @notice Helper contract to implement initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * @dev WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\nabstract contract VersionedInitializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    uint256 private lastInitializedRevision = 0;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        uint256 revision = getRevision();\n        require(\n            initializing ||\n                isConstructor() ||\n                revision > lastInitializedRevision,\n            \"Contract instance has already been initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            lastInitializedRevision = revision;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /**\n     * @notice Returns the revision number of the contract\n     * @dev Needs to be defined in the inherited class as a constant.\n     * @return The revision number\n     */\n    function getRevision() internal pure virtual returns (uint256);\n\n    /**\n     * @notice Returns true if and only if the function is running in the constructor\n     * @return True if the function is running in the constructor\n     */\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        uint256 cs;\n        //solium-disable-next-line\n        assembly {\n            cs := extcodesize(address())\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/IPullRewardsTransferStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {ITransferStrategyBase} from \"./ITransferStrategyBase.sol\";\n\n/**\n * @title IPullRewardsTransferStrategy\n * @author Aave\n **/\ninterface IPullRewardsTransferStrategy is ITransferStrategyBase {\n    /**\n     * @return Address of the rewards vault\n     */\n    function getRewardsVault() external view returns (address);\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/IRewardsController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {IAaveOracle} from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\nimport {IRewardsDistributor} from \"./IRewardsDistributor.sol\";\nimport {ITransferStrategyBase} from \"./ITransferStrategyBase.sol\";\nimport {RewardsDataTypes} from \"../libraries/RewardsDataTypes.sol\";\n\n/**\n * @title IRewardsController\n * @author Aave\n * @notice Defines the basic interface for a Rewards Controller.\n */\ninterface IRewardsController is IRewardsDistributor {\n    /**\n     * @dev Emitted when a new address is whitelisted as claimer of rewards on behalf of a user\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    event ClaimerSet(address indexed user, address indexed claimer);\n\n    /**\n     * @dev Emitted when rewards are claimed\n     * @param user The address of the user rewards has been claimed on behalf of\n     * @param reward The address of the token reward is claimed\n     * @param to The address of the receiver of the rewards\n     * @param claimer The address of the claimer\n     * @param amount The amount of rewards claimed\n     */\n    event RewardsClaimed(\n        address indexed user,\n        address indexed reward,\n        address indexed to,\n        address claimer,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when a transfer strategy is installed for the reward distribution\n     * @param reward The address of the token reward\n     * @param transferStrategy The address of TransferStrategy contract\n     */\n    event TransferStrategyInstalled(\n        address indexed reward,\n        address indexed transferStrategy\n    );\n\n    /**\n     * @dev Emitted when the reward oracle is updated\n     * @param reward The address of the token reward\n     * @param rewardOracle The address of oracle\n     */\n    event RewardOracleUpdated(\n        address indexed reward,\n        address indexed rewardOracle\n    );\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @dev Sets a TransferStrategy logic contract that determines the logic of the rewards transfer\n     * @param reward The address of the reward token\n     * @param transferStrategy The address of the TransferStrategy logic contract\n     */\n    function setTransferStrategy(\n        address reward,\n        ITransferStrategyBase transferStrategy\n    ) external;\n\n    /**\n     * @dev Sets an Aave Oracle contract to enforce rewards with a source of value.\n     * @notice At the moment of reward configuration, the Incentives Controller performs\n     * a check to see if the reward asset oracle is compatible with IAaveOracle interface.\n     * This check is enforced for integrators to be able to show incentives at\n     * the current Aave UI without the need to setup an external price registry\n     * @param reward The address of the reward to set the price aggregator\n     * @param rewardOracle The address of price aggregator that follows IAaveOracle interface\n     */\n    function setRewardOracle(address reward, IAaveOracle rewardOracle) external;\n\n    /**\n     * @dev Get the price aggregator oracle address\n     * @param reward The address of the reward\n     * @return The price oracle of the reward\n     */\n    function getRewardOracle(address reward) external view returns (address);\n\n    /**\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n     * @param user The address of the user\n     * @return The claimer address\n     */\n    function getClaimer(address user) external view returns (address);\n\n    /**\n     * @dev Returns the Transfer Strategy implementation contract address being used for a reward address\n     * @param reward The address of the reward\n     * @return The address of the TransferStrategy contract\n     */\n    function getTransferStrategy(\n        address reward\n    ) external view returns (address);\n\n    /**\n     * @dev Configure assets to incentivize with an emission of rewards per second until the end of distribution.\n     * @param config The assets configuration input, the list of structs contains the following fields:\n     *   uint104 emissionPerSecond: The emission per second following rewards unit decimals.\n     *   uint256 totalSupply: The total supply of the asset to incentivize\n     *   uint40 distributionEnd: The end of the distribution of the incentives for an asset\n     *   address asset: The asset address to incentivize\n     *   address reward: The reward token address\n     *   ITransferStrategy transferStrategy: The TransferStrategy address with the install hook and claim logic.\n     *   IAaveOracle rewardOracle: The Price Oracle of a reward to visualize the incentives at the UI Frontend.\n     */\n    function configureAssets(\n        RewardsDataTypes.RewardsConfigInput[] memory config\n    ) external;\n\n    /**\n     * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\n     * @dev The units of `totalSupply` and `userBalance` should be the same.\n     * @param user The address of the user whose asset balance has changed\n     * @param totalSupply The total supply of the asset prior to user balance change\n     * @param userBalance The previous user balance prior to balance change\n     **/\n    function handleAction(\n        address user,\n        uint256 totalSupply,\n        uint256 userBalance\n    ) external;\n\n    /**\n     * @dev Claims reward for a user to the desired address, on all the assets of the pool, accumulating the pending rewards\n     * @param assets List of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param to The address that will be receiving the rewards\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to,\n        address reward\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards. The\n     * caller must be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param user The address to check and claim rewards\n     * @param to The address that will be receiving the rewards\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to,\n        address reward\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param amount The amount of rewards to claim\n     * @param reward The address of the reward token\n     * @return The amount of rewards claimed\n     **/\n    function claimRewardsToSelf(\n        address[] calldata assets,\n        uint256 amount,\n        address reward\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims all rewards for a user to the desired address, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param to The address that will be receiving the rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardList\"\n     **/\n    function claimAllRewards(\n        address[] calldata assets,\n        address to\n    )\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @dev Claims all rewards for a user on behalf, on all the assets of the pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @param user The address to check and claim rewards\n     * @param to The address that will be receiving the rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n     **/\n    function claimAllRewardsOnBehalf(\n        address[] calldata assets,\n        address user,\n        address to\n    )\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @dev Claims all reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\n     * @param assets The list of assets to check eligible distributions before claiming rewards\n     * @return rewardsList List of addresses of the reward tokens\n     * @return claimedAmounts List that contains the claimed amount per reward, following same order as \"rewardsList\"\n     **/\n    function claimAllRewardsToSelf(\n        address[] calldata assets\n    )\n        external\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts);\n\n    /**\n     * @dev Recieve more fund from the user to existing reward\n     * @param reward The reward address is being distributed\n     * @param amount The token amount is being funded\n     * @param from The address of the one who funds the rewards\n     */\n    function depositRewardFrom(\n        address reward,\n        uint256 amount,\n        address from\n    ) external;\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IRewardsDistributor\n * @author Aave\n * @notice Defines the basic interface for a Rewards Distributor.\n */\ninterface IRewardsDistributor {\n    /**\n     * @dev Emitted when the configuration of the rewards of an asset is updated.\n     * @param asset The address of the incentivized asset\n     * @param reward The address of the reward token\n     * @param oldEmission The old emissions per second value of the reward distribution\n     * @param newEmission The new emissions per second value of the reward distribution\n     * @param oldDistributionEnd The old end timestamp of the reward distribution\n     * @param newDistributionEnd The new end timestamp of the reward distribution\n     * @param assetIndex The index of the asset distribution\n     */\n    event AssetConfigUpdated(\n        address indexed asset,\n        address indexed reward,\n        uint256 oldEmission,\n        uint256 newEmission,\n        uint256 oldDistributionEnd,\n        uint256 newDistributionEnd,\n        uint256 assetIndex\n    );\n\n    /**\n     * @dev Emitted when rewards of an asset are accrued on behalf of a user.\n     * @param asset The address of the incentivized asset\n     * @param reward The address of the reward token\n     * @param user The address of the user that rewards are accrued on behalf of\n     * @param assetIndex The index of the asset distribution\n     * @param userIndex The index of the asset distribution on behalf of the user\n     * @param rewardsAccrued The amount of rewards accrued\n     */\n    event Accrued(\n        address indexed asset,\n        address indexed reward,\n        address indexed user,\n        uint256 assetIndex,\n        uint256 userIndex,\n        uint256 rewardsAccrued\n    );\n\n    /**\n     * @dev Sets the end date for the distribution\n     * @param asset The asset to incentivize\n     * @param reward The reward token that incentives the asset\n     * @param newDistributionEnd The end date of the incentivization, in unix time format\n     **/\n    function setDistributionEnd(\n        address asset,\n        address reward,\n        uint32 newDistributionEnd\n    ) external;\n\n    /**\n     * @dev Sets the emission per second of a set of reward distributions\n     * @param asset The asset is being incentivized\n     * @param rewards List of reward addresses are being distributed\n     * @param newEmissionsPerSecond List of new reward emissions per second\n     */\n    function setEmissionPerSecond(\n        address asset,\n        address[] calldata rewards,\n        uint88[] calldata newEmissionsPerSecond\n    ) external;\n\n    /**\n     * @dev Gets the end date for the distribution\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The timestamp with the end of the distribution, in unix time format\n     **/\n    function getDistributionEnd(\n        address asset,\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns the index of a user on a reward distribution\n     * @param user Address of the user\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The current user asset index, not including new distributions\n     **/\n    function getUserAssetIndex(\n        address user,\n        address asset,\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns the configuration of the distribution reward for a certain asset\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The index of the asset distribution\n     * @return The emission per second of the reward distribution\n     * @return The timestamp of the last update of the index\n     * @return The timestamp of the distribution end\n     **/\n    function getRewardsData(\n        address asset,\n        address reward\n    ) external view returns (uint256, uint256, uint256, uint256);\n\n    /**\n     * @dev Calculates the next value of an specific distribution index, with validations.\n     * @param asset The incentivized asset\n     * @param reward The reward token of the incentivized asset\n     * @return The old index of the asset distribution\n     * @return The new index of the asset distribution\n     **/\n    function getAssetIndex(\n        address asset,\n        address reward\n    ) external view returns (uint256, uint256);\n\n    /**\n     * @dev Returns the list of available reward token addresses of an incentivized asset\n     * @param asset The incentivized asset\n     * @return List of rewards addresses of the input asset\n     **/\n    function getRewardsByAsset(\n        address asset\n    ) external view returns (address[] memory);\n\n    /**\n     * @dev Returns the list of available reward addresses\n     * @return List of rewards supported in this contract\n     **/\n    function getRewardsList() external view returns (address[] memory);\n\n    /**\n     * @dev Returns the accrued rewards balance of a user, not including virtually accrued rewards since last distribution.\n     * @param user The address of the user\n     * @param reward The address of the reward token\n     * @return Unclaimed rewards, not including new distributions\n     **/\n    function getUserAccruedRewards(\n        address user,\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns a single rewards balance of a user, including virtually accrued and unrealized claimable rewards.\n     * @param assets List of incentivized assets to check eligible distributions\n     * @param user The address of the user\n     * @param reward The address of the reward token\n     * @return The rewards amount\n     **/\n    function getUserRewards(\n        address[] calldata assets,\n        address user,\n        address reward\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns a list all rewards of a user, including already accrued and unrealized claimable rewards\n     * @param assets List of incentivized assets to check eligible distributions\n     * @param user The address of the user\n     * @return The list of reward addresses\n     * @return The list of unclaimed amount of rewards\n     **/\n    function getAllUserRewards(\n        address[] calldata assets,\n        address user\n    ) external view returns (address[] memory, uint256[] memory);\n\n    /**\n     * @dev Returns the decimals of an asset to calculate the distribution delta\n     * @param asset The address to retrieve decimals\n     * @return The decimals of an underlying asset\n     */\n    function getAssetDecimals(address asset) external view returns (uint8);\n\n    /**\n     * @dev Returns the address of the emission manager\n     * @return The address of the EmissionManager\n     */\n    function EMISSION_MANAGER() external view returns (address);\n\n    /**\n     * @dev Returns the address of the emission manager.\n     * Deprecated: This getter is maintained for compatibility purposes. Use the `EMISSION_MANAGER()` function instead.\n     * @return The address of the EmissionManager\n     */\n    function getEmissionManager() external view returns (address);\n}\n"
    },
    "contracts/dlend/periphery/rewards/interfaces/ITransferStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\ninterface ITransferStrategyBase {\n    event EmergencyWithdrawal(\n        address indexed caller,\n        address indexed token,\n        address indexed to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Perform custom transfer logic via delegate call from source contract to a TransferStrategy implementation\n     * @param to Account to transfer rewards\n     * @param reward Address of the reward token\n     * @param amount Amount to transfer to the \"to\" address parameter\n     * @return Returns true bool if transfer logic succeeds\n     */\n    function performTransfer(\n        address to,\n        address reward,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @return Returns the address of the Incentives Controller\n     */\n    function getIncentivesController() external view returns (address);\n\n    /**\n     * @return Returns the address of the Rewards admin\n     */\n    function getRewardsAdmin() external view returns (address);\n\n    /**\n     * @dev Perform an emergency token withdrawal only callable by the Rewards admin\n     * @param token Address of the token to withdraw funds from this contract\n     * @param to Address of the recipient of the withdrawal\n     * @param amount Amount of the withdrawal\n     */\n    function emergencyWithdrawal(\n        address token,\n        address to,\n        uint256 amount\n    ) external;\n}\n"
    },
    "contracts/dlend/periphery/rewards/libraries/RewardsDataTypes.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {IAaveOracle} from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\nimport {ITransferStrategyBase} from \"../interfaces/ITransferStrategyBase.sol\";\n\nlibrary RewardsDataTypes {\n    struct RewardsConfigInput {\n        uint88 emissionPerSecond;\n        uint256 totalSupply;\n        uint32 distributionEnd;\n        address asset;\n        address reward;\n        ITransferStrategyBase transferStrategy;\n        IAaveOracle rewardOracle;\n    }\n\n    struct UserAssetBalance {\n        address asset;\n        uint256 userBalance;\n        uint256 totalSupply;\n    }\n\n    struct UserData {\n        // Liquidity index of the reward distribution for the user\n        uint104 index;\n        // Amount of accrued rewards for the user since last user index update\n        uint128 accrued;\n    }\n\n    struct RewardData {\n        // Liquidity index of the reward distribution\n        uint104 index;\n        // Amount of reward tokens distributed per second\n        uint88 emissionPerSecond;\n        // Timestamp of the last reward index update\n        uint32 lastUpdateTimestamp;\n        // The end of the distribution of rewards (in seconds)\n        uint32 distributionEnd;\n        // Map of user addresses and their rewards data (userAddress => userData)\n        mapping(address => UserData) usersData;\n    }\n\n    struct AssetData {\n        // Map of reward token addresses and their data (rewardTokenAddress => rewardData)\n        mapping(address => RewardData) rewards;\n        // List of reward token addresses for the asset\n        mapping(uint128 => address) availableRewards;\n        // Count of reward tokens for the asset\n        uint128 availableRewardsCount;\n        // Number of decimals of the asset\n        uint8 decimals;\n    }\n}\n"
    },
    "contracts/dlend/periphery/rewards/RewardsController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {VersionedInitializable} from \"contracts/dlend/core/protocol/libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport {SafeCast} from \"contracts/dlend/core/dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport {IAaveOracle} from \"contracts/dlend/core/interfaces/IAaveOracle.sol\";\nimport {IScaledBalanceToken} from \"contracts/dlend/core/interfaces/IScaledBalanceToken.sol\";\nimport {RewardsDistributor} from \"./RewardsDistributor.sol\";\nimport {IRewardsController} from \"./interfaces/IRewardsController.sol\";\nimport {ITransferStrategyBase} from \"./interfaces/ITransferStrategyBase.sol\";\nimport {IPullRewardsTransferStrategy} from \"./interfaces/IPullRewardsTransferStrategy.sol\";\nimport {RewardsDataTypes} from \"./libraries/RewardsDataTypes.sol\";\nimport {IERC20} from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20.sol\";\nimport {SafeERC20} from \"contracts/dlend/core/dependencies/openzeppelin/contracts/SafeERC20.sol\";\n\n/**\n * @title RewardsController\n * @notice Abstract contract template to build Distributors contracts for ERC20 rewards to protocol participants\n * @author Aave\n **/\ncontract RewardsController is\n    RewardsDistributor,\n    VersionedInitializable,\n    IRewardsController\n{\n    using SafeCast for uint256;\n\n    // Increment this value when deploying a new implementation\n    // Current testnet implementation: 4\n    uint256 public constant REVISION = 2;\n\n    // This mapping allows whitelisted addresses to claim on behalf of others\n    // useful for contracts that hold tokens to be rewarded but don't have any native logic to claim Liquidity Mining rewards\n    mapping(address => address) internal _authorizedClaimers;\n\n    // reward => transfer strategy implementation contract\n    // The TransferStrategy contract abstracts the logic regarding\n    // the source of the reward and how to transfer it to the user.\n    mapping(address => ITransferStrategyBase) internal _transferStrategy;\n\n    // This mapping contains the price oracle per reward.\n    // A price oracle is enforced for integrators to be able to show incentives at\n    // the current Aave UI without the need to setup an external price registry\n    // At the moment of reward configuration, the Incentives Controller performs\n    // a check to see if the provided reward oracle contains `getAssetPrice`.\n    mapping(address => IAaveOracle) internal _rewardOracle;\n\n    modifier onlyAuthorizedClaimers(address claimer, address user) {\n        require(_authorizedClaimers[user] == claimer, \"CLAIMER_UNAUTHORIZED\");\n        _;\n    }\n\n    constructor(address emissionManager) RewardsDistributor(emissionManager) {}\n\n    /**\n     * @dev Initialize for RewardsController\n     * @dev It expects an address as argument since its initialized via PoolAddressesProvider._updateImpl()\n     **/\n    function initialize(address) external initializer {}\n\n    /// @inheritdoc IRewardsController\n    function getClaimer(address user) external view override returns (address) {\n        return _authorizedClaimers[user];\n    }\n\n    /**\n     * @dev Returns the revision of the implementation contract\n     * @return uint256, current revision version\n     */\n    function getRevision() internal pure override returns (uint256) {\n        return REVISION;\n    }\n\n    /// @inheritdoc IRewardsController\n    function getRewardOracle(\n        address reward\n    ) external view override returns (address) {\n        return address(_rewardOracle[reward]);\n    }\n\n    /// @inheritdoc IRewardsController\n    function getTransferStrategy(\n        address reward\n    ) external view override returns (address) {\n        return address(_transferStrategy[reward]);\n    }\n\n    /// @inheritdoc IRewardsController\n    function configureAssets(\n        RewardsDataTypes.RewardsConfigInput[] memory config\n    ) external override onlyEmissionManager {\n        for (uint256 i = 0; i < config.length; i++) {\n            // Get the current Scaled Total Supply of AToken or Debt token\n            config[i].totalSupply = IScaledBalanceToken(config[i].asset)\n                .scaledTotalSupply();\n\n            // Install TransferStrategy logic at IncentivesController\n            _installTransferStrategy(\n                config[i].reward,\n                config[i].transferStrategy\n            );\n\n            // Set reward oracle, enforces input oracle to have latestPrice function\n            _setRewardOracle(config[i].reward, config[i].rewardOracle);\n        }\n        _configureAssets(config);\n    }\n\n    /// @inheritdoc IRewardsController\n    function setTransferStrategy(\n        address reward,\n        ITransferStrategyBase transferStrategy\n    ) external onlyEmissionManager {\n        _installTransferStrategy(reward, transferStrategy);\n    }\n\n    /// @inheritdoc IRewardsController\n    function setRewardOracle(\n        address reward,\n        IAaveOracle rewardOracle\n    ) external onlyEmissionManager {\n        _setRewardOracle(reward, rewardOracle);\n    }\n\n    /// @inheritdoc IRewardsController\n    function handleAction(\n        address user,\n        uint256 totalSupply,\n        uint256 userBalance\n    ) external override {\n        _updateData(msg.sender, user, userBalance, totalSupply);\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to,\n        address reward\n    ) external override returns (uint256) {\n        require(to != address(0), \"INVALID_TO_ADDRESS\");\n        return\n            _claimRewards(assets, amount, msg.sender, msg.sender, to, reward);\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to,\n        address reward\n    )\n        external\n        override\n        onlyAuthorizedClaimers(msg.sender, user)\n        returns (uint256)\n    {\n        require(user != address(0), \"INVALID_USER_ADDRESS\");\n        require(to != address(0), \"INVALID_TO_ADDRESS\");\n        return _claimRewards(assets, amount, msg.sender, user, to, reward);\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimRewardsToSelf(\n        address[] calldata assets,\n        uint256 amount,\n        address reward\n    ) external override returns (uint256) {\n        return\n            _claimRewards(\n                assets,\n                amount,\n                msg.sender,\n                msg.sender,\n                msg.sender,\n                reward\n            );\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimAllRewards(\n        address[] calldata assets,\n        address to\n    )\n        external\n        override\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts)\n    {\n        require(to != address(0), \"INVALID_TO_ADDRESS\");\n        return _claimAllRewards(assets, msg.sender, msg.sender, to);\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimAllRewardsOnBehalf(\n        address[] calldata assets,\n        address user,\n        address to\n    )\n        external\n        override\n        onlyAuthorizedClaimers(msg.sender, user)\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts)\n    {\n        require(user != address(0), \"INVALID_USER_ADDRESS\");\n        require(to != address(0), \"INVALID_TO_ADDRESS\");\n        return _claimAllRewards(assets, msg.sender, user, to);\n    }\n\n    /// @inheritdoc IRewardsController\n    function claimAllRewardsToSelf(\n        address[] calldata assets\n    )\n        external\n        override\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts)\n    {\n        return _claimAllRewards(assets, msg.sender, msg.sender, msg.sender);\n    }\n\n    /// @inheritdoc IRewardsController\n    function setClaimer(\n        address user,\n        address caller\n    ) external override onlyEmissionManager {\n        _authorizedClaimers[user] = caller;\n        emit ClaimerSet(user, caller);\n    }\n\n    /// @inheritdoc IRewardsController\n    function depositRewardFrom(\n        address reward,\n        uint256 amount,\n        address from\n    ) external onlyEmissionManager {\n        require(\n            _isRewardEnabled[reward] == true,\n            \"ONLY_ALLOW_DEPOSIT_TO_ENABLED_REWARD\"\n        );\n        address transferStrategyAddress = address(_transferStrategy[reward]);\n\n        try\n            IPullRewardsTransferStrategy(transferStrategyAddress)\n                .getRewardsVault()\n        returns (address vault) {\n            uint256 beforeTotalRewardSupply = IERC20(reward).balanceOf(vault);\n            uint256 expectAfterTotalRewardSupply = beforeTotalRewardSupply +\n                amount;\n            SafeERC20.safeTransferFrom(IERC20(reward), from, vault, amount);\n            uint256 afterTotalRewardSupplyAfterDeposit = IERC20(reward)\n                .balanceOf(vault);\n            require(\n                afterTotalRewardSupplyAfterDeposit ==\n                    expectAfterTotalRewardSupply,\n                \"INVALID_REWARD_DEPOSIT_AMOUNT\"\n            );\n        } catch {\n            revert(\"ONLY_ALLOW_DEPOSIT_TO_PULL_REWARDS_TRANSFER_STRATEGY\");\n        }\n    }\n\n    /**\n     * @dev Get user balances and total supply of all the assets specified by the assets parameter\n     * @param assets List of assets to retrieve user balance and total supply\n     * @param user Address of the user\n     * @return userAssetBalances contains a list of structs with user balance and total supply of the given assets\n     */\n    function _getUserAssetBalances(\n        address[] calldata assets,\n        address user\n    )\n        internal\n        view\n        override\n        returns (RewardsDataTypes.UserAssetBalance[] memory userAssetBalances)\n    {\n        userAssetBalances = new RewardsDataTypes.UserAssetBalance[](\n            assets.length\n        );\n        for (uint256 i = 0; i < assets.length; i++) {\n            userAssetBalances[i].asset = assets[i];\n            (\n                userAssetBalances[i].userBalance,\n                userAssetBalances[i].totalSupply\n            ) = IScaledBalanceToken(assets[i]).getScaledUserBalanceAndSupply(\n                user\n            );\n        }\n        return userAssetBalances;\n    }\n\n    /**\n     * @dev Claims one type of reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards.\n     * @param assets List of assets to check eligible distributions before claiming rewards\n     * @param amount Amount of rewards to claim\n     * @param claimer Address of the claimer who claims rewards on behalf of user\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @param reward Address of the reward token\n     * @return Rewards claimed\n     **/\n    function _claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address claimer,\n        address user,\n        address to,\n        address reward\n    ) internal returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n        uint256 totalRewards;\n\n        _updateDataMultiple(user, _getUserAssetBalances(assets, user));\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            totalRewards += _assets[asset]\n                .rewards[reward]\n                .usersData[user]\n                .accrued;\n\n            if (totalRewards <= amount) {\n                _assets[asset].rewards[reward].usersData[user].accrued = 0;\n            } else {\n                uint256 difference = totalRewards - amount;\n                totalRewards -= difference;\n                _assets[asset]\n                    .rewards[reward]\n                    .usersData[user]\n                    .accrued = difference.toUint128();\n                break;\n            }\n        }\n\n        if (totalRewards == 0) {\n            return 0;\n        }\n\n        _transferRewards(to, reward, totalRewards);\n        emit RewardsClaimed(user, reward, to, claimer, totalRewards);\n\n        return totalRewards;\n    }\n\n    /**\n     * @dev Claims one type of reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards.\n     * @param assets List of assets to check eligible distributions before claiming rewards\n     * @param claimer Address of the claimer on behalf of user\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @return\n     *   rewardsList List of reward addresses\n     *   claimedAmount List of claimed amounts, follows \"rewardsList\" items order\n     **/\n    function _claimAllRewards(\n        address[] calldata assets,\n        address claimer,\n        address user,\n        address to\n    )\n        internal\n        returns (address[] memory rewardsList, uint256[] memory claimedAmounts)\n    {\n        uint256 rewardsListLength = _rewardsList.length;\n        rewardsList = new address[](rewardsListLength);\n        claimedAmounts = new uint256[](rewardsListLength);\n\n        _updateDataMultiple(user, _getUserAssetBalances(assets, user));\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            for (uint256 j = 0; j < rewardsListLength; j++) {\n                if (rewardsList[j] == address(0)) {\n                    rewardsList[j] = _rewardsList[j];\n                }\n                uint256 rewardAmount = _assets[asset]\n                    .rewards[rewardsList[j]]\n                    .usersData[user]\n                    .accrued;\n                if (rewardAmount != 0) {\n                    claimedAmounts[j] += rewardAmount;\n                    _assets[asset]\n                        .rewards[rewardsList[j]]\n                        .usersData[user]\n                        .accrued = 0;\n                }\n            }\n        }\n        for (uint256 i = 0; i < rewardsListLength; i++) {\n            _transferRewards(to, rewardsList[i], claimedAmounts[i]);\n            emit RewardsClaimed(\n                user,\n                rewardsList[i],\n                to,\n                claimer,\n                claimedAmounts[i]\n            );\n        }\n        return (rewardsList, claimedAmounts);\n    }\n\n    /**\n     * @dev Function to transfer rewards to the desired account using delegatecall and\n     * @param to Account address to send the rewards\n     * @param reward Address of the reward token\n     * @param amount Amount of rewards to transfer\n     */\n    function _transferRewards(\n        address to,\n        address reward,\n        uint256 amount\n    ) internal {\n        ITransferStrategyBase transferStrategy = _transferStrategy[reward];\n\n        bool success = transferStrategy.performTransfer(to, reward, amount);\n\n        require(success == true, \"TRANSFER_ERROR\");\n    }\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     * @param account The address of the account\n     * @return bool, true if contract, false otherwise\n     */\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Internal function to call the optional install hook at the TransferStrategy\n     * @param reward The address of the reward token\n     * @param transferStrategy The address of the reward TransferStrategy\n     */\n    function _installTransferStrategy(\n        address reward,\n        ITransferStrategyBase transferStrategy\n    ) internal {\n        require(\n            address(transferStrategy) != address(0),\n            \"STRATEGY_CAN_NOT_BE_ZERO\"\n        );\n        require(\n            _isContract(address(transferStrategy)) == true,\n            \"STRATEGY_MUST_BE_CONTRACT\"\n        );\n\n        _transferStrategy[reward] = transferStrategy;\n\n        emit TransferStrategyInstalled(reward, address(transferStrategy));\n    }\n\n    /**\n     * @dev Update the Price Oracle of a reward token. The Price Oracle must follow IAaveOracle interface.\n     * @notice The Price Oracle of a reward is used for displaying correct data about the incentives at the UI frontend.\n     * @param reward The address of the reward token\n     * @param rewardOracle The address of the price oracle\n     */\n\n    function _setRewardOracle(\n        address reward,\n        IAaveOracle rewardOracle\n    ) internal {\n        require(\n            rewardOracle.getAssetPrice(rewardOracle.BASE_CURRENCY()) > 0,\n            \"ORACLE_MUST_RETURN_PRICE\"\n        );\n        _rewardOracle[reward] = rewardOracle;\n        emit RewardOracleUpdated(reward, address(rewardOracle));\n    }\n}\n"
    },
    "contracts/dlend/periphery/rewards/RewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport {IScaledBalanceToken} from \"contracts/dlend/core/interfaces/IScaledBalanceToken.sol\";\nimport {IERC20Detailed} from \"contracts/dlend/core/dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport {SafeCast} from \"contracts/dlend/core/dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport {IRewardsDistributor} from \"./interfaces/IRewardsDistributor.sol\";\nimport {RewardsDataTypes} from \"./libraries/RewardsDataTypes.sol\";\n\n/**\n * @title RewardsDistributor\n * @notice Accounting contract to manage multiple staking distributions with multiple rewards\n * @author Aave\n **/\nabstract contract RewardsDistributor is IRewardsDistributor {\n    using SafeCast for uint256;\n\n    // Manager of incentives\n    address public immutable EMISSION_MANAGER;\n    // Deprecated: This storage slot is kept for backwards compatibility purposes.\n    address internal _emissionManager;\n\n    // Map of rewarded asset addresses and their data (assetAddress => assetData)\n    mapping(address => RewardsDataTypes.AssetData) internal _assets;\n\n    // Map of reward assets (rewardAddress => enabled)\n    mapping(address => bool) internal _isRewardEnabled;\n\n    // Rewards list\n    address[] internal _rewardsList;\n\n    // Assets list\n    address[] internal _assetsList;\n\n    modifier onlyEmissionManager() {\n        require(msg.sender == EMISSION_MANAGER, \"ONLY_EMISSION_MANAGER\");\n        _;\n    }\n\n    constructor(address emissionManager) {\n        EMISSION_MANAGER = emissionManager;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getRewardsData(\n        address asset,\n        address reward\n    ) public view override returns (uint256, uint256, uint256, uint256) {\n        return (\n            _assets[asset].rewards[reward].index,\n            _assets[asset].rewards[reward].emissionPerSecond,\n            _assets[asset].rewards[reward].lastUpdateTimestamp,\n            _assets[asset].rewards[reward].distributionEnd\n        );\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getAssetIndex(\n        address asset,\n        address reward\n    ) external view override returns (uint256, uint256) {\n        RewardsDataTypes.RewardData storage rewardData = _assets[asset].rewards[\n            reward\n        ];\n        return\n            _getAssetIndex(\n                rewardData,\n                IScaledBalanceToken(asset).scaledTotalSupply(),\n                10 ** _assets[asset].decimals\n            );\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getDistributionEnd(\n        address asset,\n        address reward\n    ) external view override returns (uint256) {\n        return _assets[asset].rewards[reward].distributionEnd;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getRewardsByAsset(\n        address asset\n    ) external view override returns (address[] memory) {\n        uint128 rewardsCount = _assets[asset].availableRewardsCount;\n        address[] memory availableRewards = new address[](rewardsCount);\n\n        for (uint128 i = 0; i < rewardsCount; i++) {\n            availableRewards[i] = _assets[asset].availableRewards[i];\n        }\n        return availableRewards;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getRewardsList()\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return _rewardsList;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getUserAssetIndex(\n        address user,\n        address asset,\n        address reward\n    ) public view override returns (uint256) {\n        return _assets[asset].rewards[reward].usersData[user].index;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getUserAccruedRewards(\n        address user,\n        address reward\n    ) external view override returns (uint256) {\n        uint256 totalAccrued;\n        for (uint256 i = 0; i < _assetsList.length; i++) {\n            totalAccrued += _assets[_assetsList[i]]\n                .rewards[reward]\n                .usersData[user]\n                .accrued;\n        }\n\n        return totalAccrued;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getUserRewards(\n        address[] calldata assets,\n        address user,\n        address reward\n    ) external view override returns (uint256) {\n        return\n            _getUserReward(user, reward, _getUserAssetBalances(assets, user));\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getAllUserRewards(\n        address[] calldata assets,\n        address user\n    )\n        external\n        view\n        override\n        returns (\n            address[] memory rewardsList,\n            uint256[] memory unclaimedAmounts\n        )\n    {\n        RewardsDataTypes.UserAssetBalance[]\n            memory userAssetBalances = _getUserAssetBalances(assets, user);\n        rewardsList = new address[](_rewardsList.length);\n        unclaimedAmounts = new uint256[](rewardsList.length);\n\n        // Add unrealized rewards from user to unclaimedRewards\n        for (uint256 i = 0; i < userAssetBalances.length; i++) {\n            for (uint256 r = 0; r < rewardsList.length; r++) {\n                rewardsList[r] = _rewardsList[r];\n                unclaimedAmounts[r] += _assets[userAssetBalances[i].asset]\n                    .rewards[rewardsList[r]]\n                    .usersData[user]\n                    .accrued;\n\n                if (userAssetBalances[i].userBalance == 0) {\n                    continue;\n                }\n                unclaimedAmounts[r] += _getPendingRewards(\n                    user,\n                    rewardsList[r],\n                    userAssetBalances[i]\n                );\n            }\n        }\n        return (rewardsList, unclaimedAmounts);\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function setDistributionEnd(\n        address asset,\n        address reward,\n        uint32 newDistributionEnd\n    ) external override onlyEmissionManager {\n        uint256 oldDistributionEnd = _assets[asset]\n            .rewards[reward]\n            .distributionEnd;\n        _assets[asset].rewards[reward].distributionEnd = newDistributionEnd;\n\n        emit AssetConfigUpdated(\n            asset,\n            reward,\n            _assets[asset].rewards[reward].emissionPerSecond,\n            _assets[asset].rewards[reward].emissionPerSecond,\n            oldDistributionEnd,\n            newDistributionEnd,\n            _assets[asset].rewards[reward].index\n        );\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function setEmissionPerSecond(\n        address asset,\n        address[] calldata rewards,\n        uint88[] calldata newEmissionsPerSecond\n    ) external override onlyEmissionManager {\n        require(\n            rewards.length == newEmissionsPerSecond.length,\n            \"INVALID_INPUT\"\n        );\n        _setEmissionPerSecond(asset, rewards, newEmissionsPerSecond);\n    }\n\n    function _setEmissionPerSecond(\n        address asset,\n        // use memory instead of calldata because this function will be used for other internal function\n        address[] memory rewards,\n        uint88[] memory newEmissionsPerSecond\n    ) internal {\n        for (uint256 i = 0; i < rewards.length; i++) {\n            RewardsDataTypes.AssetData storage assetConfig = _assets[asset];\n            RewardsDataTypes.RewardData storage rewardConfig = _assets[asset]\n                .rewards[rewards[i]];\n            uint256 decimals = assetConfig.decimals;\n            require(\n                decimals != 0 && rewardConfig.lastUpdateTimestamp != 0,\n                \"DISTRIBUTION_DOES_NOT_EXIST\"\n            );\n\n            (uint256 newIndex, ) = _updateRewardData(\n                rewardConfig,\n                IScaledBalanceToken(asset).scaledTotalSupply(),\n                10 ** decimals\n            );\n\n            uint256 oldEmissionPerSecond = rewardConfig.emissionPerSecond;\n            rewardConfig.emissionPerSecond = newEmissionsPerSecond[i];\n\n            emit AssetConfigUpdated(\n                asset,\n                rewards[i],\n                oldEmissionPerSecond,\n                newEmissionsPerSecond[i],\n                rewardConfig.distributionEnd,\n                rewardConfig.distributionEnd,\n                newIndex\n            );\n        }\n    }\n\n    /**\n     * @dev Configure the _assets for a specific emission\n     * @param rewardsInput The array of each asset configuration\n     **/\n    function _configureAssets(\n        RewardsDataTypes.RewardsConfigInput[] memory rewardsInput\n    ) internal {\n        for (uint256 i = 0; i < rewardsInput.length; i++) {\n            if (_assets[rewardsInput[i].asset].decimals == 0) {\n                //never initialized before, adding to the list of assets\n                _assetsList.push(rewardsInput[i].asset);\n            }\n\n            uint256 decimals = _assets[rewardsInput[i].asset]\n                .decimals = IERC20Detailed(rewardsInput[i].asset).decimals();\n\n            RewardsDataTypes.RewardData storage rewardConfig = _assets[\n                rewardsInput[i].asset\n            ].rewards[rewardsInput[i].reward];\n\n            // Add reward address to asset available rewards if latestUpdateTimestamp is zero\n            if (rewardConfig.lastUpdateTimestamp == 0) {\n                _assets[rewardsInput[i].asset].availableRewards[\n                    _assets[rewardsInput[i].asset].availableRewardsCount\n                ] = rewardsInput[i].reward;\n                _assets[rewardsInput[i].asset].availableRewardsCount++;\n            }\n\n            // Add reward address to global rewards list if still not enabled\n            if (_isRewardEnabled[rewardsInput[i].reward] == false) {\n                _isRewardEnabled[rewardsInput[i].reward] = true;\n                _rewardsList.push(rewardsInput[i].reward);\n            }\n\n            // Due emissions is still zero, updates only latestUpdateTimestamp\n            (uint256 newIndex, ) = _updateRewardData(\n                rewardConfig,\n                rewardsInput[i].totalSupply,\n                10 ** decimals\n            );\n\n            // Configure emission and distribution end of the reward per asset\n            uint88 oldEmissionsPerSecond = rewardConfig.emissionPerSecond;\n            uint32 oldDistributionEnd = rewardConfig.distributionEnd;\n            rewardConfig.emissionPerSecond = rewardsInput[i].emissionPerSecond;\n            rewardConfig.distributionEnd = rewardsInput[i].distributionEnd;\n\n            emit AssetConfigUpdated(\n                rewardsInput[i].asset,\n                rewardsInput[i].reward,\n                oldEmissionsPerSecond,\n                rewardsInput[i].emissionPerSecond,\n                oldDistributionEnd,\n                rewardsInput[i].distributionEnd,\n                newIndex\n            );\n        }\n    }\n\n    /**\n     * @dev Updates the state of the distribution for the specified reward\n     * @param rewardData Storage pointer to the distribution reward config\n     * @param totalSupply Current total of underlying assets for this distribution\n     * @param assetUnit One unit of asset (10**decimals)\n     * @return The new distribution index\n     * @return True if the index was updated, false otherwise\n     **/\n    function _updateRewardData(\n        RewardsDataTypes.RewardData storage rewardData,\n        uint256 totalSupply,\n        uint256 assetUnit\n    ) internal returns (uint256, bool) {\n        (uint256 oldIndex, uint256 newIndex) = _getAssetIndex(\n            rewardData,\n            totalSupply,\n            assetUnit\n        );\n        bool indexUpdated;\n        if (newIndex != oldIndex) {\n            require(newIndex <= type(uint104).max, \"INDEX_OVERFLOW\");\n            indexUpdated = true;\n\n            //optimization: storing one after another saves one SSTORE\n            rewardData.index = uint104(newIndex);\n            rewardData.lastUpdateTimestamp = block.timestamp.toUint32();\n        } else {\n            rewardData.lastUpdateTimestamp = block.timestamp.toUint32();\n        }\n\n        return (newIndex, indexUpdated);\n    }\n\n    /**\n     * @dev Updates the state of the distribution for the specific user\n     * @param rewardData Storage pointer to the distribution reward config\n     * @param user The address of the user\n     * @param userBalance The user balance of the asset\n     * @param newAssetIndex The new index of the asset distribution\n     * @param assetUnit One unit of asset (10**decimals)\n     * @return The rewards accrued since the last update\n     **/\n    function _updateUserData(\n        RewardsDataTypes.RewardData storage rewardData,\n        address user,\n        uint256 userBalance,\n        uint256 newAssetIndex,\n        uint256 assetUnit\n    ) internal returns (uint256, bool) {\n        uint256 userIndex = rewardData.usersData[user].index;\n        uint256 rewardsAccrued;\n        bool dataUpdated;\n        if ((dataUpdated = userIndex != newAssetIndex)) {\n            // already checked for overflow in _updateRewardData\n            rewardData.usersData[user].index = uint104(newAssetIndex);\n            if (userBalance != 0) {\n                rewardsAccrued = _getRewards(\n                    userBalance,\n                    newAssetIndex,\n                    userIndex,\n                    assetUnit\n                );\n\n                rewardData.usersData[user].accrued += rewardsAccrued\n                    .toUint128();\n            }\n        }\n        return (rewardsAccrued, dataUpdated);\n    }\n\n    /**\n     * @dev Iterates and accrues all the rewards for asset of the specific user\n     * @param asset The address of the reference asset of the distribution\n     * @param user The user address\n     * @param userBalance The current user asset balance\n     * @param totalSupply Total supply of the asset\n     **/\n    function _updateData(\n        address asset,\n        address user,\n        uint256 userBalance,\n        uint256 totalSupply\n    ) internal {\n        uint256 assetUnit;\n        uint256 numAvailableRewards = _assets[asset].availableRewardsCount;\n        unchecked {\n            assetUnit = 10 ** _assets[asset].decimals;\n        }\n\n        if (numAvailableRewards == 0) {\n            return;\n        }\n        unchecked {\n            for (uint128 r = 0; r < numAvailableRewards; r++) {\n                address reward = _assets[asset].availableRewards[r];\n                RewardsDataTypes.RewardData storage rewardData = _assets[asset]\n                    .rewards[reward];\n\n                (\n                    uint256 newAssetIndex,\n                    bool rewardDataUpdated\n                ) = _updateRewardData(rewardData, totalSupply, assetUnit);\n\n                (\n                    uint256 rewardsAccrued,\n                    bool userDataUpdated\n                ) = _updateUserData(\n                        rewardData,\n                        user,\n                        userBalance,\n                        newAssetIndex,\n                        assetUnit\n                    );\n\n                if (rewardDataUpdated || userDataUpdated) {\n                    emit Accrued(\n                        asset,\n                        reward,\n                        user,\n                        newAssetIndex,\n                        newAssetIndex,\n                        rewardsAccrued\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Accrues all the rewards of the assets specified in the userAssetBalances list\n     * @param user The address of the user\n     * @param userAssetBalances List of structs with the user balance and total supply of a set of assets\n     **/\n    function _updateDataMultiple(\n        address user,\n        RewardsDataTypes.UserAssetBalance[] memory userAssetBalances\n    ) internal {\n        for (uint256 i = 0; i < userAssetBalances.length; i++) {\n            _updateData(\n                userAssetBalances[i].asset,\n                user,\n                userAssetBalances[i].userBalance,\n                userAssetBalances[i].totalSupply\n            );\n        }\n    }\n\n    /**\n     * @dev Return the accrued unclaimed amount of a reward from a user over a list of distribution\n     * @param user The address of the user\n     * @param reward The address of the reward token\n     * @param userAssetBalances List of structs with the user balance and total supply of a set of assets\n     * @return unclaimedRewards The accrued rewards for the user until the moment\n     **/\n    function _getUserReward(\n        address user,\n        address reward,\n        RewardsDataTypes.UserAssetBalance[] memory userAssetBalances\n    ) internal view returns (uint256 unclaimedRewards) {\n        // Add unrealized rewards\n        for (uint256 i = 0; i < userAssetBalances.length; i++) {\n            if (userAssetBalances[i].userBalance == 0) {\n                unclaimedRewards += _assets[userAssetBalances[i].asset]\n                    .rewards[reward]\n                    .usersData[user]\n                    .accrued;\n            } else {\n                unclaimedRewards +=\n                    _getPendingRewards(user, reward, userAssetBalances[i]) +\n                    _assets[userAssetBalances[i].asset]\n                        .rewards[reward]\n                        .usersData[user]\n                        .accrued;\n            }\n        }\n\n        return unclaimedRewards;\n    }\n\n    /**\n     * @dev Calculates the pending (not yet accrued) rewards since the last user action\n     * @param user The address of the user\n     * @param reward The address of the reward token\n     * @param userAssetBalance struct with the user balance and total supply of the incentivized asset\n     * @return The pending rewards for the user since the last user action\n     **/\n    function _getPendingRewards(\n        address user,\n        address reward,\n        RewardsDataTypes.UserAssetBalance memory userAssetBalance\n    ) internal view returns (uint256) {\n        RewardsDataTypes.RewardData storage rewardData = _assets[\n            userAssetBalance.asset\n        ].rewards[reward];\n        uint256 assetUnit = 10 ** _assets[userAssetBalance.asset].decimals;\n        (, uint256 nextIndex) = _getAssetIndex(\n            rewardData,\n            userAssetBalance.totalSupply,\n            assetUnit\n        );\n\n        return\n            _getRewards(\n                userAssetBalance.userBalance,\n                nextIndex,\n                rewardData.usersData[user].index,\n                assetUnit\n            );\n    }\n\n    /**\n     * @dev Internal function for the calculation of user's rewards on a distribution\n     * @param userBalance Balance of the user asset on a distribution\n     * @param reserveIndex Current index of the distribution\n     * @param userIndex Index stored for the user, representation his staking moment\n     * @param assetUnit One unit of asset (10**decimals)\n     * @return The rewards\n     **/\n    function _getRewards(\n        uint256 userBalance,\n        uint256 reserveIndex,\n        uint256 userIndex,\n        uint256 assetUnit\n    ) internal pure returns (uint256) {\n        uint256 result = userBalance * (reserveIndex - userIndex);\n        assembly {\n            result := div(result, assetUnit)\n        }\n        return result;\n    }\n\n    /**\n     * @dev Calculates the next value of an specific distribution index, with validations\n     * @param rewardData Storage pointer to the distribution reward config\n     * @param totalSupply of the asset being rewarded\n     * @param assetUnit One unit of asset (10**decimals)\n     * @return The new index.\n     **/\n    function _getAssetIndex(\n        RewardsDataTypes.RewardData storage rewardData,\n        uint256 totalSupply,\n        uint256 assetUnit\n    ) internal view returns (uint256, uint256) {\n        uint256 oldIndex = rewardData.index;\n        uint256 distributionEnd = rewardData.distributionEnd;\n        uint256 emissionPerSecond = rewardData.emissionPerSecond;\n        uint256 lastUpdateTimestamp = rewardData.lastUpdateTimestamp;\n\n        if (\n            emissionPerSecond == 0 ||\n            totalSupply == 0 ||\n            lastUpdateTimestamp == block.timestamp ||\n            lastUpdateTimestamp >= distributionEnd\n        ) {\n            return (oldIndex, oldIndex);\n        }\n\n        uint256 currentTimestamp = block.timestamp > distributionEnd\n            ? distributionEnd\n            : block.timestamp;\n        uint256 timeDelta = currentTimestamp - lastUpdateTimestamp;\n        uint256 firstTerm = emissionPerSecond * timeDelta * assetUnit;\n        assembly {\n            firstTerm := div(firstTerm, totalSupply)\n        }\n        return (oldIndex, (firstTerm + oldIndex));\n    }\n\n    /**\n     * @dev Get user balances and total supply of all the assets specified by the assets parameter\n     * @param assets List of assets to retrieve user balance and total supply\n     * @param user Address of the user\n     * @return userAssetBalances contains a list of structs with user balance and total supply of the given assets\n     */\n    function _getUserAssetBalances(\n        address[] calldata assets,\n        address user\n    )\n        internal\n        view\n        virtual\n        returns (RewardsDataTypes.UserAssetBalance[] memory userAssetBalances);\n\n    /// @inheritdoc IRewardsDistributor\n    function getAssetDecimals(address asset) external view returns (uint8) {\n        return _assets[asset].decimals;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function getEmissionManager() external view returns (address) {\n        return EMISSION_MANAGER;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}