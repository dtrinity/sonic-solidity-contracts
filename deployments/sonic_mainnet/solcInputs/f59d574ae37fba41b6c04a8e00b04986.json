{
  "language": "Solidity",
  "sources": {
    "contracts/oracle_aggregator/chainlink/ChainlinkCompositeAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nimport \"../interface/chainlink/IAggregatorV3Interface.sol\";\nimport \"../wrapper/ThresholdingUtils.sol\";\n\n/**\n * @title ChainlinkCompositeAggregator\n * @notice Composes prices from two Chainlink price feeds with thresholding\n * @dev Implements AggregatorV3Interface to mimic being a Chainlink price feed\n *      Uses the same composition logic as RedstoneChainlinkCompositeWrapperWithThresholding\n */\ncontract ChainlinkCompositeAggregator is AggregatorV3Interface, ThresholdingUtils {\n    /// @notice First source Chainlink price feed\n    AggregatorV3Interface public immutable sourceFeed1;\n\n    /// @notice Second source Chainlink price feed\n    AggregatorV3Interface public immutable sourceFeed2;\n\n    /// @notice Target decimals for composite price (Chainlink standard: 8)\n    uint8 public constant override decimals = 8;\n\n    /// @notice Base currency unit for price normalization (10^8)\n    uint256 public constant CHAINLINK_BASE_CURRENCY_UNIT = 10 ** 8;\n\n    /// @notice Primary threshold configuration for sourceFeed1\n    ThresholdConfig public primaryThreshold;\n\n    /// @notice Secondary threshold configuration for sourceFeed2\n    ThresholdConfig public secondaryThreshold;\n\n    /// @notice Chainlink heartbeat period (24 hours)\n    uint256 public constant CHAINLINK_HEARTBEAT = 86400;\n\n    /// @notice Heartbeat stale time limit (additional buffer)\n    uint256 public constant heartbeatStaleTimeLimit = 3600; // 1 hour\n\n    /// @notice Error thrown when price is stale\n    error PriceIsStale();\n\n    /// @notice Error thrown when a feed address is zero\n    error ZeroFeedAddress();\n\n    /**\n     * @notice Constructor to initialize the composite wrapper\n     * @param _sourceFeed1 Address of the first source Chainlink price feed\n     * @param _sourceFeed2 Address of the second source Chainlink price feed\n     * @param _primaryThreshold Primary threshold configuration for feed1\n     * @param _secondaryThreshold Secondary threshold configuration for feed2\n     */\n    constructor(\n        address _sourceFeed1,\n        address _sourceFeed2,\n        ThresholdConfig memory _primaryThreshold,\n        ThresholdConfig memory _secondaryThreshold\n    ) {\n        // Validate feed addresses\n        if (_sourceFeed1 == address(0) || _sourceFeed2 == address(0)) {\n            revert ZeroFeedAddress();\n        }\n\n        sourceFeed1 = AggregatorV3Interface(_sourceFeed1);\n        sourceFeed2 = AggregatorV3Interface(_sourceFeed2);\n        primaryThreshold = _primaryThreshold;\n        secondaryThreshold = _secondaryThreshold;\n    }\n\n    /**\n     * @notice Returns the description of the composite feed\n     * @return Description string\n     */\n    function description() external view override returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    sourceFeed1.description(),\n                    \" x \",\n                    sourceFeed2.description(),\n                    \" (Composite)\"\n                )\n            );\n    }\n\n    /**\n     * @notice Returns the version of the original feed\n     * @return Version number\n     */\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Gets data for the latest round\n     * @return roundId The round ID\n     * @return answer The composite price with target decimals\n     * @return startedAt The timestamp when the round started\n     * @return updatedAt The timestamp when the round was updated\n     * @return answeredInRound The round in which the answer was computed\n     */\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        // Get latest data from both feeds\n        (\n            uint80 roundId1,\n            int256 answer1,\n            uint256 startedAt1,\n            uint256 updatedAt1,\n            uint80 answeredInRound1\n        ) = sourceFeed1.latestRoundData();\n\n        (\n            ,\n            // roundId2,\n            int256 answer2,\n            uint256 startedAt2,\n            uint256 updatedAt2, // answeredInRound2\n\n        ) = sourceFeed2.latestRoundData();\n\n        // Check if prices are stale\n        if (\n            updatedAt1 + CHAINLINK_HEARTBEAT + heartbeatStaleTimeLimit <=\n            block.timestamp ||\n            updatedAt2 + CHAINLINK_HEARTBEAT + heartbeatStaleTimeLimit <=\n            block.timestamp\n        ) {\n            revert PriceIsStale();\n        }\n\n        // Use the latest timestamp from both feeds\n        uint256 latestUpdatedAt = updatedAt1 > updatedAt2\n            ? updatedAt1\n            : updatedAt2;\n        uint256 latestStartedAt = startedAt1 > startedAt2\n            ? startedAt1\n            : startedAt2;\n\n        // Calculate composite price using the same logic as Redstone wrapper\n        uint256 compositePrice = _calculateCompositePrice(answer1, answer2);\n\n        return (\n            roundId1, // Use the first feed's round ID\n            int256(compositePrice),\n            latestStartedAt,\n            latestUpdatedAt,\n            answeredInRound1 // Use the first feed's answeredInRound\n        );\n    }\n\n    /**\n     * @notice Gets data for a specific round\n     * @dev IMPORTANT: Due to Chainlink round ID divergence between feeds, this aggregator only supports latest data.\n     *      Historical round queries are not supported and will always return the latest available data.\n     *      Use latestRoundData() for the most recent price information.\n     * @param roundId (ignored, always returns latest data)\n     * @return roundId The round ID\n     * @return answer The composite price with target decimals\n     * @return startedAt The timestamp when the round started\n     * @return updatedAt The timestamp when the round was updated\n     * @return answeredInRound The round in which the answer was computed\n     */\n    function getRoundData(\n        uint80 /* _roundId */\n    )\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        // Delegate to latestRoundData to avoid round ID divergence issues\n        return this.latestRoundData();\n    }\n\n    /**\n     * @notice Calculate composite price using the same logic as Redstone wrapper\n     * @param answer1 Price from first feed\n     * @param answer2 Price from second feed\n     * @return Composite price in target decimals\n     */\n    function _calculateCompositePrice(\n        int256 answer1,\n        int256 answer2\n    ) internal view returns (uint256) {\n        // Convert negative answers to 0 (same as Redstone wrapper)\n        uint256 chainlinkPrice1 = answer1 > 0 ? uint256(answer1) : 0;\n        uint256 chainlinkPrice2 = answer2 > 0 ? uint256(answer2) : 0;\n\n        // Convert both prices to base currency unit first\n        uint256 priceInBase1 = _convertToBaseCurrencyUnit(\n            chainlinkPrice1,\n            sourceFeed1.decimals()\n        );\n        uint256 priceInBase2 = _convertToBaseCurrencyUnit(\n            chainlinkPrice2,\n            sourceFeed2.decimals()\n        );\n\n        // Apply thresholding to prices in base currency unit if specified\n        if (primaryThreshold.lowerThresholdInBase > 0) {\n            priceInBase1 = _applyThreshold(priceInBase1, primaryThreshold);\n        }\n        if (secondaryThreshold.lowerThresholdInBase > 0) {\n            priceInBase2 = _applyThreshold(priceInBase2, secondaryThreshold);\n        }\n\n        // Calculate composite price: (price1 * price2) / baseCurrencyUnit\n        return (priceInBase1 * priceInBase2) / CHAINLINK_BASE_CURRENCY_UNIT;\n    }\n\n    /**\n     * @notice Convert price to base currency unit (same logic as Redstone wrapper)\n     * @param price Price in source decimals\n     * @param sourceDecimals Decimal precision of the source price\n     * @return Price in base currency unit\n     */\n    function _convertToBaseCurrencyUnit(\n        uint256 price,\n        uint8 sourceDecimals\n    ) internal pure returns (uint256) {\n        if (sourceDecimals > decimals) {\n            // Scale down to target decimals\n            return price / (10 ** (sourceDecimals - decimals));\n        } else if (sourceDecimals < decimals) {\n            // Scale up to target decimals\n            return price * (10 ** (decimals - sourceDecimals));\n        }\n        return price;\n    }\n}\n"
    },
    "contracts/oracle_aggregator/interface/chainlink/IAggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/oracle_aggregator/wrapper/ThresholdingUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* ———————————————————————————————————————————————————————————————————————————————— *\n *    _____     ______   ______     __     __   __     __     ______   __  __       *\n *   /\\  __-.  /\\__  _\\ /\\  == \\   /\\ \\   /\\ \"-.\\ \\   /\\ \\   /\\__  _\\ /\\ \\_\\ \\      *\n *   \\ \\ \\/\\ \\ \\/_/\\ \\/ \\ \\  __<   \\ \\ \\  \\ \\ \\-.  \\  \\ \\ \\  \\/_/\\ \\/ \\ \\____ \\     *\n *    \\ \\____-    \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\    \\ \\_\\  \\/\\_____\\    *\n *     \\/____/     \\/_/   \\/_/ /_/   \\/_/   \\/_/ \\/_/   \\/_/     \\/_/   \\/_____/    *\n *                                                                                  *\n * ————————————————————————————————— dtrinity.org ————————————————————————————————— *\n *                                                                                  *\n *                                         ▲                                        *\n *                                        ▲ ▲                                       *\n *                                                                                  *\n * ———————————————————————————————————————————————————————————————————————————————— *\n * dTRINITY Protocol: https://github.com/dtrinity                                   *\n * ———————————————————————————————————————————————————————————————————————————————— */\n\npragma solidity ^0.8.20;\n\nabstract contract ThresholdingUtils {\n    /* Types */\n    struct ThresholdConfig {\n        /// @notice The minimum price after which thresholding is applied. Not a price cap, but a trigger point.\n        /// @dev If lowerThresholdInBase == fixedPriceInBase: Acts as an upper threshold\n        /// @dev If lowerThresholdInBase < fixedPriceInBase: Acts as \"price rounding up\" (e.g. if USDC > 0.997 then round to 1)\n        /// @dev If lowerThresholdInBase > fixedPriceInBase: Acts as \"price rounding down\" (e.g. if USDC > 1.003 then round to 1)\n        uint256 lowerThresholdInBase;\n        uint256 fixedPriceInBase;\n    }\n\n    /**\n     * @notice Apply threshold to a price value\n     * @param priceInBase The price to check against threshold\n     * @param thresholdConfig The threshold configuration\n     * @return The original price or fixed price based on threshold\n     */\n    function _applyThreshold(\n        uint256 priceInBase,\n        ThresholdConfig memory thresholdConfig\n    ) internal pure returns (uint256) {\n        if (priceInBase > thresholdConfig.lowerThresholdInBase) {\n            return thresholdConfig.fixedPriceInBase;\n        }\n        return priceInBase;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}