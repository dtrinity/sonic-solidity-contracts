# Smart Contract Vulnerability Catalog

## Table of Contents

1. [Common Vulnerability Categories](#common-vulnerability-categories)
2. [DeFi-Specific Vulnerabilities](#defi-specific-vulnerabilities)
3. [Solidity-Specific Issues](#solidity-specific-issues)
4. [Attack Patterns](#attack-patterns)
5. [Detection Methods](#detection-methods)
6. [Remediation Strategies](#remediation-strategies)

---

## Common Vulnerability Categories

### 1. Reentrancy Attacks (SWC-107)

**Description**: Occurs when external contract calls are made before state changes are finalized, allowing malicious contracts to re-enter the function.

**Types**:
- Single-function reentrancy
- Cross-function reentrancy
- Cross-contract reentrancy
- Read-only reentrancy

**Example**:
```solidity
// VULNERABLE
contract Vulnerable {
    mapping(address => uint256) public balances;
    
    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount);
        
        // External call before state update - VULNERABLE!
        (bool success,) = msg.sender.call{value: amount}("");
        require(success);
        
        balances[msg.sender] -= amount;
    }
}
```

**Detection Pattern**:
- External calls before state updates
- Missing reentrancy guards
- Callbacks in the middle of state transitions

**Remediation**:
```solidity
// SECURE - Using Checks-Effects-Interactions pattern
contract Secure {
    mapping(address => uint256) public balances;
    
    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount);
        
        // Update state first
        balances[msg.sender] -= amount;
        
        // External call last
        (bool success,) = msg.sender.call{value: amount}("");
        require(success);
    }
}

// SECURE - Using ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SecureWithGuard is ReentrancyGuard {
    function withdraw(uint256 amount) external nonReentrant {
        // Function logic
    }
}
```

### 2. Integer Overflow/Underflow (SWC-101)

**Description**: Arithmetic operations that exceed the maximum or minimum values for integer types.

**Note**: Solidity 0.8.0+ has built-in overflow protection, but unchecked blocks and assembly bypass this.

**Example**:
```solidity
// VULNERABLE (pre-0.8.0 or in unchecked block)
contract Vulnerable {
    uint8 public counter = 255;
    
    function increment() external {
        unchecked {
            counter++; // Wraps to 0
        }
    }
}
```

**Detection Pattern**:
- `unchecked` blocks with arithmetic
- Assembly code with arithmetic operations
- Multiplication before division
- Type casting between different integer sizes

**Remediation**:
```solidity
// SECURE
contract Secure {
    uint256 public counter;
    
    function increment() external {
        // Automatic overflow protection in Solidity 0.8+
        counter++;
        
        // Or use SafeMath for older versions
        // counter = counter.add(1);
    }
    
    // For necessary unchecked operations
    function optimizedMath(uint256 a, uint256 b) external pure returns (uint256) {
        require(a <= type(uint256).max - b, "Overflow");
        unchecked {
            return a + b;
        }
    }
}
```

### 3. Access Control Issues (SWC-105, SWC-106)

**Description**: Improper or missing access controls allowing unauthorized actions.

**Types**:
- Missing access modifiers
- Incorrect visibility
- Unprotected initialization
- Centralization risks

**Example**:
```solidity
// VULNERABLE
contract Vulnerable {
    address public owner;
    
    // Missing access control
    function setOwner(address newOwner) external {
        owner = newOwner;
    }
    
    // Unprotected initialization
    function initialize(address _owner) external {
        owner = _owner;
    }
}
```

**Detection Pattern**:
- Public/external functions modifying critical state
- Missing `onlyOwner` or role checks
- Unprotected `initialize` functions
- Default visibility functions

**Remediation**:
```solidity
// SECURE
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/proxy/utils/Initializable.sol";

contract Secure is Ownable, Initializable {
    function setOwner(address newOwner) external onlyOwner {
        transferOwnership(newOwner);
    }
    
    function initialize(address _owner) external initializer {
        _transferOwnership(_owner);
    }
}
```

### 4. Front-running/MEV Attacks (SWC-114)

**Description**: Transactions can be seen in the mempool before execution, allowing attackers to place their transactions first.

**Types**:
- Displacement attacks
- Insertion attacks
- Suppression attacks

**Example**:
```solidity
// VULNERABLE
contract Vulnerable {
    uint256 public prize = 1 ether;
    bytes32 public hashedSolution;
    
    function submitSolution(string memory solution) external {
        require(keccak256(abi.encode(solution)) == hashedSolution);
        // Attacker can see solution in mempool and front-run
        payable(msg.sender).transfer(prize);
    }
}
```

**Detection Pattern**:
- Predictable outcomes based on transaction data
- Lack of commit-reveal schemes
- Price-sensitive operations without slippage protection

**Remediation**:
```solidity
// SECURE - Commit-Reveal Pattern
contract Secure {
    mapping(address => bytes32) private commitments;
    mapping(address => uint256) private commitTimestamps;
    
    function commit(bytes32 hashedSolution) external {
        commitments[msg.sender] = hashedSolution;
        commitTimestamps[msg.sender] = block.timestamp;
    }
    
    function reveal(string memory solution, uint256 nonce) external {
        require(block.timestamp >= commitTimestamps[msg.sender] + 1 days);
        require(keccak256(abi.encode(solution, nonce)) == commitments[msg.sender]);
        // Process solution
    }
}
```

### 5. Oracle Manipulation

**Description**: External price feeds can be manipulated, leading to incorrect protocol behavior.

**Types**:
- Spot price manipulation
- TWAP manipulation
- Oracle downtime
- Stale price data

**Example**:
```solidity
// VULNERABLE
contract Vulnerable {
    IUniswapV2Pair public pair;
    
    function getPrice() external view returns (uint256) {
        (uint112 reserve0, uint112 reserve1,) = pair.getReserves();
        // Spot price - easily manipulated with flash loans
        return uint256(reserve1) * 1e18 / uint256(reserve0);
    }
}
```

**Detection Pattern**:
- Direct DEX reserve queries
- Single oracle dependencies
- Missing price staleness checks
- No price deviation checks

**Remediation**:
```solidity
// SECURE
contract Secure {
    AggregatorV3Interface public priceFeed;
    uint256 public constant MAX_PRICE_DEVIATION = 500; // 5%
    uint256 public constant MAX_PRICE_AGE = 3600; // 1 hour
    
    function getPrice() external view returns (uint256) {
        (
            uint80 roundId,
            int256 price,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        
        require(updatedAt > 0, "Round not complete");
        require(block.timestamp - updatedAt < MAX_PRICE_AGE, "Price too old");
        require(price > 0, "Invalid price");
        
        return uint256(price);
    }
}
```

### 6. Economic Attacks

**Description**: Exploiting protocol economics rather than code vulnerabilities.

**Types**:
- Governance attacks
- Liquidity draining
- Fee manipulation
- Griefing attacks

**Example**:
```solidity
// VULNERABLE - No minimum liquidity
contract Vulnerable {
    uint256 public totalShares;
    uint256 public totalAssets;
    
    function deposit(uint256 assets) external returns (uint256 shares) {
        if (totalShares == 0) {
            shares = assets; // First depositor controls exchange rate
        } else {
            shares = assets * totalShares / totalAssets;
        }
        totalShares += shares;
        totalAssets += assets;
    }
}
```

**Detection Pattern**:
- First depositor advantages
- Missing minimum liquidity locks
- Unrestricted minting/burning
- Lack of fee mechanisms

**Remediation**:
```solidity
// SECURE
contract Secure {
    uint256 public totalShares;
    uint256 public totalAssets;
    uint256 public constant MINIMUM_LIQUIDITY = 1000;
    
    function deposit(uint256 assets) external returns (uint256 shares) {
        if (totalShares == 0) {
            shares = assets - MINIMUM_LIQUIDITY;
            totalShares = MINIMUM_LIQUIDITY; // Lock minimum liquidity
        } else {
            shares = assets * totalShares / totalAssets;
        }
        totalShares += shares;
        totalAssets += assets;
    }
}
```

---

## DeFi-Specific Vulnerabilities

### 1. Flash Loan Attacks

**Description**: Exploiting protocols using uncollateralized loans within a single transaction.

**Attack Vectors**:
- Price oracle manipulation
- Governance token borrowing
- Liquidity pool manipulation
- Arbitrage amplification

**Example**:
```solidity
// VULNERABLE - Relies on spot price
contract Vulnerable {
    function liquidate(address user) external {
        uint256 price = getSpotPrice(); // Can be manipulated with flash loan
        uint256 collateralValue = collateral[user] * price;
        require(collateralValue < debt[user] * 150 / 100, "Not liquidatable");
        // Liquidation logic
    }
}
```

**Detection Pattern**:
- Spot price dependencies
- Same-block price updates
- Unprotected liquidation thresholds
- Missing flash loan protection

**Remediation**:
```solidity
// SECURE
contract Secure {
    mapping(address => uint256) private lastUpdateBlock;
    
    modifier flashLoanProtection() {
        require(lastUpdateBlock[msg.sender] < block.number, "Same block update");
        lastUpdateBlock[msg.sender] = block.number;
        _;
    }
    
    function liquidate(address user) external flashLoanProtection {
        uint256 price = getTWAPPrice(); // Use TWAP instead of spot
        // Liquidation logic
    }
}
```

### 2. Price Manipulation

**Description**: Manipulating asset prices to exploit protocols.

**Types**:
- AMM pool manipulation
- Oracle front-running
- Multi-block attacks
- Cross-protocol manipulation

**Example**:
```solidity
// VULNERABLE
contract Vulnerable {
    function swap(uint256 amountIn) external returns (uint256 amountOut) {
        uint256 price = getPoolPrice();
        amountOut = amountIn * price / 1e18;
        // No slippage protection
    }
}
```

**Detection Pattern**:
- Direct pool price queries
- Missing slippage protection
- No price impact calculations
- Single-source price feeds

**Remediation**:
```solidity
// SECURE
contract Secure {
    uint256 public constant MAX_SLIPPAGE = 300; // 3%
    
    function swap(
        uint256 amountIn,
        uint256 minAmountOut
    ) external returns (uint256 amountOut) {
        uint256 price = getOraclePrice(); // Use oracle instead of pool
        amountOut = calculateAmountOut(amountIn, price);
        
        require(amountOut >= minAmountOut, "Excessive slippage");
        require(
            amountOut >= amountIn * price * (10000 - MAX_SLIPPAGE) / 10000 / 1e18,
            "Price impact too high"
        );
    }
}
```

### 3. Liquidity Attacks

**Description**: Exploiting liquidity provision and removal mechanisms.

**Types**:
- Sandwich attacks
- JIT (Just-In-Time) liquidity
- Impermanent loss amplification
- LP token manipulation

**Example**:
```solidity
// VULNERABLE - No lock period
contract Vulnerable {
    function addLiquidity(uint256 amount) external {
        lpTokens[msg.sender] += amount;
        totalLiquidity += amount;
    }
    
    function removeLiquidity(uint256 amount) external {
        lpTokens[msg.sender] -= amount;
        totalLiquidity -= amount;
        // Immediate withdrawal allows sandwich attacks
    }
}
```

**Detection Pattern**:
- No minimum lock periods
- Missing fee mechanisms
- Unrestricted liquidity operations
- LP token price manipulation

**Remediation**:
```solidity
// SECURE
contract Secure {
    mapping(address => uint256) public lastDepositTime;
    uint256 public constant MIN_LOCK_TIME = 1 days;
    uint256 public constant WITHDRAWAL_FEE = 30; // 0.3%
    
    function addLiquidity(uint256 amount) external {
        lastDepositTime[msg.sender] = block.timestamp;
        // Add liquidity logic
    }
    
    function removeLiquidity(uint256 amount) external {
        require(
            block.timestamp >= lastDepositTime[msg.sender] + MIN_LOCK_TIME,
            "Lock period not met"
        );
        
        uint256 fee = amount * WITHDRAWAL_FEE / 10000;
        uint256 amountAfterFee = amount - fee;
        // Remove liquidity logic
    }
}
```

### 4. Sandwich Attacks

**Description**: Front-running and back-running user transactions for profit.

**Attack Pattern**:
1. Detect large trade in mempool
2. Front-run with buy order
3. User's trade executes (moves price)
4. Back-run with sell order

**Example**:
```solidity
// VULNERABLE - No protection
contract Vulnerable {
    function swap(address tokenIn, address tokenOut, uint256 amountIn) external {
        uint256 amountOut = getAmountOut(amountIn);
        // No slippage or MEV protection
        transfer(tokenOut, msg.sender, amountOut);
    }
}
```

**Detection Pattern**:
- Public mempool visibility
- No commit-reveal mechanism
- Missing slippage parameters
- Large price impact trades

**Remediation**:
```solidity
// SECURE
contract Secure {
    mapping(address => uint256) private lastBlockTraded;
    
    function swap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 deadline
    ) external {
        require(block.timestamp <= deadline, "Transaction expired");
        require(lastBlockTraded[msg.sender] < block.number, "Already traded this block");
        
        lastBlockTraded[msg.sender] = block.number;
        
        uint256 amountOut = getAmountOut(amountIn);
        require(amountOut >= minAmountOut, "Insufficient output");
        
        // MEV protection through private mempool or commit-reveal
    }
}
```

### 5. Governance Attacks

**Description**: Exploiting governance mechanisms to gain control or extract value.

**Types**:
- Flash loan governance attacks
- Vote buying
- Proposal spam
- Time-based manipulation

**Example**:
```solidity
// VULNERABLE - No flash loan protection
contract Vulnerable {
    function propose(address target, bytes memory data) external {
        require(balanceOf(msg.sender) >= proposalThreshold);
        // Create proposal - tokens can be flash loaned
    }
    
    function vote(uint256 proposalId) external {
        uint256 votes = balanceOf(msg.sender); // Current balance
        // Record votes
    }
}
```

**Detection Pattern**:
- Snapshot-less voting
- No vote delegation checks
- Missing time locks
- Flash loan vulnerabilities

**Remediation**:
```solidity
// SECURE
contract Secure {
    mapping(uint256 => uint256) public proposalSnapshots;
    mapping(address => mapping(uint256 => uint256)) public checkpoints;
    
    function propose(address target, bytes memory data) external returns (uint256 proposalId) {
        uint256 blockNumber = block.number - 1; // Previous block
        require(getPriorVotes(msg.sender, blockNumber) >= proposalThreshold);
        
        proposalId = proposalCount++;
        proposalSnapshots[proposalId] = blockNumber;
    }
    
    function vote(uint256 proposalId) external {
        uint256 snapshot = proposalSnapshots[proposalId];
        uint256 votes = getPriorVotes(msg.sender, snapshot);
        // Record votes based on historical balance
    }
}
```

---

## Solidity-Specific Issues

### 1. Storage Collisions

**Description**: Improper storage layout causing variable overwrites.

**Types**:
- Proxy storage collisions
- Inheritance storage conflicts
- Struct packing issues
- Dynamic array overwrites

**Example**:
```solidity
// VULNERABLE - Storage collision in proxy
contract Implementation {
    address public owner; // Slot 0
    uint256 public value; // Slot 1
}

contract Proxy {
    address public implementation; // Slot 0 - Collides!
    
    function upgrade(address newImpl) external {
        implementation = newImpl; // Overwrites owner in logic contract
    }
}
```

**Detection Pattern**:
- Proxy patterns without storage gaps
- Multiple inheritance
- Unstructured storage access
- Assembly storage operations

**Remediation**:
```solidity
// SECURE - Using storage gaps and EIP-1967
contract Implementation {
    uint256[50] private __gap; // Reserve storage slots
    address public owner;
    uint256 public value;
}

contract Proxy {
    // EIP-1967 storage slot
    bytes32 private constant IMPLEMENTATION_SLOT = 
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    
    function upgrade(address newImpl) external {
        assembly {
            sstore(IMPLEMENTATION_SLOT, newImpl)
        }
    }
}
```

### 2. Delegatecall Vulnerabilities

**Description**: Improper use of delegatecall leading to context manipulation.

**Types**:
- Storage context confusion
- msg.sender preservation
- Arbitrary code execution
- Proxy implementation attacks

**Example**:
```solidity
// VULNERABLE
contract Vulnerable {
    address public owner;
    
    function delegateCall(address target, bytes memory data) external {
        (bool success,) = target.delegatecall(data);
        require(success);
        // Allows arbitrary storage manipulation
    }
}
```

**Detection Pattern**:
- Unrestricted delegatecall
- Dynamic target addresses
- Missing storage layout validation
- No access control on delegation

**Remediation**:
```solidity
// SECURE
contract Secure {
    address public owner;
    mapping(address => bool) public allowedTargets;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    function setAllowedTarget(address target, bool allowed) external onlyOwner {
        allowedTargets[target] = allowed;
    }
    
    function delegateCall(address target, bytes memory data) external onlyOwner {
        require(allowedTargets[target], "Target not allowed");
        (bool success,) = target.delegatecall(data);
        require(success, "Delegatecall failed");
    }
}
```

### 3. Gas Griefing

**Description**: Malicious actors causing excessive gas consumption.

**Types**:
- Unbounded loops
- Large data operations
- Denial of service
- Block gas limit attacks

**Example**:
```solidity
// VULNERABLE - Unbounded loop
contract Vulnerable {
    address[] public users;
    
    function distributeRewards() external {
        for (uint i = 0; i < users.length; i++) {
            // Gas cost grows with array size
            payable(users[i]).transfer(1 ether);
        }
    }
}
```

**Detection Pattern**:
- Loops over dynamic arrays
- External calls in loops
- Unbounded data structures
- No gas limits on operations

**Remediation**:
```solidity
// SECURE - Paginated approach
contract Secure {
    address[] public users;
    uint256 public lastProcessedIndex;
    
    function distributeRewards(uint256 batchSize) external {
        uint256 end = lastProcessedIndex + batchSize;
        if (end > users.length) {
            end = users.length;
        }
        
        for (uint256 i = lastProcessedIndex; i < end; i++) {
            payable(users[i]).transfer(1 ether);
        }
        
        lastProcessedIndex = end;
        if (lastProcessedIndex >= users.length) {
            lastProcessedIndex = 0; // Reset for next round
        }
    }
}
```

### 4. Compiler Bugs

**Description**: Known compiler issues affecting contract behavior.

**Notable Issues**:
- Storage array encoding (< 0.8.0)
- ABI encoder v2 bugs (< 0.8.0)
- Optimizer bugs
- Memory cleanup issues

**Example**:
```solidity
// VULNERABLE - Using old compiler
pragma solidity 0.7.6;

contract Vulnerable {
    // Subject to various compiler bugs
    bytes public data;
    
    function encode(uint256[] memory values) external {
        data = abi.encode(values); // Potential encoding bugs
    }
}
```

**Detection Pattern**:
- Old compiler versions
- Complex ABI encoding
- Inline assembly usage
- Optimizer enabled with complex logic

**Remediation**:
```solidity
// SECURE - Latest stable compiler
pragma solidity 0.8.20;

contract Secure {
    bytes public data;
    
    function encode(uint256[] memory values) external {
        // Modern compiler with bug fixes
        data = abi.encode(values);
    }
}
```

---

## Attack Patterns

### 1. Initialization Attacks

**Pattern**: Exploiting uninitialized contracts or front-running initialization.

```solidity
// ATTACK SCENARIO
contract VulnerableProxy {
    address public implementation;
    address public owner;
    bool public initialized;
    
    function initialize(address _owner) external {
        require(!initialized, "Already initialized");
        owner = _owner;
        initialized = true;
    }
}

// Attacker can:
// 1. Front-run initialization transaction
// 2. Call initialize with attacker address
// 3. Gain control of the contract
```

**Prevention**:
```solidity
contract SecureProxy {
    address public implementation;
    address public owner;
    
    // Initialize in constructor for proxy
    constructor(address _owner) {
        owner = _owner;
    }
    
    // Or use initializer modifier
    function initialize(address _owner) external initializer {
        __Ownable_init();
        transferOwnership(_owner);
    }
}
```

### 2. Approval Attacks

**Pattern**: Exploiting token approval mechanisms.

```solidity
// ATTACK SCENARIO
// 1. User approves contract for 100 tokens
// 2. User wants to change approval to 200 tokens
// 3. Attacker front-runs the approval change
// 4. Attacker spends original 100 tokens
// 5. New approval for 200 tokens goes through
// 6. Attacker can spend 200 more tokens (300 total)
```

**Prevention**:
```solidity
contract SecureToken {
    // Use increase/decrease allowance pattern
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, allowances[msg.sender][spender] + addedValue);
        return true;
    }
    
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        uint256 currentAllowance = allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, "Decreased allowance below zero");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }
}
```

### 3. Signature Replay Attacks

**Pattern**: Reusing signatures in different contexts.

```solidity
// VULNERABLE
contract Vulnerable {
    function withdraw(uint256 amount, bytes memory signature) external {
        bytes32 hash = keccak256(abi.encodePacked(msg.sender, amount));
        address signer = recoverSigner(hash, signature);
        require(signer == owner, "Invalid signature");
        
        // Signature can be replayed!
        payable(msg.sender).transfer(amount);
    }
}
```

**Prevention**:
```solidity
contract Secure {
    mapping(bytes32 => bool) public usedSignatures;
    uint256 public nonce;
    
    function withdraw(
        uint256 amount,
        uint256 nonce,
        uint256 deadline,
        bytes memory signature
    ) external {
        require(block.timestamp <= deadline, "Signature expired");
        
        bytes32 hash = keccak256(abi.encodePacked(
            msg.sender,
            amount,
            nonce,
            deadline,
            address(this),
            block.chainid
        ));
        
        require(!usedSignatures[hash], "Signature already used");
        usedSignatures[hash] = true;
        
        address signer = recoverSigner(hash, signature);
        require(signer == owner, "Invalid signature");
        
        payable(msg.sender).transfer(amount);
    }
}
```

### 4. Time Manipulation Attacks

**Pattern**: Exploiting block timestamp dependencies.

```solidity
// VULNERABLE
contract Vulnerable {
    uint256 public lastAction;
    
    function action() external {
        require(block.timestamp >= lastAction + 1 days, "Too soon");
        
        // Miner can manipulate timestamp within ~900 seconds
        if (block.timestamp % 1000 == 0) {
            // Special reward - predictable!
            payable(msg.sender).transfer(1 ether);
        }
        
        lastAction = block.timestamp;
    }
}
```

**Prevention**:
```solidity
contract Secure {
    uint256 public lastActionBlock;
    uint256 private seed;
    
    function action() external {
        require(block.number >= lastActionBlock + 6500, "Too soon"); // ~1 day in blocks
        
        // Use block hash for randomness (still not perfect but better)
        bytes32 blockHash = blockhash(block.number - 1);
        uint256 random = uint256(keccak256(abi.encodePacked(blockHash, seed, msg.sender)));
        
        if (random % 1000 == 0) {
            payable(msg.sender).transfer(1 ether);
        }
        
        lastActionBlock = block.number;
        seed = random;
    }
}
```

---

## Detection Methods

### 1. Static Analysis Tools

**Slither**:
```bash
# Install
pip3 install slither-analyzer

# Basic scan
slither .

# Specific detectors
slither . --detect reentrancy-eth,arbitrary-send,suicidal

# Generate inheritance graph
slither . --print inheritance-graph

# Check upgradeability
slither-check-upgradeability --proxy-address [0x...] --new-implementation [0x...]
```

**Mythril**:
```bash
# Install
pip3 install mythril

# Analyze contract
myth analyze contract.sol

# Deep analysis with symbolic execution
myth analyze contract.sol --execution-timeout 900 --solver-timeout 60000

# Check specific functions
myth analyze contract.sol --function "withdraw(uint256)"
```

### 2. Code Patterns to Review

**High-Risk Patterns**:
```solidity
// External calls
.call{value: }()
.delegatecall()
.transfer()
.send()

// State changes after external calls
balances[msg.sender] = 0; // Should be before transfer

// Unrestricted functions
function kill() external { // No access control
    selfdestruct(payable(msg.sender));
}

// Unsafe math (pre-0.8.0)
uint256 result = a + b; // No overflow check

// Storage manipulation
assembly {
    sstore(slot, value) // Direct storage access
}

// Timestamp dependencies
if (block.timestamp > deadline) { }

// Blockhash randomness
uint256 random = uint256(blockhash(block.number));
```

### 3. Manual Review Checklist

**Access Control**:
- [ ] All admin functions have proper modifiers
- [ ] Initialization can only happen once
- [ ] Role management is properly implemented
- [ ] No default admin roles assigned to deployer

**External Calls**:
- [ ] CEI pattern followed
- [ ] Reentrancy guards on all stateful functions
- [ ] Return values checked
- [ ] Gas forwarding considered

**Math Operations**:
- [ ] Overflow/underflow protection
- [ ] Division by zero checks
- [ ] Rounding errors considered
- [ ] Precision loss minimized

**Input Validation**:
- [ ] All inputs sanitized
- [ ] Array bounds checked
- [ ] Address(0) checks
- [ ] Parameter ranges validated

---

## Remediation Strategies

### 1. Security Framework Implementation

```solidity
// Base security contract
abstract contract SecureBase is 
    Initializable,
    PausableUpgradeable,
    AccessControlUpgradeable,
    ReentrancyGuardUpgradeable 
{
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");
    
    // Storage gap for upgrades
    uint256[50] private __gap;
    
    function __SecureBase_init(address admin) internal onlyInitializing {
        __Pausable_init();
        __AccessControl_init();
        __ReentrancyGuard_init();
        
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setupRole(ADMIN_ROLE, admin);
    }
    
    modifier onlyAdmin() {
        require(hasRole(ADMIN_ROLE, msg.sender), "Not admin");
        _;
    }
    
    modifier validAddress(address addr) {
        require(addr != address(0), "Zero address");
        _;
    }
}
```

### 2. Safe Math Patterns

```solidity
library SafeFinancialMath {
    uint256 constant WAD = 1e18;
    uint256 constant RAY = 1e27;
    
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        uint256 prod0;
        uint256 prod1;
        assembly {
            let mm := mulmod(x, y, not(0))
            prod0 := mul(x, y)
            prod1 := sub(sub(mm, prod0), lt(mm, prod0))
        }
        
        require(denominator > prod1, "Math: mulDiv overflow");
        
        assembly {
            result := div(
                or(
                    mul(prod0, iszero(iszero(prod1))),
                    mul(
                        div(sub(prod0, mod(prod0, denominator)), denominator),
                        iszero(prod1)
                    )
                ),
                denominator
            )
        }
    }
}
```

### 3. Oracle Security

```solidity
contract SecureOracle {
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 confidence;
    }
    
    mapping(address => PriceData) public prices;
    mapping(address => bool) public priceProviders;
    
    uint256 public constant MIN_PROVIDERS = 3;
    uint256 public constant MAX_PRICE_AGE = 3600; // 1 hour
    uint256 public constant MAX_DEVIATION = 500; // 5%
    
    function updatePrice(
        address token,
        uint256[] memory proposedPrices,
        address[] memory providers
    ) external {
        require(proposedPrices.length >= MIN_PROVIDERS, "Insufficient providers");
        require(proposedPrices.length == providers.length, "Length mismatch");
        
        // Verify providers
        for (uint i = 0; i < providers.length; i++) {
            require(priceProviders[providers[i]], "Invalid provider");
        }
        
        // Calculate median
        uint256 medianPrice = calculateMedian(proposedPrices);
        
        // Check deviation
        for (uint i = 0; i < proposedPrices.length; i++) {
            uint256 deviation = proposedPrices[i] > medianPrice 
                ? ((proposedPrices[i] - medianPrice) * 10000) / medianPrice
                : ((medianPrice - proposedPrices[i]) * 10000) / medianPrice;
            
            require(deviation <= MAX_DEVIATION, "Price deviation too high");
        }
        
        prices[token] = PriceData({
            price: medianPrice,
            timestamp: block.timestamp,
            confidence: proposedPrices.length
        });
    }
}
```

### 4. Upgrade Safety

```solidity
contract UpgradeableImplementation is UUPSUpgradeable {
    // State variables
    uint256 public version;
    mapping(address => uint256) public balances;
    
    // Storage gap
    uint256[48] private __gap;
    
    // Only allow upgrades through governance
    function _authorizeUpgrade(address newImplementation) internal override {
        require(msg.sender == governance, "Not governance");
        require(newImplementation != address(0), "Invalid implementation");
        
        // Verify new implementation
        try IImplementation(newImplementation).version() returns (uint256 newVersion) {
            require(newVersion > version, "Invalid version");
        } catch {
            revert("Version check failed");
        }
    }
    
    // Safe migration function
    function migrate(bytes calldata data) external onlyProxy {
        require(version == 1, "Invalid version for migration");
        
        // Decode and validate migration data
        // Perform migration
        
        version = 2;
    }
}
```

---

## Additional Resources

### References
- [SWC Registry](https://swcregistry.io/) - Smart Contract Weakness Classification
- [Consensys Best Practices](https://consensys.github.io/smart-contract-best-practices/)
- [OpenZeppelin Security](https://docs.openzeppelin.com/contracts/4.x/)
- [Trail of Bits Security Guidance](https://github.com/crytic/building-secure-contracts)

### Tools
- **Slither**: Static analyzer
- **Mythril**: Symbolic execution
- **Echidna**: Fuzzing framework
- **Manticore**: Dynamic analysis
- **Foundry**: Testing and fuzzing

### Audit Firms
- Trail of Bits
- ConsenSys Diligence
- OpenZeppelin
- Certik
- Quantstamp

### Bug Bounties
- Immunefi
- HackerOne
- Code4rena
- Sherlock

---

## Conclusion

This catalog provides a comprehensive overview of smart contract vulnerabilities and attack vectors. Key takeaways:

1. **Defense in Depth**: Implement multiple security layers
2. **Regular Audits**: Both automated and manual reviews
3. **Stay Updated**: Monitor new attack vectors and compiler updates
4. **Test Thoroughly**: Include negative testing and fuzzing
5. **Incident Response**: Have a plan for discovered vulnerabilities

Remember that security is an ongoing process, not a one-time achievement. Regular reviews, updates, and monitoring are essential for maintaining secure smart contracts.